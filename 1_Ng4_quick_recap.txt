ngIf, ngFor, ngStyle, ngClass, ngSwitch, ngModel, (ngSubmit) = doSubmit() [for both template n reactive form], ngForm
*ngIf = "someconditionevaluatesToTrue"
*ngFor="let item of products"
ngswitch = [ngSwitch] *ngSwitchCase + *ngSwitchDefault 
eg.
	<ul *ngFor="let person of people"
	    [ngSwitch]="person.country"> 

	  <li *ngSwitchCase="'UK'" 
	      class="text-success">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'USA'"
	      class="text-primary">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'HK'"
	      class="text-danger">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchDefault 
	      class="text-warning">{{ person.name }} ({{ person.country }})
	  </li>
	</ul>`

Directives (selector) + Components (selector, template, styles, providers)
@Input, @Output
	eg.1. for Input:-
		@Input() hero: Hero;	// =OR=
  		@Input('master') masterName: string; // master is the alias for masterName and master will be used everywhere.
	eg.2. for output:-
	In some class
		@Output() valueChange = new EventEmitter();
		in some method:-
			this.valueChange.emit(this.counter); // where counter is a class variable.
			
@HostListener, @HostBinding, L88, 89 : used to create reactive directive
	- use them with directives
	HostListener:	(from @angular/core)	we can capture the events of the host-element (on which this directive sits).
		In Directive's class:
			ngOnInit(){ ... }
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
			}
	HostBinding: Alternative to renderer.   we can specify style-properties of the host-element(on which this directive sits).	
		- camelcase in 'style.backgroundColor' is VIMP!!!
		- needs to be used with a HostListener
		
		In Directive's class:
			@HostBinding('style.backgroundColor')tmpbackgroundColor: string;
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
				this.tmpbackgroundColor = 'blue';
			}
			
@Viewchild

Renderer, Renderer2 :- Renderer2 is used to write mobile + desktop code. no separate code for mobile.
RouterModule, Routes, Router, routerlinks, <router-outlet>, Navigation Paths, 
Navigating Programmatically, Using relative paths in navigating programmatically, L120
ActivatedRoutes, Passing Params to Routes, Fetching Route Params Reactively, Passing Query Params and Fragments, Common Gotchas (skipped)
ChildRoutes, queryParamsHandling, Redirecting and Wildcarding Routes, LocationStrategy
named router outlet 
	AppModule:-	
		import { RouterModule, Routes, Router, PreloadAllModules } from '@angular/router';
		const appRoutes: Routes = [{}, {}]; // Its an array of objects.
		
		- routerLink replaces href in an <a href...> and help with NOT reloading the page; href reloads the page i.e. it sends a request to the server
			[routerLink] = ['users']  // users is an absolute path.
			[routerLink] = ['./users']  // users is an relative path.
			You can use this relative syntax because routerLink is aware of which component u r currently on . Will give errors, if the path does not exist.
			
		- NavigationPaths:- if you use a relative path, then it becomes relative to the current comp (i.e. the component u are on).
							use absolute paths, to prevent breaking ur routes, unknowingly.
		- Navigating Programmatically:-  L120
			-- this.router.navigate(['/servers']);  /servers is an absolute path. and router: Router
		- Using relative paths in navigating programmatically, L121
			-- this.router.navigate(['servers']);	//servers is a relative path.
				// Unlike, routerLink, it WONT give errors, if the path does not exist. 
				// This is because Router does NOT know which component u r currently on. This is the difference between Router and RouterLink
		- To fix this use:- ActivatedRoute + optionsObj having relativeTo: route
			import { ActivatedRoute } from '@angular/router';
				route: ActivatedRoute
					-- this.router.navigate(['servers'], {relativeTo: this.route});	//servers is a relative path.	

		- Passing Params to Routes:
				{ path: 'users/:id', component: 'UserComp' },
				{ path: 'users/:id/:name', component: 'UserComp' },
			- In UserComp::ngOnInit()
				this.route.snapshot.params['id'], where route: ActivatedRoute
				this.route.snapshot.params['name'], where route: ActivatedRoute
		
			this.route.snapshot.params should be used ONLY for 1-time loading. For subsequent changes, use this.route.params (see below) 
		- Fetching Route Params Reactively
			- the above approach may break sometimes
			Problem eg.
				<a [routerLink] = "['/users', 10, 'Anna']"> Load Anna </a>
					>> The route changes, but the template does not change to reflect anna. (because Angular doesnt know the data in the template change)
					
			Solution :- 
			import { ActivatedRoute, Params } from '@angular/router';	
				// NOTE: this.route.params is an observable. 
				this.route.params.subscribe(
					params: Params {
					this.templatevar1 = params['id']
					this.templatevar2 = params['name']
				})
		- Passing Query Params and Fragments.		
			QueryParams: eg. ?mode=editing&name=plankton
			Fragments: eg. ?mode=editing#loading   (loading is a fragment)

			Passing Query Params and Fragments.	
			A.1.
				{ path: 'servers/:id/edit', component: 'ServComp' },
				+
				<a 
					[routerLink] = "['/servers', 5, 'Serv1']"
					[queryParams] = "{ allowEdit: '1'}"
					[fragment]="'loading'"
				> Server1 </a>
				
				Use:- [fragment]="'loading'"  -OR- fragment="loading"   // both are the same
				
			A.2.
				this.route.navigate(
										['/servers', id, 'edit'],  // 1st param
										{							// 2nd param is an options object
											queryParams: {allowEdit: '1'},
											fragment: 'loading'
										}
									)
		- 	Retrieve Query Params and Fragments:
				Retrieve using snapshot:- this.route.snapshot.queryParams -or- this.route.snapshot.fragment
				Retrieving reactively:- this.route.queryParams.subscribe();
										this.route.fragment.subscribe();
										
				Angular will unsubscribe automatically.
		- Common Gotchas: 
		- child routes: 
			{ path: 'servers/:id/edit', component: 'ServComp' , children: [{}]},
			and add a second <router-outlet></router-outlet>
		
		- queryParamsHandling: preserving queryParams when we navigate to another route.
			this.router.navigate(['servers'], 
									{relativeTo: this.route, queryParamsHandling: {'preserve'}
								);
			queryParamsHandling: {'preserve'}
			queryParamsHandling: {'merge'}
		- Redirecting and Wildcarding Routes	
				{ path: 'not-found', component: 'NotFoundComp' },
				{ path: '**', redirectTo: '/not-found' },   //NOTE:- its double **
			
		- LocationStrategy:-
				RouterModule.forRoot(appRoutes, { useHash: true });
				
				This will be useful when we deploy on Apache/ which will parse the string before the #; whereas angular will parse after the #.
		
		- named router outlet 
			https://www.concretepage.com/angular-2/angular-2-4-named-router-outlet-popup-example#navigate
			app.component.html
				<router-outlet></router-outlet>
				<router-outlet name="green"></router-outlet>
				<router-outlet name="red"></router-outlet>
				
			app-routing.module.ts
				import { RouterModule, Routes } from '@angular/routes';
				
				const appRoutes: Routes {

					{ path: 'color', component: 'colorcomp'},
					{ path: 'green', component: 'greencomp', outlet: 'green'},
					{ path: 'red', component: 'redcomp',  outlet: 'red'},
					{ path: '', redirectTo: '/color', pathMatch: 'full'},					
				}
				
				imports: [
					RouterModule.forRoot( appRoutes )
				],				
				
				exports: [ RouterModule ],  // this is very important because without this, u will get router-outlet unknown errors !!!
			
			ng g c red 
			ng g c green
			
		- How to detect route changes? 
		A. Subscribe to this.router.events . Events are like : // example: NavigationStart, RoutesRecognized, NavigationEnd
			For more events look at: 
				https://angular.io/api/router/RouterEvent
			
			https://toddmotto.com/dynamic-page-titles-angular-2-router-events 
			https://stackoverflow.com/questions/33520043/how-to-detect-a-route-change-in-angular
			this.router.events
			  .subscribe((event) => {
				if (event instanceof NavigationEnd) {
				  console.log('NavigationEnd:', event);
				}
			  });			
			
		A.2. 
		this.router.events
			.filter(event => event instanceof NavigationEnd)
			.map(() => this.activatedRoute)	// getting the activatedRoute at the end of NavigationEnd.
			.map(route => route.firstChild)
			.switchMap(route => route.data)
			.map(data => data['asdf'])
		
			
		
Guards L135
	- CanActivate, CanActivateChild, CanDeactivate, CanLoad, Resolve

	- canActivate
		{ path: 'comp', component: 'SomeComp', canActivate: [AuthGuard] },

		@Injectable()
		export class AuthGuard implements canActivate {
			// 2 I/p params: route: ActivatedRouteSnapshot, state: RouterStateSnapshot from '@angular/router'. Angular will give us this data.
			// O/p: Observable<boolean> | Promise<boolean> if async, boolean if ran synchronously.

			canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot ) : Observable<boolean> | Promise<boolean> | boolean {
				// check if user is logged in.
			}
		} // class ends
	
Pipes: 
Pure, PipeTransform, impurepipe, async pipe
	// default pipes: date, json 
	
	Create custom pipe:-
		filesize.pipe.ts 
			import { Pipe, PipeTransform } from '@angular/core';
			
			@Pipe({
				name: 'filesize'
			})
			export class FileSizePipe implement PipeTransform {
				transform( ipvalue: number, extension: string = 'MB' ) {
					return ( size/ (1024*1024)).toFixed(2)) + extension
				}
			} // class ends 
			
			{{ data | filesize: 'megabytes' }}  // if megabytes is no given as extension, default MB kicks in

	Pipes as providers/services:- transform() method is the key.
		In SomeComp:-
			import { FileSizePipe } ...
			providers: [ FileSizePipe ];
			
			constructor (
				private filesizePipe: FileSizePipe;
			){}
		
		
			// NOW WE CAN USE transform():- this.filesizePipe.transform( somevar, 'mb');
Module:
	- @NgModule (declarations, imports, providers, bootstrap) Note :- import is a TS-keyword, where imports:[] is an angular feature.
				(exports, etc.) 
	- Feature module: L271 , say RecipesModule
		- IMP NOTE:- You cannot declare components, directives and pipes, in more than 1 module. Duplications not allowed.
		- In RecipesModule, in @NgModule({}). add CommonModule from @angular/common to imports:[] array of the new Feature Module. Gives access to ngClass, etc.
			NOTE: The AppModule has BrowserModule, instead of CommonModule. BrowserModule is a superset of CommonModule.
		- Add RecipesModule to the AppModule.	
	- Registering routes to a feature module: L272
		- Maintain import order in the imports:[] array in AppModule. 
		- If routing is in an AppRoutingModule, it should be the last item in imports:[] array, so that all wildcards can be accounted for.
		- create RecipesRoutingModule.
			-- const recipesRoutes: Routes = [
					{ path: 'new', component: 'Parent1', children: [
							{ path: 'new', component: 'Comp1', canActivate: [AuthGuard] },
							{ path: '', redirectTo: 'DefaultComp', pathMatch: 'full' },
							{ path: ':id', component: 'Comp2' },
						] // children ends.
					}, // parent1 ends	
				]; // recipesRoutes ends
			-- NOTE:- RouterModule.forRoot() should ALWAYS be used in AppModule, RouterModule.forChild() should always be used in the child component.
			-- 
				@NgModule ({
					imports:[
						RouterModule.forChild(recipesRoutes)
					],
					exports: [RouterModule]			//<<<<===== NOTE how we are exporting from the current RecipesRoutingModule
				})
		- goto the feature module RecipesModule and add RecipesRoutingModule to the imports:[] array.
		- the feature module RecipesModule will be in the AppModule::imports:[]
	- Shared module
		-- AppModule = FeatureModule1 + FeatureModule2
						-- FM1 and FM2 uses SharedModule
						
		-- L274 
		-- shared/shared.module.ts 
			@NgModule({
				declarations: [
					DropDownDirective	// has to be declared ONCE, somewhere. Its accessible only in current module.
				],
				exports: [
					DropDownDirective	// so that it can be imported in FM1 and FM2. It should be be accessible outside too.
				],
			})
		-- Add SharedModule to the RecipesModule::imports:[]	
		-- Add SharedModule to the AppModule::imports:[]
	
	-- 	Another Feature Module : ShoppingListModule
		- import {CommonModule} from '@angular/common'
		- imports:[ CommonModule, FormsModule]
		- Add ShoppingListModule to AppModule.
		- For routing, we could use RouterModule.forChild() which is fine, but lets c another way i.e. "Loading Components Via Selectors":-
			Loading Components Via Selectors:- 
					- 1. include the <app-shopping-list> </app-shopping-list>, add it to the declarations:[] array. (else u will get errors)
				-- OR--
					- 2. u have to import (TS-style) a module, which exports app-shopping-list component. (this we already saw with RecipesRoutingModule/ RecipesModule ?)
					
					1. 
					- FormsModule can be a problem, if its used @ multiple places, then should be mentioned everywhere.
					- OR it should be exported . But its a bad practise to export a module from a FM1 to be used in FM2.
			
	- Lazy Loading: Improving App Performance
		(Note: Opp. of Lazy Loading is Eagerly Loading, which loads everything)
		AppModule
			-- RootRouter
				-- ChildRoutes
				
		FM1 (RecipesModule) :-
			-- child router 
			-- component
			-- directive
			
		All Angular code is downloaded at the beginning.	
		But, If the user NEVER visits the FM1, then that particular code is never used and we downloaded too much code at the beginning.
		We can lazyload, FM1 and its children.
			-- i.e. FM1 is loaded ONLY if the route for FM1 is hit.
			
			
	- Adding Lazy load to the RecipesModule		
		- ng g c home --spec false
		- { path: '', redirectTo: 'HomeComp'},
			- { path: 'recipes', component: RecipesModule }, // Before: EAGERLY LOADING
			- { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule', }, //After: LAZY LOADING.
					IMPNOTE:- loadChildren takes a string, which of the format: '<path>#<ModuleName>' 
		- restart ng serve
		- network tab: disable caching is checked
			-- check chunk.js was added when the route was requested for.
	
	- Protect Lazy loaded Routes with ...
		-- using canActivate with lazy loaded is useless as the code wont be reachable until the route is loaded.
		-- we need something which can help us check before the route is called.
		-- use canLoad guard.
			eg. - { path: 'recipe', loadChildren: './recipes/recipe.module#RecipesModule', canLoad: [AuthGuard] }, 
			Note: AuthGuard should implement the "canLoad" interface.
			
	- Understanding Modules & Service Injection (when using FMs and Lazy Loaded modules)
		eg. 1. 
		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			Because, FM1 is injected into AppModule, using it at two places, wont hurt as the Root Injector will create ONLY one instance of the Serv1.
			LLM1, since its lazy loaded will also use the same global instance of Serv1 (provided by the Root Injector).	
			
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since no providers are used, LLM1 also uses the global instance of Serv1
			
		eg. 2. 	
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , providers: Serv1
			Here, LLM1, angular will create a child injector i.e. a local instance of Serv1.
	
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since providers are used @ module level, LLM1 will use a local instance of Serv1.
			
		Q. In eg.1., can FeatureModule1 be forced to use a local instance of Serv1 ?
		A. Yes, it can be done.
			If FeatureModule1, needs to be forced to use a local instance of Serv1, Serv1 should be removed from FeatureModule1::providers[] 
				and should be added to its child comp., say FMChild1::providers[]
				
		Q. In eg.1., 		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			SharedModule (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			(i.e. AppModule, FM1 and SharedModule are eagerly loaded)

			- Here, SharedModule will have access to global instance of Serv1 
			- LLM1 will NOT have global instance, it will have a local instance of Serv1. 
			- So, be very careful when adding services to SharedModule !!!
			
			V. V.IMP:- DO NOT add services to shared modules, especially, if those services will be used in Lazy Loaded Modules !!!!

	- Understanding the core module:-
			AppModule: AppComponent + Component + Directive 
									> Component + Directive should be move to a Core Module, because they apply to our App Module.
	- Core module 
			- will be used ONLY in AppModule.
			- should NOT be used anywhere else like LLM, SharedModule or FM1.
			- U can move providers (services) from AppModule to CoreModule. Keeping the AppModule leaner is a good practise.
			- CoreModule should ALWAYS be eagerly loaded.
	- Ahead of time compilation
			- 2 types of compiling the code. :- JIT or AOT.
				-- What is compiling the code? It does NOT mean angular is moving TS code to ES5, that is done by the cli.
					A. Angular needs to compile ur templates by parsing. It moves html-code to JS-code. (html-elements have JS-equivalents).
					   Ang. does this because accessing JS-equivalents is much faster than parsing DOMs.
				Such compilation can be done using Just in Time / Ahead of time compilation.		
			- Just in time:- is default and what we regularly do using ng-serve
				-- Development -> production -> App downloaded to browser -> Angular parses and compiles the templates to JS
				Here, in the last step, parsing and compilation happens on the browser.
				- Bulkier. Because the compiler is shipped.
			-- Ahead of time:-
				-- Development -> Angular parses and compiles the templates to JS -> Production -> App downloaded to browser
				This has advantages:-
				- Faster startup. ZERO parsing and compilation on the browser.
				- Templates are checked during development.
				- Smaller File Size. Compiler is NOT shipped. Any other features which are NEVER used are never shipped.
				
			AOT using cli:-
			- open network tab and the vendor.js/anyother file are very bulky. It has the compiler and so on.
			- cancel "ng serve"
			- ng build (uses JIT)
			- ng build --prod (uses minification + JIT )
			- ng build --prod --aot (uses minification + AOT)
			- see dist folder and check sizes of all files.
			
			Usually servers gzip it, but that is another discussion.
			
	- Pre-Loading lazy loaded routes
			- if LL, u will load the chunk of LLMs at that time, when the route is visited, so there may be a lag of few secs.
			- it would be nice to use LL, but still pre-load the code, so that there is no lag.
			
			AppRoutingModule, where we define all our routes.
			import { Routes, RouterModule, PreloadAllModules } from '@angular/router';

			before:- RouterModule.forRoot(appRoutes)	// Hidden Default is { preloadingStrategy: DontPreload }		// ???
			after:- RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules } // This property takes a type-definition. PreloadAllModules
										); 
Observable
	- operators
	- queryparams L126, L127
Subjects:-
	- using them as observables
Template-driven:- 
	- form
Reactive-driven:- L193:  @angular/forms
	- form
		this.signupForm = new FormGroup({
			'username' : new FormControl (null),
			'email': new FormControl (null),
			'gender': new FormControl('male'),
		});
		
		- sync HTML template with FormGroup, using formControlName
			<form [formGroup]="signupForm">
				<input ... id="username" formControlName ="username" ... >
				<input ... id="email" formControlName ="email" ... >
				<input ... id="gender" formControlName ="gender" ... >
				
		- submit the form using ngSubmit
				<form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
					<input ... id="username" formControlName ="username" ... >
					<input ... id="email" formControlName ="email" ... >
					<input ... id="gender" formControlName ="gender" ... >		
					
				onSubmit(){ ... }	
	- Validators
		this.signupForm = new FormGroup({
			'username' : new FormControl (null, Validators.required), // DO NOT execute it like Validators.required(); angular will do that.
			'email': new FormControl (null, [Validators.required, Validators.email]),
			'gender': new FormControl('male'),
		});
		
	- Getting access to controls:-
		<span *ngIf="signupForm.get('username').valid && signupForm.get('username').touched">  // Note:- .get(name) or path-to-the-name, if its nested.
			...
		</span>
	- 		
Life-cycle hooks:- https://codecraft.tv/courses/angular/components/lifecycle-hooks/ 
	- (hooks are executed in this order)
		- constructor, 
		- ngOnChanges (invoked when input properties are changed), ngOnInit (invoked on initialized, invoked ONLY ONCE after the 1st ngOnChanges), 
		- ngDoCheck (invoked when the change detector of the given component is invoked, allows us to implement alternative change detection algo).
			IMP: ngDoCheck and ngOnChanges should NOT be implemented on the SAME Component
		- ngOnDestroy
			-- invoked just before angular destroys the component.
	- Hooks for the components children	
			-- ngAfterContentInit ( invoked after any content projection is done into the components-view. )
			-- ngAfterContentChecked ( invoked each time the CONTENT of the given component has been checked. )
			-- ngAfterViewInit ( invoked when the components view has been fully initialized)
			-- ngAfterViewChecked ( invoked each time the VIEW of the given component has been checked. )
	
	- ngOnChanges eg.
		ngOnChanges(changes: SimpleChanges) {
		  console.log(`ngOnChanges - data is ${this.data}`);
		  for (let key in changes) {
			console.log(`${key} changed.
		Current: ${changes[key].currentValue}.
		Previous: ${changes[key].previousValue}`);
		  }
		}	
			
Types of communications:- https://angularfirebase.com/lessons/sharing-data-between-angular-components-four-methods/
	- Parent to child
	- child to parent using ViewChild 
	- child to Parent using @output + EventEmitter
	- Using Subjects/BehaviorSubjects
Simple API unit testing using jasmine
Angular animations

Ultimate angular:-
- Content Projection n its types
	ng-content :- to form pieces of the form. 
		eg.1. simple ng-content
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> ></auth-form>
						<auth-form () = "" <h3>Login<h3> ></auth-form>
			AuthFormComp: Put <ng-content></ng-content> as placeholder, to show where the h3 should be inserted.
		
		eg.2. ng-content with projection/injection slots. (same for login)
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> 
										   <button type="submit">Join Us</button>
						></auth-form>
						
			AuthFormComp: 
						<ng-content select="h3"></ng-content>		where it requires to be projected/injected
						<ng-content select="button"></ng-content>	where it requires to be projected/injected

			Do same for Login
			
		eg.3. Content-project a component & bind to it 
			AuthRemember:
			AppComp: 
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>	
			checked is of EventEmitter
			
			AuthFormComp: 
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<ng-content select="button"></ng-content>	
						
			Note:= we can also use <ng-content select = ".somecssclass"	> </ng-content>		
			Binding can be done using class-var.
			
		eg.4. @ContentChild and ngAfterContentInit
			In eg.3., h3, auth-remember and button are contentchild of auth-form 
			
			AuthFormComp:
				
				In its template:-
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<div *ngIf="showMessage"> 
							You will be logged in for 30 days.
						</div>
						<ng-content select="button"></ng-content>	
			
				import { AuthRememberComp } from '';  // We r importing, so that we can query it after the content has been initialized.
				import { ContentChild, AfterContentInit} ... 
				
				@ContentChild(AuthRememberComp) remember: AuthRememberComp ;
				
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.checked.subscribe( (checked: boolean) => {
							this.showMessage = checked;
						});
					}
				}
			
			
		eg.5. @ContentChildren and QueryLists
				
				AppComp: 
			
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>
			
			
				import { ContentChildren, QueryList, AfterContentInit} ... 
				@ContentChildren(AuthRememberComp) remember: QueryList<AuthRememberComp> ;
			
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.forEach( (item) => {
							item.checked.subscribe( (checked:boolean) => this.showMessage = checked; );
						});
					}
				}
			
			
		eg.6. ViewChild and ngAfterViewInit 
		
				AuthMessageComp: 
					<div *ngIf="showMessage"> 
							You will be logged in for 7 days.
						</div>
						
				Pending.		
					
		eg.7. ViewChildren and ngAfterViewInit 	
			
						
- ngTemplateOutletContext

- Change Detection & immutability:
	OnPush + Immutable Data Objects :- Angular is faster when using immutable objects;
	We can build stateless/presentation/dummy components. (?)
	
	SomeComp:-
		changeDetection: ChangeDetectionStrategy.Default
		changeDetection: ChangeDetectionStrategy.OnPush 
		
- Dynamic components using ComponentFactoryResolver:-
	What we are going to do:-
		import {AuthFormComp}...
		<div>					// this serves as a container
			<div #entry></div>  // We will use the ComponentFactoryResolver to inject the AuthFormComp here. We will create a factory method for it.
		</div>
		- Note:  @Output()Submitted = new EventEmitter(); 

	App Comp implement AfterContentInit:-
		@ViewChild('entry', { read: ViewContainerRef}) entry: ViewContainerRef;  
		// the 2nd param here by default is an ElementRef, until we explicitly ask for a ViewContainerRef
		
		constructor(
			private resolver: ComponentFactoryResolver		// from @angular/core
		){}
	
		ngAfterContentInit() {
			const authFormFactory = this.resolver.resolveComponentFactory(AuthFormComp);
			const component = this.entry.createComponent(authFormFactory); // We will get error. Add entryComponents:[AuthFormComp] to auth-form.module.ts 
		}
		
		

Services:- egghead:-
Interceptors:-

PrimeNg:-
	PrimeNg v4.1, font-awesome v4.7.0
		npm install primeng --save 
		npm install primeicons --save
		npm install font-awesome --save 
		npm install @angular/animations --save 
	
	angular-cli.json:-
		styles: [ font-awesome.min.css, primeng/resources/themes/omega/theme.css, primeng/resources/primeng.min.css ]
	module.ts: 
		import { BrowserModule } from '@angular/platform-browser';
		import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
		import { AngularFontAwesomeModule } from 'angular-font-awesome';
		import { AccordionModule } from 'primeng/components/accordion/accordion';
		import { MenuItem } from 'primeng/components/accordion/accordion';
		import { MenuModule, MenubarModule } from 'primeng/primeng';

		Add to imports:[]

	AppComp:-
		{
			label: 'label1',
			icon: 'edit',
			items: [
				{label: 'Undo', icon: 'fa-mail-forward'}.
				{label: 'Undo', icon: 'fa-mail-forward'}
			]
		}
		
	<link rel="stylesheet" type="text/css" href="/node_modules/primeicons/primeicons.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/themes/omega/theme.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/primeng.min.css" />
	
---
	ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
	app/app-routing.module.ts
		
		- RouterModule.forRoot(appRoutes);
		
			@NgModule({ 
				imports: [ RouterModule.forRoot(appRoutes) ],
				Exports: [ RouterModule ]
			})
			
			export class AppRouting {}
		
		- <router-outlet></router-outlet> 
		
		
---

ElementRef,
ViewContainerRef, ViewContainerRef::createEmbeddedView, TemplateRef<any>, 
OOS:- ViewContainerRef::createComponent()

---
http://qnimate.com/post-series/ecmascript-6-complete-tutorial/ 

ES6:-
- call, apply & bind
	Obj1: properties & methods 	 
	Obj2: properties & methods 
	
	var obj = { num: 10};
	var addToThis = function (p1) {
		return this.num + p1;  // num is not yet accessible here
	};
	addToThis.call(obj, 20); //fn-name.call(obj, fn-args);
	addToThis.apply(obj, [20, 30]);
	addToThis.bind(obj, [20, 30])(); // bind returns a call

- Spread (... operator). 
	[1,2,3] ==> ...numbersArray
- Generics, interfaces
	interface:- is a contract that needs to be implemented.
	generics:- allow us to be less flexible 
		let numberArray: Array<number>;
- type alias

---

Angular Material Design:- Adding a custom theme 
	http://github.com/angular/material2

style.scss
	/* You can add global styles to this file, and also import other style files */

	@import "~@angular/material/theming";	// actual filename is _theming.scss, _ because its a partial. sass pre-processor ignores _ files.

	// Include non-theme styles for core.
	@include mat-core();

	// Define a theme.
	$primary: mat-palette($mat-pink);	// -OR- mat-palette($mat-indigo)  -OR-  $mat-red
	$accent:  mat-palette($mat-deep-purple, A200, A100, A400);	// -OR- $mat-pink

	$theme: mat-light-theme($primary, $accent); // we could also use mat-dark-theme().

	// Include all theme styles for the components.
	@include angular-material-theme($theme);

Add to to styles: [] in angular.json and restart ng serve

---

Rxjs6 In Practise:-
		Rxjs6:-
		git clone https://github.com/angular-university/rxjs-course.git
		git checkout -b 1-operators

		npm start (will start the dev-server which provides courses & lessons rest apis)

		interval(1000), timer(3000, 1000), fromEvent(document, 'click');

		1. 
		Non-Completing streams:- keeps emitting, but never completes.
			document.addEventListener('click', (event) => {
				console.log (event);
			});
			
			const counter = 0;	// emits a value after every 1 sec but never completes.
			setInterval(() => { counter++; c.log(counter); }, 1000);

		Completing stream:- executes only once.
			setTimeout(() => { console.log('Finished...'); }, 3000);
			
		2.
		Observable is a blueprint of a stream.
		subscribe() gives us an instance of the stream.
		 
			const interval$ = interval(1000); // rxjs interval() does same thing as setInterval();
			interval$.subscribe(	// instance of a stream.
				(val) => { console.log(val); }
			);
			interval$.subscribe(
				(val) => { console.log(val); }
			);
			
		3.	Wait for 3 seconds and then emit the values. Use timer()
				const interval$ = timer(3000, 1000);	// waits for 3 seconds before starting to emit.
				interval$.subscribe(
					(val) => { console.log(val); }
				);
				
		4. Define a stream of clicks: use fromEvent()

				const click$ = fromEvent(document, 'click');
				click$.subscribe(	// instance of a stream.
					(event) => { console.log(event); }
				);
			
		5. Stream Errors & Stream Completion.

				click$.subscribe(
					(event) => {},
					(err) => {},
					() => { console.log ('completed'); }
				);

			Subscription & Cancellation using unsubscribe
				// subscription
				const subscription = interval$.subscribe(	// instance of a stream.
										(val) => { console.log(val); }
									);
				
				// cancellation/unsubscribe
				subscription.unsubscribe();					
				
		6.  
		- How do observables work under the hood?
		- Build ur own http observable.

		fetch() is a browser api. it can be used to call rest apis.
		fetch('/api/courses') will return a promise.
			- promise get executed as soon as they r defined.
			-	observer.next()  to emit a value. will only be called on subscribe() call.
				observer.error()
				observer.complete() to complete it.
				

			const http$ = Observable.create( observer => {
				fetch('/api/courses')
					.then( response => response.json())  // response.body(), response.ok(), response.status() are few other.
					.then ( body => {					 // body here meants the json-body/json-data
						observer.next(body);
						observer.complete();
					})
					.catch ( err => {
						observer.error(err);
					})
					;	
			});

			http$.subscribe(
				( data ) => console.log(courses),
				noop, // -OR- ( err ) => {}, // noop is an rxjs function for no operation
				() => {}
			);
			
		7. 
			pipe operator: chain multiple observables eg. pipe(map ( ... ) )
			Map operator: eg. map (x => 10*x)
			
			const courses$ = http$.pipe(
				map( res => Object.values (res["payload"]) );	// payload is a property which has array of objects. REST API response is : obj-of-payload: Arr-of-objects
			);
			
			courses$.subscribe( ... );
		---

		L10:- stopped. to be continued later.
			
---

morgan project:-

ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
- json server for products 
	-- unit test for same
- App Routing Module
app.module.ts
		-> imports app-routing.module.ts			
			-> imports FM products.modules.ts
			-> imports CommonModule
				-> declarations + imports products.component.ts
		-> exports RouterModule + FM Products Module		
		
- Products Featured Module ( Component + Service + Directive ) 
		Products.Component.ts	
			-- dispatch an action 
			-- reducer
				-- products service
			-- comp has data 
			
npm install @ngrx/core @ngrx/store --save
create store/
	step 1: create App level interface AppStore (app.store.ts).
			>>  { products: any } 
	
	step 2: StoreX.module.ts  (StoreXModule class)
		Maps interface-keys of app.store.ts to reducers (defined in various *.reducer.ts file) using ActionReducerMap<AppStore>
			>> 
				export const reducers: ActionReducerMap<AppStore> = {
					products: ProdReducer.productreducerFn
				};
			
				import * as ProdReducer from './product.reducer';
				NOTE.:- productreducerFn in ProdReducer.productreducerFn will be an exported function name "productreducerFn"
	
	step 3: store/reducers/products.reducer.ts
			export function productreducer(state = initialState, action, any) {}
				where 
					- initialState implement an interface like IProducts for string-type.
					- action is of type any for now, but it should change to ALLACTIONS (from store/actions/products.action.ts)

	step 4: store/actions/products.actions.ts 
			- import { Action } from 'ngrx/store';
			- export type AllActions = Class1implementsAction | Class2implementsAction ;
			
			- export class class1 implements Action {  // Here u can name the class1 anything, its not of significance outside this file.
					readonly type = someConstValue;	   // This is v.imp
				}
				
			- export const someConstValue = 'GetProducts'; // RHS is very imp. Will be used in the switch-case in the reducers.	

			eg. 
				import { Action } from 'ngrx/store';
				export const getProducts = 'GetProducts';
				export class FetchProducts implements Action {
					readonly type = getProducts;
				}
				export type ALLACTIONS = FetchProducts;

- Shared Module
	- Shared components ( Prime Ng )
		-- Data Table Component
		-- Shared Prime Ng button.
- Ngrx
	- Storemodule
	- action creators, reducer
	- Unit test for reducer

	
