String Interpolation:-
{{ classvar }} // will be a class variable.
{{ classmethod() }} // Works, but Dont do this as it will call it multiple times

Property binding:-
[disabled] = "some property name"

String Interpolation can be replaced with property binding:-
before:- <p> {{ someclassvar }} </p>
after:- <p [innertext]="someclassvar"> </p>	DONT DO:- <p [innertext]="{{someclassvar}}"> </p>

Event Binding:-
	(click) = "callSomeMethod()"   // VanillaJS:- onClick = "doSomething()"
Passing Data with EventBinding:-
	(input) = "doSomething($event)" // $event will give access to data like clicked-details, etc.
	where,
		doSomething(ev: any) {
			c.log( ev.target.value ); // where target shows the html-element on which the event occured.
		}
---
ngIf, ngFor, ngStyle, ngClass, ngSwitch, ngModel, (ngSubmit) = doSubmit() [for both template n reactive form], ngForm

<input ... ngModel name="email">
<input ... ngModel name="email" #email="ngModel"> (for displaying custom errors)

<div ... ngModelGroup="customKeyInNgFormObject"> </div>
<div ... ngModelGroup="customKeyInNgFormObject" #customKeyInNgFormObject="ngModelGroup"> ... </div> (for displaying custom errors)

Note:- (for displaying custom errors), u can use like email.invalid && email.touched, etc.
---

*ngIf = "someconditionevaluatesToTrue"
*ngFor="let item of products"
ngswitch = [ngSwitch] *ngSwitchCase + *ngSwitchDefault 
eg.
	<ul *ngFor="let person of people"
	    [ngSwitch]="person.country"> 

	  <li *ngSwitchCase="'UK'" 
	      class="text-success">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'USA'"
	      class="text-primary">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'HK'"
	      class="text-danger">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchDefault 
	      class="text-warning">{{ person.name }} ({{ person.country }})
	  </li>
	</ul>`

ngModel: 2-way data binding = EventBinding + PropertyBinding
[(ngModel)] = "somevar" + {{somevar}}
Using ngModel is considered a better way, than to pass $event around. See doSomething($event) above.

---
ngIf and ngFor: Rabbits hole. (uses ng-template)

1. *ngIf="someexpressionWhichReturnsTrue" eg. *ngIf="1===1" and it will work.
2. ngIf + else.
	>> semi-colon, else condition requires <ng-template> + local-reference
	<p *ngIf="someexpression; else noServerCondition"> iftext1 </p>
		<ng-template #noServerCondition> 
			<p> elseText </p>
		</ng-template>
output:-  iftext1 is shown if condition is true, else elseText is shown.
3. ngIf + then + else
	>> semi-colon, then-condition && else-condition requires <ng-template> + local-reference
	<p *ngIf="someexpression; then thenTemplate else elseTemplate"> iftext1 </p>
		<ng-template #thenTemplate>ThenText1</ng-template>
		<ng-template #elseTemplate>ElseText1</ng-template>
output:-
	if condition is true, thenTemplate is shown, else elsetemplate is shown.
	NOTE:= iftext1 will NEVER BE shown. This is a gotcha. so be careful when using ngIg-then-else
	
---
*ngIf deeper, *ngFor deeper

1. <p *ngIf = "someconditionevaluatesToTrue"> </p>
Angular does this:-
   <ng-template	[ngIf] = "someconditionevaluatesToTrue">
   	<p> ,,,, </p>
   </ng-template>
   Note:- [ngIfElse]="someotherconditiion"
2.    
<ul *ngFor="let item of products"> //NOTE: let is mandatory
Angular does this internally:-
  <ng-template ngFor let-item [ngForOf] = "products" let-i = "index">
  	<p> .... </p>
  </ng-template>

Variations:-
	<ul *ngFor="let item of products; let i = index"></ul>
	<ul *ngFor="let item of products; index as i"></ul>
	<ul *ngFor="let item of products; let i = index; let even = even; let odd=odd"></ul>
  	<tr *ngFor="let employee of employees; trackBy: trackByEmpcode">
	NOTE:- ngFor may perform poorly with large lists; recreating the whole table on small changes; this is bcoz angular doesnt know its dealing with the same obj. When trackBy is used, angular only does incremental changes to the DOM.
---

Q. How to create your own ngIf:- eg. myNgIf
A.1. Use ViewContainerRef + ViewContainerRef::CreateEmbeddedView() + TemplateRef<obj|any>
A.2. Use ng-container + ngTemplateOutlet + context-obj.

A.1. 
	ng g d myNgIf
	constructor (
		private  viewContainerRef: ViewContainerRef, private templateRef: TemplateRef<Object>
	){}
	ngOnInit(){
		const condition = true;
		if (condition ) { this.viewContainerRef.createEmbeddedView (this.templateRef); }
		else { this.viewContainerRef.clear(); }
	}

	<p *myNgIf> ... </p> -OR- <ng-template myNgIf> </ng-template> (NOTE: no asterisk)
	PS: We can add @Input to make RHS accept conditions.

A.2.
ng-container + ngTemplateOutlet + context-obj (helps with interpolation) + ng-template.

2.1
   Inside class have an obj ready 
   	ctx = { estimate: 10}; // NOTE: if more than 1 properties, then more let-variables can be used.

	<ng-container *ngTemplateOutlet="loadingTemplate; context: ctx"></ng-container>
	<ng-template #loadingTemplate let-var1 = "estimate">
		<p>loading {{ var1 }} pages ... </p>
	</ng-template>
>> ng-container is the table on which the template is laid and the context is interpolated into the template
>> let-variables are in local template-context meaning, access to them is not available from outside.
>> Note: if a let-variable does not have a RHS value assigned to it, then it latches up to $implicit; if more than one let-vars dont have RHS vallue, then all such let-vars are initialized to $implicit.
	ctx = { estimate: 10}; can be rewritten as ctx = { $implicit: 'World' };
>> *ngTemplateOutlet is of type TemplateRef<any>
   *ngTemplateOutletContext is of type Object. (We may see this later in ultimate angular)
---

<p [ngStyle] = "{backgroundColor: getColor()}"
   [ngClass] = "{somecsscolor: somevar === 'true' }"	> </p>
   
---
Directives (selector) + Components (selector, template, styles, providers)
@Input, @Output
	eg.1. for Input:-
		@Input() hero: Hero;	// =OR=
  		@Input('master') masterName: string; // master is the alias for masterName and master will be used everywhere.
	eg.2. for output:-
	In some class
		@Output() valueChange = new EventEmitter();
		in some method:-
			this.valueChange.emit(this.counter); // where counter is a class variable.

----
Types of component communication:-
1. Parent-to-child using @Input
2. Child-to-parent using @Output + EventEmitter
3. Child-to-parent using @Viewchild + ngAfterViewInit()
	@ViewChild(ChildComponent) child; 
	message:string;

	ngAfterViewInit() {
	   this.message = this.child.message
	}
4. Unrelated Components: Sharing Data with a Service
	To keep them in sync: use a global service-providers
	To keep one of them out of sync: use a local service-providers in that comp., which needs to be out of sync
	
	https://angularfirebase.com/lessons/sharing-data-between-angular-components-four-methods/	
	This is applicable for unrelated-parents/siblings.
	
	Why BehaviorSubject ?:-
	> It will always return the current value on subscription - there is no need to call onnext
	> It has a getValue() function to extract the last value as raw data.
	> It ensures that the component always receives the most recent data.
	
	(may not work, put in here as a reference only.)
	eg. 4.1. The service
		@Injectable()
			export class DataService {

			  private messageSource = new BehaviorSubject('default message');
			  currentMessage = this.messageSource.asObservable(); // NOTE:= currentmessage will be used to get curr. val.

			  constructor() { }

			  changeMessage(message: string) {
			    this.messageSource.next(message)
			  }
	4.2 Parent comp:-
		ngOnInit() {
		    this.data.currentMessage.subscribe(message => this.message = message)
		  }
		  
	4.3 Sibling comp:-
		ngOnInit() {
   		  this.data.currentMessage.subscribe(message => this.message = message)
  		}

		  newMessage() {
		    this.data.changeMessage("Hello from Sibling")
		  }
----

@HostListener, @HostBinding, L88, 89 : used to create reactive directive
	- use them with directives
	HostListener:	(from @angular/core)	we can capture the events of the host-element (on which this directive sits).
		In Directive's class:
			ngOnInit(){ ... }
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
			}
	HostBinding: Alternative to renderer.   we can specify style-properties of the host-element(on which this directive sits).	
		- camelcase in 'style.backgroundColor' is VIMP!!!
		- needs to be used with a HostListener
		
		In Directive's class:
			@HostBinding('style.backgroundColor')tmpbackgroundColor: string;
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
				this.tmpbackgroundColor = 'blue';
			}
			
@Viewchild

Renderer, Renderer2 :- Renderer2 is used to write mobile + desktop code. no separate code for mobile.
RouterModule, Routes, Router, routerlinks, <router-outlet>, Navigation Paths, 
Navigating Programmatically, Using relative paths in navigating programmatically, L120
ActivatedRoutes, Passing Params to Routes, Fetching Route Params Reactively, Passing Query Params and Fragments, Common Gotchas (skipped)
ChildRoutes, queryParamsHandling, Redirecting and Wildcarding Routes, LocationStrategy
named router outlet 
	AppModule:-	
		import { RouterModule, Routes, Router, PreloadAllModules } from '@angular/router';
		const appRoutes: Routes = [{}, {}]; // Its an array of objects.
		
		- routerLink replaces href in an <a href...> and help with NOT reloading the page; href reloads the page i.e. it sends a request to the server
			[routerLink] = ['users']  // users is an absolute path.
			[routerLink] = ['./users']  // users is an relative path.
			You can use this relative syntax because routerLink is aware of which component u r currently on . Will give errors, if the path does not exist.
			
		- NavigationPaths:- if you use a relative path, then it becomes relative to the current comp (i.e. the component u are on).
							use absolute paths, to prevent breaking ur routes, unknowingly.
		- Navigating Programmatically:-  L120
			-- this.router.navigate(['/servers']);  /servers is an absolute path. and router: Router
		- Using relative paths in navigating programmatically, L121
			-- this.router.navigate(['servers']);	//servers is a relative path.
				// Unlike, routerLink, it WONT give errors, if the path does not exist. 
				// This is because Router does NOT know which component u r currently on. This is the difference between Router and RouterLink
		- To fix this use:- ActivatedRoute + optionsObj having relativeTo: route
			import { ActivatedRoute } from '@angular/router';
				route: ActivatedRoute
					-- this.router.navigate(['servers'], {relativeTo: this.route});	//servers is a relative path.	

		- Passing Params to Routes:
				{ path: 'users/:id', component: 'UserComp' },
				{ path: 'users/:id/:name', component: 'UserComp' },
			- In UserComp::ngOnInit()
				this.route.snapshot.params['id'], where route: ActivatedRoute
				this.route.snapshot.params['name'], where route: ActivatedRoute
		
			this.route.snapshot.params should be used ONLY for 1-time loading. For subsequent changes, use this.route.params (see below) 
		- Fetching Route Params Reactively
			- the above approach may break sometimes
			Problem eg.
				<a [routerLink] = "['/users', 10, 'Anna']"> Load Anna </a>
					>> The route changes, but the template does not change to reflect anna. (because Angular doesnt know the data in the template change)
					
			Solution :- 
			import { ActivatedRoute, Params } from '@angular/router';	
				// NOTE: this.route.params is an observable. 
				this.route.params.subscribe(
					params: Params {
					this.templatevar1 = params['id']
					this.templatevar2 = params['name']
				})
		- Passing Query Params and Fragments.		
			QueryParams: eg. ?mode=editing&name=plankton
			Fragments: eg. ?mode=editing#loading   (loading is a fragment)

			Passing Query Params and Fragments.	
			A.1.
				{ path: 'servers/:id/edit', component: 'ServComp' },
				+
				<a 
					[routerLink] = "['/servers', 5, 'Serv1']"
					[queryParams] = "{ allowEdit: '1'}"
					[fragment]="'loading'"
				> Server1 </a>
				
				Use:- [fragment]="'loading'"  -OR- fragment="loading"   // both are the same
				
			A.2.
				this.route.navigate(
										['/servers', id, 'edit'],  // 1st param
										{							// 2nd param is an options object
											queryParams: {allowEdit: '1'},
											fragment: 'loading'
										}
									)
		- 	Retrieve Query Params and Fragments:
				Retrieve using snapshot:- this.route.snapshot.queryParams -or- this.route.snapshot.fragment
				Retrieving reactively:- this.route.queryParams.subscribe();
										this.route.fragment.subscribe();
										
				Angular will unsubscribe automatically.
		- Common Gotchas: 
		- child routes: 
			{ path: 'servers/:id/edit', component: 'ServComp' , children: [{}]},
			and add a second <router-outlet></router-outlet>
		
		- queryParamsHandling: preserving queryParams when we navigate to another route.
			this.router.navigate(['servers'], 
									{relativeTo: this.route, queryParamsHandling: {'preserve'}
								);
			queryParamsHandling: {'preserve'}
			queryParamsHandling: {'merge'}
		- Redirecting and Wildcarding Routes	
				{ path: 'not-found', component: 'NotFoundComp' },
				{ path: '**', redirectTo: '/not-found' },   //NOTE:- its double **
			
		- LocationStrategy:-
				RouterModule.forRoot(appRoutes, { useHash: true });
				
				This will be useful when we deploy on Apache/ which will parse the string before the #; whereas angular will parse after the #.
		
		- named router outlet 
			https://www.concretepage.com/angular-2/angular-2-4-named-router-outlet-popup-example#navigate
			app.component.html
				<router-outlet></router-outlet>
				<router-outlet name="green"></router-outlet>
				<router-outlet name="red"></router-outlet>
				
			app-routing.module.ts
				import { RouterModule, Routes } from '@angular/routes';
				
				const appRoutes: Routes {

					{ path: 'color', component: 'colorcomp'},
					{ path: 'green', component: 'greencomp', outlet: 'green'},
					{ path: 'red', component: 'redcomp',  outlet: 'red'},
					{ path: '', redirectTo: '/color', pathMatch: 'full'},					
				}
				
				imports: [
					RouterModule.forRoot( appRoutes )
				],				
				
				exports: [ RouterModule ],  // this is very important because without this, u will get router-outlet unknown errors !!!
			
			ng g c red 
			ng g c green
			
		- How to detect route changes? 
		A. Subscribe to this.router.events . Events are like : // example: NavigationStart, RoutesRecognized, NavigationEnd
			For more events look at: 
				https://angular.io/api/router/RouterEvent
			
			https://toddmotto.com/dynamic-page-titles-angular-2-router-events 
			https://stackoverflow.com/questions/33520043/how-to-detect-a-route-change-in-angular
			this.router.events
			  .subscribe((event) => {
				if (event instanceof NavigationEnd) {
				  console.log('NavigationEnd:', event);
				}
			  });			
			
		A.2. 
		this.router.events
			.filter(event => event instanceof NavigationEnd)
			.map(() => this.activatedRoute)	// getting the activatedRoute at the end of NavigationEnd.
			.map(route => route.firstChild)
			.switchMap(route => route.data)
			.map(data => data['asdf'])
		
			
		
Guards L135
	- CanActivate, CanActivateChild, CanDeactivate, CanLoad, Resolve

	- canActivate
		{ path: 'comp', component: 'SomeComp', canActivate: [AuthGuard] },

		@Injectable()
		export class AuthGuard implements canActivate {
			// 2 I/p params: route: ActivatedRouteSnapshot, state: RouterStateSnapshot from '@angular/router'. Angular will give us this data.
			// O/p: Observable<boolean> | Promise<boolean> if async, boolean if ran synchronously.

			canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot ) : Observable<boolean> | Promise<boolean> | boolean {
				// check if user is logged in.
			}
		} // class ends
	
Pipes: 
Pure, PipeTransform, impurepipe, async pipe
	// default pipes: date, json 
	
	Create custom pipe:-
		filesize.pipe.ts 
			import { Pipe, PipeTransform } from '@angular/core';
			
			@Pipe({
				name: 'filesize'
			})
			export class FileSizePipe implement PipeTransform {
				transform( ipvalue: number, extension: string = 'MB' ) {
					return ( size/ (1024*1024)).toFixed(2)) + extension
				}
			} // class ends 
			
			{{ data | filesize: 'megabytes' }}  // if megabytes is no given as extension, default MB kicks in

	Pipes as providers/services:- transform() method is the key.
		In SomeComp:-
			import { FileSizePipe } ...
			providers: [ FileSizePipe ];
			
			constructor (
				private filesizePipe: FileSizePipe;
			){}
		
		
			// NOW WE CAN USE transform():- this.filesizePipe.transform( somevar, 'mb');

few examples:-
{{ text | shorten:5 }}
{{ text | shorten:15:2ndparam }} // param1 and param2 will be argument2 and argument3 in the transform() method.
*ngFor = "let server of servers | filter: filteredStatus: 'status'	
	(filteredString is ngModel and is a class var too)
	('status' is a column)

Creating a filter pipe:- (Pure vs Impure Pipe)
eg. u have a table of contents and u want to search some content in it:-
 ng g p filter
 	... 
	transform ( value: any, filteredString: string): any {
		if (value.length === 0 || filterString === '') {
			return value;
		}
 	}

>> angular is NOT re-running the pipe when the data changes. (thanksfully).
	When ur data (in arrays / objects changes), then angular will not rerun the pipe.
>> if u add a space to the filteredString, then it will start showing the new changes.
This is because, changing the input of the pipe (param1 i.e. filteredString) will trigger angular to rerun the pipe.

The reason such a filtering condition exists is because, there is a high performance cost. (pure: true by default)
If u still wanted the pipe to re-run when the data changes, we have to create an impure pipe:-	
		pure: false;
	if u make the pipe impure, then it will respond to data changes.

---
Asyncpipe
| async 
	> if an observable, it auto subscribes and unsubscribes
	> if a promise, then it watches the promise object and if the promise returns a string, it will display that string.
		someclassVar = new Promise ( (resolve, reject) => {
			...
		});

---

Module:
	- @NgModule (declarations, imports, providers, bootstrap) Note :- import is a TS-keyword, where imports:[] is an angular feature.
				(exports, etc.) 
	- Feature module: L271 , say RecipesModule
		- IMP NOTE:- You cannot declare components, directives and pipes, in more than 1 module. Duplications not allowed.
		- In RecipesModule, in @NgModule({}). add CommonModule from @angular/common to imports:[] array of the new Feature Module. Gives access to ngClass, etc.
			NOTE: The AppModule has BrowserModule, instead of CommonModule. BrowserModule is a superset of CommonModule.
		- Add RecipesModule to the AppModule.	
	- Registering routes to a feature module: L272
		- Maintain import order in the imports:[] array in AppModule. 
		- If routing is in an AppRoutingModule, it should be the last item in imports:[] array, so that all wildcards can be accounted for.
		- create RecipesRoutingModule.
			-- const recipesRoutes: Routes = [
					{ path: 'new', component: 'Parent1', children: [
							{ path: 'new', component: 'Comp1', canActivate: [AuthGuard] },
							{ path: '', redirectTo: 'DefaultComp', pathMatch: 'full' },
							{ path: ':id', component: 'Comp2' },
						] // children ends.
					}, // parent1 ends	
				]; // recipesRoutes ends
			-- NOTE:- RouterModule.forRoot() should ALWAYS be used in AppModule, RouterModule.forChild() should always be used in the child component.
			-- 
				@NgModule ({
					imports:[
						RouterModule.forChild(recipesRoutes)
					],
					exports: [RouterModule]			//<<<<===== NOTE how we are exporting from the current RecipesRoutingModule
				})
		- goto the feature module RecipesModule and add RecipesRoutingModule to the imports:[] array.
		- the feature module RecipesModule will be in the AppModule::imports:[]
	- Shared module
		-- AppModule = FeatureModule1 + FeatureModule2
						-- FM1 and FM2 uses SharedModule
						
		-- L274 
		-- shared/shared.module.ts 
			@NgModule({
				declarations: [
					DropDownDirective	// has to be declared ONCE, somewhere. Its accessible only in current module.
				],
				exports: [
					DropDownDirective	// so that it can be imported in FM1 and FM2. It should be be accessible outside too.
				],
			})
		-- Add SharedModule to the RecipesModule::imports:[]	
		-- Add SharedModule to the AppModule::imports:[]
	
	-- 	Another Feature Module : ShoppingListModule
		- import {CommonModule} from '@angular/common'
		- imports:[ CommonModule, FormsModule]
		- Add ShoppingListModule to AppModule.
		- For routing, we could use RouterModule.forChild() which is fine, but lets c another way i.e. "Loading Components Via Selectors":-
			Loading Components Via Selectors:- 
					- 1. include the <app-shopping-list> </app-shopping-list>, add it to the declarations:[] array. (else u will get errors)
				-- OR--
					- 2. u have to import (TS-style) a module, which exports app-shopping-list component. (this we already saw with RecipesRoutingModule/ RecipesModule ?)
					
					1. 
					- FormsModule can be a problem, if its used @ multiple places, then should be mentioned everywhere.
					- OR it should be exported . But its a bad practise to export a module from a FM1 to be used in FM2.
			
	- Lazy Loading: Improving App Performance
		(Note: Opp. of Lazy Loading is Eagerly Loading, which loads everything)
		AppModule
			-- RootRouter
				-- ChildRoutes
				
		FM1 (RecipesModule) :-
			-- child router 
			-- component
			-- directive
			
		All Angular code is downloaded at the beginning.	
		But, If the user NEVER visits the FM1, then that particular code is never used and we downloaded too much code at the beginning.
		We can lazyload, FM1 and its children.
			-- i.e. FM1 is loaded ONLY if the route for FM1 is hit.
			
			
	- Adding Lazy load to the RecipesModule		
		- ng g c home --spec false
		- { path: '', redirectTo: 'HomeComp'},
			- { path: 'recipes', component: RecipesModule }, // Before: EAGERLY LOADING
			- { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule', }, //After: LAZY LOADING.
					IMPNOTE:- loadChildren takes a string, which of the format: '<path>#<ModuleName>' 
		- restart ng serve
		- network tab: disable caching is checked
			-- check chunk.js was added when the route was requested for.
	
	- Protect Lazy loaded Routes with ...
		-- using canActivate with lazy loaded is useless as the code wont be reachable until the route is loaded.
		-- we need something which can help us check before the route is called.
		-- use canLoad guard.
			eg. - { path: 'recipe', loadChildren: './recipes/recipe.module#RecipesModule', canLoad: [AuthGuard] }, 
			Note: AuthGuard should implement the "canLoad" interface.
			
	- Understanding Modules & Service Injection (when using FMs and Lazy Loaded modules)
		eg. 1. 
		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			Because, FM1 is injected into AppModule, using it at two places, wont hurt as the Root Injector will create ONLY one instance of the Serv1.
			LLM1, since its lazy loaded will also use the same global instance of Serv1 (provided by the Root Injector).	
			
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since no providers are used, LLM1 also uses the global instance of Serv1
			
		eg. 2. 	
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , providers: Serv1
			Here, LLM1, angular will create a child injector i.e. a local instance of Serv1.
	
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since providers are used @ module level, LLM1 will use a local instance of Serv1.
			
		Q. In eg.1., can FeatureModule1 be forced to use a local instance of Serv1 ?
		A. Yes, it can be done.
			If FeatureModule1, needs to be forced to use a local instance of Serv1, Serv1 should be removed from FeatureModule1::providers[] 
				and should be added to its child comp., say FMChild1::providers[]
				
		Q. In eg.1., 		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			SharedModule (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			(i.e. AppModule, FM1 and SharedModule are eagerly loaded)

			- Here, SharedModule will have access to global instance of Serv1 
			- LLM1 will NOT have global instance, it will have a local instance of Serv1. 
			- So, be very careful when adding services to SharedModule !!!
			
			V. V.IMP:- DO NOT add services to shared modules, especially, if those services will be used in Lazy Loaded Modules !!!!

	- Understanding the core module:-
			AppModule: AppComponent + Component + Directive 
									> Component + Directive should be move to a Core Module, because they apply to our App Module.
	- Core module 
			- will be used ONLY in AppModule.
			- should NOT be used anywhere else like LLM, SharedModule or FM1.
			- U can move providers (services) from AppModule to CoreModule. Keeping the AppModule leaner is a good practise.
			- CoreModule should ALWAYS be eagerly loaded.
	- Ahead of time compilation
			- 2 types of compiling the code. :- JIT or AOT.
				-- What is compiling the code? It does NOT mean angular is moving TS code to ES5, that is done by the cli.
					A. Angular needs to compile ur templates by parsing. It moves html-code to JS-code. (html-elements have JS-equivalents).
					   Ang. does this because accessing JS-equivalents is much faster than parsing DOMs.
				Such compilation can be done using Just in Time / Ahead of time compilation.		
			- Just in time:- is default and what we regularly do using ng-serve
				-- Development -> production -> App downloaded to browser -> Angular parses and compiles the templates to JS
				Here, in the last step, parsing and compilation happens on the browser.
				- Bulkier. Because the compiler is shipped.
			-- Ahead of time:-
				-- Development -> Angular parses and compiles the templates to JS -> Production -> App downloaded to browser
				This has advantages:-
				- Faster startup. ZERO parsing and compilation on the browser.
				- Templates are checked during development.
				- Smaller File Size. Compiler is NOT shipped. Any other features which are NEVER used are never shipped.
				
			AOT using cli:-
			- open network tab and the vendor.js/anyother file are very bulky. It has the compiler and so on.
			- cancel "ng serve"
			- ng build (uses JIT)
			- ng build --prod (uses minification + JIT )
			- ng build --prod --aot (uses minification + AOT)
			- see dist folder and check sizes of all files.
			
			Usually servers gzip it, but that is another discussion.
			
	- Pre-Loading lazy loaded routes
			- if LL, u will load the chunk of LLMs at that time, when the route is visited, so there may be a lag of few secs.
			- it would be nice to use LL, but still pre-load the code, so that there is no lag.
			
			AppRoutingModule, where we define all our routes.
			import { Routes, RouterModule, PreloadAllModules } from '@angular/router';

			before:- RouterModule.forRoot(appRoutes)	// Hidden Default is { preloadingStrategy: DontPreload }		// ???
			after:- RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules } // This property takes a type-definition. PreloadAllModules
			
---
Interceptors.

import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
app.module.ts
	imports: [ HTTP_INTERCEPTORS, HttpClientModule, n other modules ]
	providers: [
		{
			provide: HTTP_INTERCEPTORS,
			useClass: MyHttpInterceptor,
			multi: true
		}
	]
	
.ts
import { Injectable, Injector } from '@angular/core';
import { HttpClient, HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';

export class MyHttpInterceptor implements HttpInterceptor: Observable<HttpEvent<any>> {
	intercept (req: HttpRequest<any>, next: HttpHandler) {
		console.log("intercepted request ... ");

		// Clone the request to add the new header.
		const authReq = req.clone({ headers: req.headers.set("headerName", "headerValue")});
		console.log("Sending request with new header now ...");
		
		//send the newly created request
		return next.handle(authReq)
				   .catch((error, caught) => {
						//intercept the respons error and displace it to the console
						console.log("Error Occurred");
						console.log(error);
						//return the error to the method that called it
						return Observable.throw(error);
					}) as any;
	}
} // class ends

---
										); 
Observable
	- operators
	- queryparams L126, L127
Subjects:-
	- using them as observables


---

FormsModule + ReactiveFormsModule
	import { FormModule } from '@angular/forms'; // shouls be inthe imports[] too of app.module.ts

Template-Driven Forms:-
- Angular infers the form object from the DOM, based on foll. conditions:-
- FormsModule 

Reactive Forms:-
- Form is created programmatically and synchronized with the DOM.
- Gives finer control.
- ReactiveFormsModule

Template-Driven forms:-
  > Add ngModel (yes, just 'ngModel') as an attribute on the control.
  > Give it a name. name = "username"
  > eg. 
  	<form #f = "ngForm" (ngSubmit) = "doSubmit(f)">	<!-- Dont forget the "" -->
  		<input ... ngModel name="username">
		<button ... type="submit"> <!-- imp: bcoz it triggers the default submission behavior -->
	</form>
	where f : HTMLFormElement in typescript in doSubmit()
	u can also get it using:-
		@ViewChild('f')signupForm: NgForm (note: Its NgForm in typescript and ngForm in HTML)
  
  > Adding Validation (HTML Validators to be precise)
  	required
	minlength = 8
	email
	[disabled]="!f.valid" + CSS rules like:- input.ng-invalid.ng-touched select.ng-invalid.ng-touched { border: 1px solid red }
  
  > Adding custom-error msgs.
    <input ... ngModel name="email" #email="ngModel"> <!-- Note: how ngModel is mentioned twice -->
    <span class="help-block" *ngIf="!email.valid && email.touched"> Email format is incorrect </span-block>
    	<!-- help-block is a bootstrap class -->
	
  > Defining default values:-
    Before:-
	    <select ... ngModel name="secret"> 
		<option value = 'pet'>What is ur fav.pet</option>
		<option value = 'teacher'>What is ur fav.teacher</option>
	    </select>
    After:-
	    <select ... [ngModel] = "defaultQuestion" name="secret"> </select>
	    where defaultQuestion is a class var i.e. defaultQuestion = 'pet';
  
  > Custom-Grouping Values in our form-structure:-
  	Use ngModelGroup on ur parent-element and give it a name.
	eg. 
	<div id= ... ngModelGroup="userData"> 
		where userData will be shown as a key in the #f obj. i.e. in NgForm::value::userData
		-OR-
	<div id= ... ngModelGroup="userData" #userData="ngModelGroup"> (to access the userData as a JS object)
		and add custom-error msgs.
	
  > Handling radio buttons : they are not a special case. 
  	<div *ngFor="let gender of genders">
	  <label>
	  	<input type="radio" 
			     ngModel name="gender" [value] = "gender">
	  </label> {{ gender }}
	</div>
	
  > setting and patching form values:
  	
  > Handling checkbox 
  
---

  <!-- Email error block -->
    <div *ngIf="email.invalid && email.touched"
        class="col-sm-3 text-danger">
 
        <div *ngIf = "email.errors?.required">
            Email field can't be blank
        </div>
 
        <div *ngIf = "email.errors?.pattern">
            The email id doesn't seem right
        </div>
 
     </div>
    
---

Reactive-driven:- L193:  @angular/forms
	- form
		this.signupForm = new FormGroup({
			'username' : new FormControl (null),
			'email': new FormControl (null),
			'gender': new FormControl('male'),
		});
		
		- sync HTML template with FormGroup, using formControlName
			<form [formGroup]="signupForm">
				<input ... id="username" formControlName ="username" ... >
				<input ... id="email" formControlName ="email" ... >
				<input ... id="gender" formControlName ="gender" ... >
				
		- submit the form using ngSubmit
				<form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
					<input ... id="username" formControlName ="username" ... >
					<input ... id="email" formControlName ="email" ... >
					<input ... id="gender" formControlName ="gender" ... >		
					
				onSubmit(){ ... }	
	- Validators
		this.signupForm = new FormGroup({
			'username' : new FormControl (null, Validators.required), // DO NOT execute it like Validators.required(); angular will do that.
			'email': new FormControl (null, [Validators.required, Validators.email]),
			'gender': new FormControl('male'),
		});
		
	- Getting access to controls:-
		<span *ngIf="signupForm.get('username').valid && signupForm.get('username').touched">  // Note:- .get(name) or path-to-the-name, if its nested.
			...
		</span>
	- 		
Life-cycle hooks:- https://codecraft.tv/courses/angular/components/lifecycle-hooks/ 
	- (hooks are executed in this order)
		- constructor, 
		- ngOnChanges (invoked when input properties are changed), ngOnInit (invoked on initialized, invoked ONLY ONCE after the 1st ngOnChanges), 
		- ngDoCheck (invoked when the change detector of the given component is invoked, allows us to implement alternative change detection algo).
			IMP: ngDoCheck and ngOnChanges should NOT be implemented on the SAME Component
		- ngOnDestroy
			-- invoked just before angular destroys the component.
	- Hooks for the components children	
			-- ngAfterContentInit ( invoked after any content projection is done into the components-view. )
			-- ngAfterContentChecked ( invoked each time the CONTENT of the given component has been checked. )
			-- ngAfterViewInit ( invoked when the components view has been fully initialized)
			-- ngAfterViewChecked ( invoked each time the VIEW of the given component has been checked. )
	
	- ngOnChanges eg.
		ngOnChanges(changes: SimpleChanges) {
		  console.log(`ngOnChanges - data is ${this.data}`);
		  for (let key in changes) {
			console.log(`${key} changed.
		Current: ${changes[key].currentValue}.
		Previous: ${changes[key].previousValue}`);
		  }
		}	
			
Types of communications:- https://angularfirebase.com/lessons/sharing-data-between-angular-components-four-methods/
	- Parent to child
	- child to parent using ViewChild 
	- child to Parent using @output + EventEmitter
	- Using Subjects/BehaviorSubjects
Simple API unit testing using jasmine
Angular animations

Ultimate angular:-
- Content Projection n its types
	ng-content :- to form pieces of the form. 
		eg.1. simple ng-content
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> ></auth-form>
						<auth-form () = "" <h3>Login<h3> ></auth-form>
			AuthFormComp: Put <ng-content></ng-content> as placeholder, to show where the h3 should be inserted.
		
		eg.2. ng-content with projection/injection slots. (same for login)
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> 
										   <button type="submit">Join Us</button>
						></auth-form>
						
			AuthFormComp: 
						<ng-content select="h3"></ng-content>		where it requires to be projected/injected
						<ng-content select="button"></ng-content>	where it requires to be projected/injected

			Do same for Login
			
		eg.3. Content-project a component & bind to it 
			AuthRemember:
			AppComp: 
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>	
			checked is of EventEmitter
			
			AuthFormComp: 
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<ng-content select="button"></ng-content>	
						
			Note:= we can also use <ng-content select = ".somecssclass"	> </ng-content>		
			Binding can be done using class-var.
			
		eg.4. @ContentChild and ngAfterContentInit
			In eg.3., h3, auth-remember and button are contentchild of auth-form 
			
			AuthFormComp:
				
				In its template:-
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<div *ngIf="showMessage"> 
							You will be logged in for 30 days.
						</div>
						<ng-content select="button"></ng-content>	
			
				import { AuthRememberComp } from '';  // We r importing, so that we can query it after the content has been initialized.
				import { ContentChild, AfterContentInit} ... 
				
				@ContentChild(AuthRememberComp) remember: AuthRememberComp ;
				
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.checked.subscribe( (checked: boolean) => {
							this.showMessage = checked;
						});
					}
				}
			
			
		eg.5. @ContentChildren and QueryLists
				
				AppComp: 
			
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>
			
			
				import { ContentChildren, QueryList, AfterContentInit} ... 
				@ContentChildren(AuthRememberComp) remember: QueryList<AuthRememberComp> ;
			
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.forEach( (item) => {
							item.checked.subscribe( (checked:boolean) => this.showMessage = checked; );
						});
					}
				}
			
			
		eg.6. ViewChild and ngAfterViewInit 
		
				AuthMessageComp: 
					<div *ngIf="showMessage"> 
							You will be logged in for 7 days.
						</div>
						
				Pending.		
					
		eg.7. ViewChildren and ngAfterViewInit 	
			
						
- ngTemplateOutletContext

- Change Detection & immutability:
	OnPush + Immutable Data Objects :- Angular is faster when using immutable objects;
	We can build stateless/presentation/dummy components. (?)
	
	SomeComp:-
		changeDetection: ChangeDetectionStrategy.Default
		changeDetection: ChangeDetectionStrategy.OnPush 
		
- Dynamic components using ComponentFactoryResolver:-
	What we are going to do:-
		import {AuthFormComp}...
		<div>					// this serves as a container
			<div #entry></div>  // We will use the ComponentFactoryResolver to inject the AuthFormComp here. We will create a factory method for it.
		</div>
		- Note:  @Output()Submitted = new EventEmitter(); 

	App Comp implement AfterContentInit:-
		@ViewChild('entry', { read: ViewContainerRef}) entry: ViewContainerRef;  
		// the 2nd param here by default is an ElementRef, until we explicitly ask for a ViewContainerRef
		
		constructor(
			private resolver: ComponentFactoryResolver		// from @angular/core
		){}
	
		ngAfterContentInit() {
			const authFormFactory = this.resolver.resolveComponentFactory(AuthFormComp);
			const component = this.entry.createComponent(authFormFactory); // We will get error. Add entryComponents:[AuthFormComp] to auth-form.module.ts 
		}
		
		

Services:- egghead:-
Interceptors:-

PrimeNg:-
	PrimeNg v4.1, font-awesome v4.7.0
		npm install primeng --save 
		npm install primeicons --save
		npm install font-awesome --save 
		npm install @angular/animations --save 
	
	angular-cli.json:-
		styles: [ font-awesome.min.css, primeng/resources/themes/omega/theme.css, primeng/resources/primeng.min.css ]
	module.ts: 
		import { BrowserModule } from '@angular/platform-browser';
		import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
		import { AngularFontAwesomeModule } from 'angular-font-awesome';
		import { AccordionModule } from 'primeng/components/accordion/accordion';
		import { MenuItem } from 'primeng/components/accordion/accordion';
		import { MenuModule, MenubarModule } from 'primeng/primeng';

		Add to imports:[]

	AppComp:-
		{
			label: 'label1',
			icon: 'edit',
			items: [
				{label: 'Undo', icon: 'fa-mail-forward'}.
				{label: 'Undo', icon: 'fa-mail-forward'}
			]
		}
		
	<link rel="stylesheet" type="text/css" href="/node_modules/primeicons/primeicons.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/themes/omega/theme.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/primeng.min.css" />
	
---
	ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
	app/app-routing.module.ts
		
		- RouterModule.forRoot(appRoutes);
		
			@NgModule({ 
				imports: [ RouterModule.forRoot(appRoutes) ],
				Exports: [ RouterModule ]
			})
			
			export class AppRouting {}
		
		- <router-outlet></router-outlet> 
		
		
---

ElementRef,
ViewContainerRef, ViewContainerRef::createEmbeddedView, TemplateRef<any>, 
OOS:- ViewContainerRef::createComponent()

---
http://qnimate.com/post-series/ecmascript-6-complete-tutorial/ 

ES6:-
- call, apply & bind
	Obj1: properties & methods 	 
	Obj2: properties & methods 
	
	var obj = { num: 10};
	var addToThis = function (p1) {
		return this.num + p1;  // num is not yet accessible here
	};
	addToThis.call(obj, 20); //fn-name.call(obj, fn-args);
	addToThis.apply(obj, [20, 30]);
	addToThis.bind(obj, [20, 30])(); // bind returns a call

- Spread (... operator). 
	[1,2,3] ==> ...numbersArray
- Generics, interfaces
	interface:- is a contract that needs to be implemented.
	generics:- allow us to be less flexible 
		let numberArray: Array<number>;
- type alias

---

Angular Material Design:- Adding a custom theme 
	http://github.com/angular/material2

style.scss
	/* You can add global styles to this file, and also import other style files */

	@import "~@angular/material/theming";	// actual filename is _theming.scss, _ because its a partial. sass pre-processor ignores _ files.

	// Include non-theme styles for core.
	@include mat-core();

	// Define a theme.
	$primary: mat-palette($mat-pink);	// -OR- mat-palette($mat-indigo)  -OR-  $mat-red
	$accent:  mat-palette($mat-deep-purple, A200, A100, A400);	// -OR- $mat-pink

	$theme: mat-light-theme($primary, $accent); // we could also use mat-dark-theme().

	// Include all theme styles for the components.
	@include angular-material-theme($theme);

Add to to styles: [] in angular.json and restart ng serve

---

Rxjs6 In Practise:-
		Rxjs6:-
		git clone https://github.com/angular-university/rxjs-course.git
		git checkout -b 1-operators

		npm start (will start the dev-server which provides courses & lessons rest apis)

		interval(1000), timer(3000, 1000), fromEvent(document, 'click');

		1. 
		Non-Completing streams:- keeps emitting, but never completes.
			document.addEventListener('click', (event) => {
				console.log (event);
			});
			
			const counter = 0;	// emits a value after every 1 sec but never completes.
			setInterval(() => { counter++; c.log(counter); }, 1000);

		Completing stream:- executes only once.
			setTimeout(() => { console.log('Finished...'); }, 3000);
			
		2.
		Observable is a blueprint of a stream.
		subscribe() gives us an instance of the stream.
		 
			const interval$ = interval(1000); // rxjs interval() does same thing as setInterval();
			interval$.subscribe(	// instance of a stream.
				(val) => { console.log(val); }
			);
			interval$.subscribe(
				(val) => { console.log(val); }
			);
			
		3.	Wait for 3 seconds and then emit the values. Use timer()
				const interval$ = timer(3000, 1000);	// waits for 3 seconds before starting to emit.
				interval$.subscribe(
					(val) => { console.log(val); }
				);
				
		4. Define a stream of clicks: use fromEvent()

				const click$ = fromEvent(document, 'click');
				click$.subscribe(	// instance of a stream.
					(event) => { console.log(event); }
				);
			
		5. Stream Errors & Stream Completion.

				click$.subscribe(
					(event) => {},
					(err) => {},
					() => { console.log ('completed'); }
				);

			Subscription & Cancellation using unsubscribe
				// subscription
				const subscription = interval$.subscribe(	// instance of a stream.
										(val) => { console.log(val); }
									);
				
				// cancellation/unsubscribe
				subscription.unsubscribe();					
				
		6.  
		- How do observables work under the hood?
		- Build ur own http observable.

		fetch() is a browser api. it can be used to call rest apis.
		fetch('/api/courses') will return a promise.
			- promise get executed as soon as they r defined.
			-	observer.next()  to emit a value. will only be called on subscribe() call.
				observer.error()
				observer.complete() to complete it.
				

			const http$ = Observable.create( observer => {
				fetch('/api/courses')
					.then( response => response.json())  // response.body(), response.ok(), response.status() are few other.
					.then ( body => {					 // body here meants the json-body/json-data
						observer.next(body);
						observer.complete();
					})
					.catch ( err => {
						observer.error(err);
					})
					;	
			});

			http$.subscribe(
				( data ) => console.log(courses),
				noop, // -OR- ( err ) => {}, // noop is an rxjs function for no operation
				() => {}
			);
			
		7. 
			pipe operator: chain multiple observables eg. pipe(map ( ... ) )
			Map operator: eg. map (x => 10*x)
			
			const courses$ = http$.pipe(
				map( res => Object.values (res["payload"]) );	// payload is a property which has array of objects. REST API response is : obj-of-payload: Arr-of-objects
			);
			
			courses$.subscribe( ... );
		---

		L10:- stopped. to be continued later.
			
---

morgan project:-

ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
- json server for products 
	-- unit test for same
- App Routing Module
app.module.ts
		-> imports app-routing.module.ts			
			-> imports FM products.modules.ts
			-> imports CommonModule
				-> declarations + imports products.component.ts
		-> exports RouterModule + FM Products Module		
		
- Products Featured Module ( Component + Service + Directive ) 
		Products.Component.ts	
			-- dispatch an action 
			-- reducer
				-- products service
			-- comp has data 
			
npm install @ngrx/core @ngrx/store --save
create store/
	step 1: create App level interface AppStore (app.store.ts).
			>>  { products: any } 
	
	step 2: StoreX.module.ts  (StoreXModule class)
		Maps interface-keys of app.store.ts to reducers (defined in various *.reducer.ts file) using ActionReducerMap<AppStore>
			>> 
				export const reducers: ActionReducerMap<AppStore> = {
					products: ProdReducer.productreducerFn
				};
			
				import * as ProdReducer from './product.reducer';
				NOTE.:- productreducerFn in ProdReducer.productreducerFn will be an exported function name "productreducerFn"
	
	step 3: store/reducers/products.reducer.ts
			export function productreducer(state = initialState, action, any) {}
				where 
					- initialState implement an interface like IProducts for string-type.
					- action is of type any for now, but it should change to ALLACTIONS (from store/actions/products.action.ts)

	step 4: store/actions/products.actions.ts 
			- import { Action } from 'ngrx/store';
			- export type AllActions = Class1implementsAction | Class2implementsAction ;
			
			- export class class1 implements Action {  // Here u can name the class1 anything, its not of significance outside this file.
					readonly type = someConstValue;	   // This is v.imp
				}
				
			- export const someConstValue = 'GetProducts'; // RHS is very imp. Will be used in the switch-case in the reducers.	

			eg. 
				import { Action } from 'ngrx/store';
				export const getProducts = 'GetProducts';
				export class FetchProducts implements Action {
					readonly type = getProducts;
				}
				export type ALLACTIONS = FetchProducts;

- Shared Module
	- Shared components ( Prime Ng )
		-- Data Table Component
		-- Shared Prime Ng button.
- Ngrx
	- Storemodule
	- action creators, reducer
	- Unit test for reducer

	
