Observables vs Promises:- https://angular.io/guide/comparing-observables

> Promises start immediately on creation. Observables are declarative; computation does not start until subscription.
> Promises provide one value; Observables provide many values (over time).
> Promises execute only once; Observables can be executed/subscribed repeatedly.
> Promises are not cancellable; Observables are cancellable.

> Promises cannot differentiate between chaining, it only uses .then() clauses. (Does not differentiate between last and intermediate .then() blocks)
  Whereas, observables knows the difference between subscribe() and in-betweeners.	
  Observables differentiate between chaining and subscription. Obsvs, thus help to create complex centralized pre-processing, 
  without executing the actual work (until subscription).
> Promises push errors to child promises, observables have subscribe(), which has inbuilt error-handling for centralized error handling.  

==============================

https://angular.io/guide/rx-library
Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.

tsc v2.7.2, rxjs v6.*

Creation	    :    from , fromPromise , fromEvent , of
Combination	    :    combineLatest , concat , merge , startWith , withLatestFrom , zip
Filtering	    :    debounceTime , distinctUntilChanged , filter , take , takeUntil
Transformation	:    bufferTime , concatMap , map , mergeMap , scan , switchMap
Utility	        :    tap
Multicasting	:    share
Retry           :    retry, retryWhen
Miscellaneous   :    throttleTime (see how it is different from debounceTime )

Obs -vs- Array:-
obs.find()          ====>   arr.find()
obs.findIndex()     ====>   arr.findIndex()
obs.forEach()       ====>   arr.forEach()
obs.map()           ====>   arr.map()
obs.scan()          ====>   arr.reduce()


import { Observable } from 'rxjs'; 
import { interval, fromEvent, fromPromise, from, pipe, range, timer, zip } from 'rxjs';
import { ajax } from 'rxjs/ajax';
import { filter, map, retry, retryWhen, catchError, 
         debounceTime, distinctUntilChanged, 
         switchMap, mergeMap } from 'rxjs/operators';

==============================

==============================
Constructor decorator params:-
	@SkipSelf, @Self, @Optional, @Host + viewProviders:[], @Inject, @Attribute
	1. @SkipSelf:-
	   > use it if, Comp wants to have its own (local) instance of Service + at same time have (global) instance of the service
	   	https://stackoverflow.com/questions/34983611/injecting-service-providers-in-angular-2-0
	2. @Self:- (default behavior ONLY!!! Else error)
		background: 
		  Angular checks if currentcomp defines a DInjector (for a service) in its @Component decorator.
		  If not found, it will try to find a parent injector in a parent component.
	  	(Q. How to create a parent component?? Unlike angular1, we use @Input() and @Output() to communicate with child)
		  If not found, it will go up the chain and try to find a parent injector (i.e.DI in constructor()) n so on
		  If not found, it will check the root injector (in @NgModule of SM/FM/CoreM, app.module.ts)
		  If not found, it will give "No provider error"
		  
		@Self:- find the service only in current comp. else error
		 in any comp, (both seem to do the same thing ??? i.e. default behavior)
		 	private srvcInstance: ServiceOneService,
			@Self() private srvcInstance: ServiceOneService,
			
	3. @Optional:- u can mark any instance as optional in the constructor. u can put it before or afte @Self()/@Host()
		@Optional() @Self() srvc:Service  // works.
		@Self() @Optional() srvc:Service  // works.
		@Optional() @Host() srvc:Service  // works.
		@Host() @Optional() srvc:Service  // works.
		
	4. @Host:- Looks like it stops the injector bubbling on the host-element (directive/component) where it is declared (???)
	See ex. 4.1
	5. @Inject:- 	
	6. @Attribute:- 
	 - used in constructor(){} and used typically with @Input() string constants; thereby preventing angular to check it repeatedly
	 - gives a performance boost when used with @Input string constants.
	 - explore more.
		
	Examples:-
	1.1
		services/ng g s serviceOne
	   	export class ServiceOneService {
  			someproperty: string = 'I am a default value'
			...
		+
		child1/ng g c child1
		+ 
		app.module.ts (In @NgModule)
			providers: [ServiceOneService],	// for creating singleton / global instance in components
		+
		app.component.ts
		  constructor( private appSrvc: ServiceOneService ) {	// get the singleton global instance
    				this.appSrvc.someproperty = 'I am having parents value'; // change the default value.
				console.log( 'this.appSrvc.someproperty', this.appSrvc.someproperty);
  			      }
		+
		child1.component.ts (In @Component)
		     providers: [ServiceOneService]
		     ...
		     constructor(
   			 @SkipSelf() private globalSrvcInstance: ServiceOneService, // will get the global instance
    				     private localSrvcInstance: ServiceOneService   // will create a new local instance for child1 comp
                     ) { }
			
		ngOnInit() {
    			console.log(this.localSrvcInstance, this.globalSrvcInstance);
  		}
		
		IMP NOTE:= 
		  correct syntax:- @SkipSelf() private globalSrvcInstance: ServiceOneService, // decorator 1st + then "private"
		  wrong syntax:- private @SkipSelf() globalSrvcInstance: ServiceOneService,

	----
	
	4.1	
	>> Service1Service, Service2Service (with default), 
	>> Directive1Directive (overwites default msgs with @Host , 
	>> (parent) comp1, (parent) comp2 - call <app-directive1></app-directive1> + viewProviders:[]
	>> Output is in ngOninit{} of (parent) comp1, comp2 and ngOnInit of directive1.
	
// viewProviders is of type Providers:[], so using Providers & viewProviders in the same comp, will give u same local instance of the service	// DO NOT use providers: [] with viewProviders:[], because it just does not make sense.

		Service1Service : has default "msg1" property: I am service1
		Service2Service : has default "msg2" property: I am service2

		directive: app-directive
			> implements ngOnInit(){}
			> overwrites default msgs, msg1 and msg2 to : I am #1 and I am#2
				>> uses constructor @Host() serv1: Service1Service, serv2: Service2Service
			> Every component that uses via viewProviders, will an independent copy (deep copy) of the service objects (VIMP: in ngOnInit() of comp + directive !!!). 
			> So, comp1 and comp2, will get 2 diff. objects of services.

		comp1 -> 
			<app-directive></app-directive> + viewProviders:[ Service1Service, Service2Service]	 // viewProviders is of type Providers:[]
				>> I am #1, I am #2
		comp2 -> 
			<app-directive></app-directive> + viewProviders:[ Service1Service, Service2Service]
				>> I am #1, I am #2

		NOTE:- Comp1 & Comp2:-
				> both comp1 and comp2 do NOT create instances in their constructors.
				> instead, they are just calling the directive using <app-directive></app-directive> + viewProviders:[] 

		Q. but what if comp1 and comp2 do create instances in their constructors ??
		A. 
		comp1:-
			constructor() { private srv1: Service1Service } // will give u the exact same instance as was used in the directive.
				>> get its own local instance of Service1Service
				>> any changes made using srv1 (in ngOnInit()), will also be reflected in the directive's serv1 (in ngOnInit)
					change, msg1 to: Modified I am #1, 
						>>> Modified I am #1 (in srv1 & in directive obj too is auto updated, as its pass by reference), I am #2


		comp2:-
			constructor() { private srv2: Service2Service } // will give u the exact same instance as was used in the directive.	   
				>> get its own local instance of Service2Service
				>> any changes made using srv2(in ngOnInit), will also be reflected in the directive's serv2(in ngOnInit)
					change, msg2 to: Modified I am #2, 
						>>> I am #1, Modified I am #2 (in srv2 & in directive obj too is auto updated, as its pass by reference)
		NOTE: comp1.srv2 and comp2.srv2 are totally independent of each other.

		Q. But what is comp1 and comp2 want to have the default values i.e. I am service1 , I am service2
		In comp1 / comp2
		A.1. // @SkipSelf() private srv2: Service2Service // IMP: gives u the default instance of the service.
		A.2. // srv2 = new Service2Service(); // IMP: gives u the default instance of the service. Providers:[] is not required. 
		If you get errors of StaticInjectorError, then add viewProviders:[] to app.component.ts 
		
======================
Injector bubbling (https://angular.io/guide/hierarchical-dependency-injection)
tree-shakable providers, InjectionToken (https://angular.io/guide/dependency-injection), OpaqueToken (+ @Inject)

	InjectionToken (https://angular.io/guide/dependency-injection), OpaqueToken (+ @Inject)
	  -- InjectionToken seems to a stricter type checking than OpaqueToken which got deprecated in Angular4
	  > https://stackoverflow.com/questions/43419050/angular-2-opaquetoken-vs-angular-4-injectiontoken		
		> https://toddmotto.com/angular-dependency-injection 
			>> Note: in providers: [{ provide: SomeClass, useClass: SomeClass }], 
				The provide property in the object is the "token" for the provider that we’re registering, angular registers the class to this token, using "useClass: ...". Hence we can use the same token and override it with another class.
		

** providers -vs- viewProviders **
( https://codecraft.tv/courses/angular/dependency-injection-and-providers/ngmodule-providers-vs-component-providers-vs-component-viewproviders/ )
	>> viewProviders are used in parent comps, which call directives (using services). they r used in parent comps, to prevent reloading services everywhere. The ngOninit() of the parent comps (using service) & ngOninit of the directive (using service) both have same instance of the service (when using viewProviders).

@Injectable, Injector
@ViewTemplate, 
ElementRef, TemplateRef, ViewRef, ComponentRef, ViewContainerRef, (Abstractions provided by angular)
	https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02 
	The new Angular version runs on different platforms — in a browser, on a mobile platform or inside a web worker. So a level of abstraction is required to stand between platform specific API and the framework interfaces. In angular these abstractions come in a form of the following reference types: ElementRef, TemplateRef, ViewRef, ComponentRef and ViewContainerRef
	
Angular provides foll. DOM Queries to access the above abstractions:- 
	@ViewChild, @ViewChildren (We can use these to get the above abstractions in a component/directive).
	
  @ViewChild([reference from template], {read: [reference type]});
    - 2nd param is optional, as angular can infer the type; but there are exceptions, where the 2nd param needs to be mentioned explicitly.
    - ElementRef: html elements like span, angular infers & returns ElementRef
    	ElementRef -> NativeElement eg. console.log(this.tref.nativeElement.textContent);
	> NOTE:- Such usage is discouraged as it causes tight coupling. See ex.1.1 below
    - TemplateRef: if its a template, angular infers & returns TemplateRef
    	<ng-template #someTmplref> .. </ng-template> 
	+ 
	@ViewChild("tpl") tpl: TemplateRef<any>;
    - ViewRef: cannot be returned from the DOM and have to be constructed manually.
    	> This type of abstraction represents an angular View. Views contain elements which are created and destroyed together.
	Angular supports two types of views:
	1. Embedded Views which are linked to a Template
		Any View --> A template (template is blueprint of a view)
			ngAfterViewInit() {
 			   let view = this.tpl.createEmbeddedView(null);
			}
	2. Host Views which are linked to a Component
		Host View --> Component created dynamically.
		> Host views are created when a component is dynamically created/instantiated
		> A component can be created dynamically using ComponentFactoryResolver. See ultimate ng for more.
		constructor(private injector: Injector,
            		    private r: ComponentFactoryResolver) {
    				let factory = this.r.resolveComponentFactory(ColorComponent);
    				let componentRef = factory.create(injector);
    				let view = componentRef.hostView;
				}
			    );
		VIMP:-
		  - Every component is bound to a particular instance (global/local) of an injector(RootInjector is for appComp).
		     so we’re passing the current injector instance when creating the component below:-
		     	let componentRef = factory.create(injector);
		  - Also, don’t forget that components that are instantiated dynamically must be added to 
		  	EntryComponents of a module or hosting component.	
	So, we’ve seen how both embedded and host views can be created. Once a view is created it can be inserted into the DOM using ViewContainerRef		
    - ComponentRef: 
    - ViewContainerRef: ViewContainerRef cannot be inferred and have to be asked for specifically in read parameter. 
    	- Represents a container where one or more views can be attached.
	- any DOM element can be used as a view container; IMP!!! What’s interesting is that Angular doesn’t insert views inside the element, but appends them after the element bound to ViewContainer
		<ng-container #vc></ng-container>
		@ViewChild("vc", {read: ViewContainerRef}) vc: ViewContainerRef;
		ngAfterViewInit(): void {
     			console.log(this.vc.element.nativeElement.textContent);
    		}
		
		----
		
		  @ViewChild("vc", {read: ViewContainerRef}) vc: ViewContainerRef;
    		  @ViewChild("tpl") tpl: TemplateRef<any>;

		    ngAfterViewInit() {
			let view = this.tpl.createEmbeddedView(null);
			this.vc.insert(view);
		    }

==============================
Ex. 1.1. ElementRef + ViewChild
	<app-views></app-views>
	+ 
	<span #spanEleRef>I am content inside a span ElementRef</span>
	+ 
	@ViewChild('spanEleRef')spanElementRef; // Note: outside the () is the name u give, in this case spanElementRef.
	-OR-
	// @ViewChild('spanEleRef')spanElementRef: ElementRef; // same as above
	+ 
	ngOnInit() {
   	 console.log ('1. ', this.spanElementRef); // will give the JS obj
	 		  // this.spanElementRef.nativeElement // will give <span> ... </spa>
			  // this.spanElementRef.nativeElement.textContent // will give the content within the <span> element.
  	}
	
Ex. 1.2. TemplateRef + ViewChild
	<app-views></app-views> 
	+ 
	<ng-template #ngTmplRef>
  		<p>I am a para in an ng-template </p>
	</ng-template>
	+
	@ViewChild('ngTmplRef') ngCustomTmplRef: TemplateRef<any>;
	+ 
	// this.ngCustomTmplRef['_def'].element.template.lastRenderRootNode.text.prefix // only text1
    	// this.ngCustomTmplRef['_def'].element.template.nodes[1].text.prefix // text1commented + text2withpara
    	// this.ngCustomTmplRef['_def'].element.template.nodes[2].text.prefix // if both text1withoutpara + text2withpara
	
NOTE: As you can see, this is very cumbersome and not guaranteed. 
      As a matter of principle, use TemplateRefs ONLY with ViewContainerRef. 
      	ViewContainer ---> can have many views --> Each view has a template.
	ViewContainer exposes ViewContainRef for us to attach one or more views to it using 
			      ViewContainerRef::createEmbeddedView(), ViewContainerRef::createComponent(), ViewContainerRef::clear().
			      
	So, in 1.2, add these 
	<ng-container #vc></ng-container>
	+
	@ViewChild("vc", {read: ViewContainerRef}) customVC: ViewContainerRef;	// Viewchild should have read-options obj for a ViewContainerRef
	+ 
	ngOnInit() {
	   // 1.
	   let view = this.ngCustomTmplRef.createEmbeddedView(null); // A view has a template
           this.customVC.insert(view); // A container can have one or more views.
	   // 2. -OR- 
	   this.customVC.createEmbeddedView(this.ngCustomTmplRef); // preferred way.
	   // 3. - OR-
	   this.customVS.createComponent(); // incomplete. See 3.1
	   	- uses ComponentFactoryResolver, 
  	}
	
	// 3.1
	In another comp, constructor() {}
	   private compFactoryResolver: ComponentFactoryResolver,
	   
	   ngOnInit() {
	   	// 2. The resolveComponentFactory() method takes a component and returns a ComponentFactory.
	   	// const compfactory: ComponentFactory<any> = this.compFactoryResolver.resolveComponentFactory(ButtonComponent);
		// this.compRef = this.customVC.createComponent(compfactory);  // where compRef: ComponentRef<any>; 
    		// console.log(this.compRef.instance); // works, because of singlecomp (ButtonComp)
	   }
	 
	 // 3.2 -- extending 3.1 to have multiple components
	 create another wrapper component
	 export class SomeComp {
    		constructor(){
        		return [ 
            			new ButtonComponent('button1'), new ButtonComponent('button2'), new ButtonComponent('button3')
        		]
    		} // constructor ends
	  }
	 In prev. comp. 
	 compRef: ComponentRef<any>;
		+
	 ngOnInit() {
		 const compfactory: ComponentFactory<any> = this.compFactoryResolver.resolveComponentFactory(SomeComp);   
    		 this.compRef = this.customVC.createComponent(compfactory);
		 this.compRef.instance.forEach(element => {	// now we have all 3 components.
      			console.log(element);
      		 });
	 }
	 
	 // 3.3 To view multiple components on html (this is not the optimal solution)
	 this.compRefInstance = <HTMLButtonElement>this.compRef.instance;
	 +
	 <div *ngFor="let button of compRefInstance">
    		<!-- {{ button | json }} -->
    	    <button type="button">{{button.label}}</button> 
	 </div>
		
		
	
==============================

String Interpolation:-
{{ classvar }} // will be a class variable.
{{ classmethod() }} // Works, but Dont do this as it will call it multiple times

Property binding:-
[disabled] = "some property name"

String Interpolation can be replaced with property binding:-
before:- <p> {{ someclassvar }} </p>
after:- <p [innertext]="someclassvar"> </p>	DONT DO:- <p [innertext]="{{someclassvar}}"> </p>

Event Binding:-
	(click) = "callSomeMethod()"   // VanillaJS:- onClick = "doSomething()"
Passing Data with EventBinding:-
	(input) = "doSomething($event)" // $event will give access to data like clicked-details, etc.
	where,
		doSomething(ev: any) {
			c.log( ev.target.value ); // where target shows the html-element on which the event occured.
		}
---
ngIf, ngFor, ngStyle, ngClass, ngSwitch, ngModel, (ngSubmit) = doSubmit() [for both template n reactive form], ngForm

<input ... ngModel name="email">
<input ... ngModel name="email" #email="ngModel"> (for displaying custom errors)

<div ... ngModelGroup="customKeyInNgFormObject"> </div>
<div ... ngModelGroup="customKeyInNgFormObject" #customKeyInNgFormObject="ngModelGroup"> ... </div> (for displaying custom errors)

Note:- (for displaying custom errors), u can use like email.invalid && email.touched, etc.
---

*ngIf = "someconditionevaluatesToTrue"
*ngFor="let item of products"
ngswitch = [ngSwitch] *ngSwitchCase + *ngSwitchDefault 
eg.
	<ul *ngFor="let person of people"
	    [ngSwitch]="person.country"> 

	  <li *ngSwitchCase="'UK'" 
	      class="text-success">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'USA'"
	      class="text-primary">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchCase="'HK'"
	      class="text-danger">{{ person.name }} ({{ person.country }})
	  </li>
	  <li *ngSwitchDefault 
	      class="text-warning">{{ person.name }} ({{ person.country }})
	  </li>
	</ul>`

ngModel: 2-way data binding = EventBinding + PropertyBinding
[(ngModel)] = "somevar" + {{somevar}}
Using ngModel is considered a better way, than to pass $event around. See doSomething($event) above.

---
ngIf and ngFor: Rabbits hole. (uses ng-template)

1. *ngIf="someexpressionWhichReturnsTrue" eg. *ngIf="1===1" and it will work.
2. ngIf + else.
	>> semi-colon, else condition requires <ng-template> + local-reference
	<p *ngIf="someexpression; else noServerCondition"> iftext1 </p>
		<ng-template #noServerCondition> 
			<p> elseText </p>
		</ng-template>
output:-  iftext1 is shown if condition is true, else elseText is shown.
3. ngIf + then + else
	>> semi-colon, then-condition && else-condition requires <ng-template> + local-reference
	<p *ngIf="someexpression; then thenTemplate else elseTemplate"> iftext1 </p>
		<ng-template #thenTemplate>ThenText1</ng-template>
		<ng-template #elseTemplate>ElseText1</ng-template>
output:-
	if condition is true, thenTemplate is shown, else elsetemplate is shown.
	NOTE:= iftext1 will NEVER BE shown. This is a gotcha. so be careful when using ngIg-then-else
	
---
*ngIf deeper, *ngFor deeper

1. <p *ngIf = "someconditionevaluatesToTrue"> </p>
Angular does this:-
   <ng-template	[ngIf] = "someconditionevaluatesToTrue">
   	<p> ,,,, </p>
   </ng-template>
   Note:- [ngIfElse]="someotherconditiion"
2.    
<ul *ngFor="let item of products"> //NOTE: let is mandatory
Angular does this internally:-
  <ng-template ngFor let-item [ngForOf] = "products" let-i = "index">
  	<p> .... </p>
  </ng-template>

Variations:-
	<ul *ngFor="let item of products; let i = index"></ul>
	<ul *ngFor="let item of products; index as i"></ul>
	<ul *ngFor="let item of products; let i = index; let even = even; let odd=odd"></ul>
  	<tr *ngFor="let employee of employees; trackBy: trackByEmpcode">
	NOTE:- ngFor may perform poorly with large lists; recreating the whole table on small changes; this is bcoz angular doesnt know its dealing with the same obj. When trackBy is used, angular only does incremental changes to the DOM.
---

Q. How to create your own ngIf:- eg. myNgIf
A.1. Use ViewContainerRef + ViewContainerRef::CreateEmbeddedView() + TemplateRef<obj|any>
A.2. Use ng-container + ngTemplateOutlet + context-obj.

A.1. 
	ng g d myNgIf
	constructor (
		private  viewContainerRef: ViewContainerRef, private templateRef: TemplateRef<Object>
	){}
	ngOnInit(){
		const condition = true;
		if (condition ) { this.viewContainerRef.createEmbeddedView (this.templateRef); }
		else { this.viewContainerRef.clear(); }
	}

	<p *myNgIf> ... </p> -OR- <ng-template myNgIf> </ng-template> (NOTE: no asterisk)
	PS: We can add @Input to make RHS accept conditions.

A.2.
ng-container + ngTemplateOutlet + context-obj (helps with interpolation) + ng-template.

2.1
   Inside class have an obj ready 
   	ctx = { estimate: 10}; // NOTE: if more than 1 properties, then more let-variables can be used.

	<ng-container *ngTemplateOutlet="loadingTemplate; context: ctx"></ng-container>
	<ng-template #loadingTemplate let-var1 = "estimate">
		<p>loading {{ var1 }} pages ... </p>
	</ng-template>
>> ng-container is the table on which the template is laid and the context is interpolated into the template
>> let-variables are in local template-context meaning, access to them is not available from outside.
>> Note: if a let-variable does not have a RHS value assigned to it, then it latches up to $implicit; if more than one let-vars dont have RHS vallue, then all such let-vars are initialized to $implicit.
	ctx = { estimate: 10}; can be rewritten as ctx = { $implicit: 'World' };
>> *ngTemplateOutlet is of type TemplateRef<any>
   *ngTemplateOutletContext is of type Object. (We may see this later in ultimate angular)
---

<p [ngStyle] = "{backgroundColor: getColor()}"
   [ngClass] = "{somecsscolor: somevar === 'true' }"	> </p>
   
---
Directives (selector) + Components (selector, template, styles, providers)
@Input, @Output
	eg.1. for Input:-
		@Input() hero: Hero;	// =OR=
  		@Input('master') masterName: string; // master is the alias for masterName and master will be used everywhere.
	eg.2. for output:-
	In some class
		@Output() valueChange = new EventEmitter();
		in some method:-
			this.valueChange.emit(this.counter); // where counter is a class variable.

----
Types of component communication:-
1. Parent-to-child using @Input
2. Child-to-parent using @Output + EventEmitter
3. Child-to-parent using @Viewchild + ngAfterViewInit()
	@ViewChild(ChildComponent) child; 
	message:string;

	ngAfterViewInit() {
	   this.message = this.child.message
	}
4. Unrelated Components: Sharing Data with a Service
	To keep them in sync: use a global service-providers
	To keep one of them out of sync: use a local service-providers in that comp., which needs to be out of sync
	
	https://angularfirebase.com/lessons/sharing-data-between-angular-components-four-methods/	
	This is applicable for unrelated-parents/siblings.
	
	Why BehaviorSubject ?:-
	> It will always return the current value on subscription - there is no need to call onnext
	> It has a getValue() function to extract the last value as raw data.
	> It ensures that the component always receives the most recent data.
	
	(may not work, put in here as a reference only.)
	eg. 4.1. The service
		@Injectable()
			export class DataService {

			  private messageSource = new BehaviorSubject('default message');
			  currentMessage = this.messageSource.asObservable(); // NOTE:= currentmessage will be used to get curr. val.

			  constructor() { }

			  changeMessage(message: string) {
			    this.messageSource.next(message)
			  }
	4.2 Parent comp:-
		ngOnInit() {
		    this.data.currentMessage.subscribe(message => this.message = message)
		  }
		  
	4.3 Sibling comp:-
		ngOnInit() {
   		  this.data.currentMessage.subscribe(message => this.message = message)
  		}

		  newMessage() {
		    this.data.changeMessage("Hello from Sibling")
		  }
----

@HostListener, @HostBinding, L88, 89 : used to create reactive directive
	- use them with directives
	HostListener:	(from @angular/core)	we can capture the events of the host-element (on which this directive sits).
		In Directive's class:
			ngOnInit(){ ... }
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
			}
	HostBinding: Alternative to renderer.   we can specify style-properties of the host-element(on which this directive sits).	
		- camelcase in 'style.backgroundColor' is VIMP!!!
		- needs to be used with a HostListener
		
		In Directive's class:
			@HostBinding('style.backgroundColor')tmpbackgroundColor: string;
			@HostListener('mouseenter')mouseover( eventData: Event) {
				this.renderer2.setStyle(this.elRef.nativeElement, 'background-color', 'blue', false, false);
				this.tmpbackgroundColor = 'blue';
			}
			
@Viewchild

Renderer, Renderer2 :- Renderer2 is used to write mobile + desktop code. no separate code for mobile.
RouterModule, Routes, Router, routerlinks, <router-outlet>, Navigation Paths, 
Navigating Programmatically, Using relative paths in navigating programmatically, L120
ActivatedRoutes, Passing Params to Routes, Fetching Route Params Reactively, Passing Query Params and Fragments, Common Gotchas (skipped)
ChildRoutes, queryParamsHandling, Redirecting and Wildcarding Routes, LocationStrategy
named router outlet 
	AppModule:-	
		import { RouterModule, Routes, Router, PreloadAllModules } from '@angular/router';
		const appRoutes: Routes = [{}, {}]; // Its an array of objects.
		
		- routerLink replaces href in an <a href...> and help with NOT reloading the page; href reloads the page i.e. it sends a request to the server
			[routerLink] = ['users']  // users is an absolute path.
			[routerLink] = ['./users']  // users is an relative path.
			You can use this relative syntax because routerLink is aware of which component u r currently on . Will give errors, if the path does not exist.
			
		- NavigationPaths:- if you use a relative path, then it becomes relative to the current comp (i.e. the component u are on).
							use absolute paths, to prevent breaking ur routes, unknowingly.
		- Navigating Programmatically:-  L120
			-- this.router.navigate(['/servers']);  /servers is an absolute path. and router: Router
		- Using relative paths in navigating programmatically, L121
			-- this.router.navigate(['servers']);	//servers is a relative path.
				// Unlike, routerLink, it WONT give errors, if the path does not exist. 
				// This is because Router does NOT know which component u r currently on. This is the difference between Router and RouterLink
		- To fix this use:- ActivatedRoute + optionsObj having relativeTo: route
			import { ActivatedRoute } from '@angular/router';
				route: ActivatedRoute
					-- this.router.navigate(['servers'], {relativeTo: this.route});	//servers is a relative path.	

		- Passing Params to Routes:
				{ path: 'users/:id', component: 'UserComp' },
				{ path: 'users/:id/:name', component: 'UserComp' },
			- In UserComp::ngOnInit()
				this.route.snapshot.params['id'], where route: ActivatedRoute
				this.route.snapshot.params['name'], where route: ActivatedRoute
		
			this.route.snapshot.params should be used ONLY for 1-time loading. For subsequent changes, use this.route.params (see below) 
		- Fetching Route Params Reactively
			- the above approach may break sometimes
			Problem eg.
				<a [routerLink] = "['/users', 10, 'Anna']"> Load Anna </a>
					>> The route changes, but the template does not change to reflect anna. (because Angular doesnt know the data in the template change)
					
			Solution :- 
			import { ActivatedRoute, Params } from '@angular/router';	
				// NOTE: this.route.params is an observable. 
				this.route.params.subscribe(
					params: Params {
					this.templatevar1 = params['id']
					this.templatevar2 = params['name']
				})
		- Passing Query Params and Fragments.		
			QueryParams: eg. ?mode=editing&name=plankton
			Fragments: eg. ?mode=editing#loading   (loading is a fragment)

			Passing Query Params and Fragments.	
			A.1.
				{ path: 'servers/:id/edit', component: 'ServComp' },
				+
				<a 
					[routerLink] = "['/servers', 5, 'Serv1']"
					[queryParams] = "{ allowEdit: '1'}"
					[fragment]="'loading'"
				> Server1 </a>
				
				Use:- [fragment]="'loading'"  -OR- fragment="loading"   // both are the same
				
			A.2.
				this.route.navigate(
										['/servers', id, 'edit'],  // 1st param
										{							// 2nd param is an options object
											queryParams: {allowEdit: '1'},
											fragment: 'loading'
										}
									)
		- 	Retrieve Query Params and Fragments:
				Retrieve using snapshot:- this.route.snapshot.queryParams -or- this.route.snapshot.fragment
				Retrieving reactively:- this.route.queryParams.subscribe();
										this.route.fragment.subscribe();
										
				Angular will unsubscribe automatically.
		- Common Gotchas: 
		- child routes: 
			{ path: 'servers/:id/edit', component: 'ServComp' , children: [{}]},
			and add a second <router-outlet></router-outlet>
		
		- queryParamsHandling: preserving queryParams when we navigate to another route.
			this.router.navigate(['servers'], 
									{relativeTo: this.route, queryParamsHandling: {'preserve'}
								);
			queryParamsHandling: {'preserve'}
			queryParamsHandling: {'merge'}
		- Redirecting and Wildcarding Routes	
				{ path: 'not-found', component: 'NotFoundComp' },
				{ path: '**', redirectTo: '/not-found' },   //NOTE:- its double **
			
		- LocationStrategy:-
				RouterModule.forRoot(appRoutes, { useHash: true });
				
				This will be useful when we deploy on Apache/ which will parse the string before the #; whereas angular will parse after the #.
		
		- named router outlet 
			https://www.concretepage.com/angular-2/angular-2-4-named-router-outlet-popup-example#navigate
			app.component.html
				<router-outlet></router-outlet>
				<router-outlet name="green"></router-outlet>
				<router-outlet name="red"></router-outlet>
				
			app-routing.module.ts
				import { RouterModule, Routes } from '@angular/routes';
				
				const appRoutes: Routes {

					{ path: 'color', component: 'colorcomp'},
					{ path: 'green', component: 'greencomp', outlet: 'green'},
					{ path: 'red', component: 'redcomp',  outlet: 'red'},
					{ path: '', redirectTo: '/color', pathMatch: 'full'},					
				}
				
				imports: [
					RouterModule.forRoot( appRoutes )
				],				
				
				exports: [ RouterModule ],  // this is very important because without this, u will get router-outlet unknown errors !!!
			
			ng g c red 
			ng g c green
			
		- How to detect route changes? 
		A. Subscribe to this.router.events . Events are like : // example: NavigationStart, RoutesRecognized, NavigationEnd
			For more events look at: 
				https://angular.io/api/router/RouterEvent
			
			https://toddmotto.com/dynamic-page-titles-angular-2-router-events 
			https://stackoverflow.com/questions/33520043/how-to-detect-a-route-change-in-angular
			this.router.events
			  .subscribe((event) => {
				if (event instanceof NavigationEnd) {
				  console.log('NavigationEnd:', event);
				}
			  });			
			
		A.2. 
		this.router.events
			.filter(event => event instanceof NavigationEnd)
			.map(() => this.activatedRoute)	// getting the activatedRoute at the end of NavigationEnd.
			.map(route => route.firstChild)
			.switchMap(route => route.data)
			.map(data => data['asdf'])
		
			
		
Guards L135
	- CanActivate, CanActivateChild, CanDeactivate, CanLoad, Resolve

	- canActivate
		{ path: 'comp', component: 'SomeComp', canActivate: [AuthGuard] },

		@Injectable()
		export class AuthGuard implements canActivate {
			// 2 I/p params: route: ActivatedRouteSnapshot, state: RouterStateSnapshot from '@angular/router'. Angular will give us this data.
			// O/p: Observable<boolean> | Promise<boolean> if async, boolean if ran synchronously.

			canActivate( route: ActivatedRouteSnapshot, state: RouterStateSnapshot ) : Observable<boolean> | Promise<boolean> | boolean {
				// check if user is logged in.
			}
		} // class ends
	
Pipes: 
Pure, PipeTransform, impurepipe, async pipe
	// default pipes: date, json 
	
	Create custom pipe:-
		filesize.pipe.ts 
			import { Pipe, PipeTransform } from '@angular/core';
			
			@Pipe({
				name: 'filesize'
			})
			export class FileSizePipe implement PipeTransform {
				transform( ipvalue: number, extension: string = 'MB' ) {
					return ( size/ (1024*1024)).toFixed(2)) + extension
				}
			} // class ends 
			
			{{ data | filesize: 'megabytes' }}  // if megabytes is no given as extension, default MB kicks in

	Pipes as providers/services:- transform() method is the key.
		In SomeComp:-
			import { FileSizePipe } ...
			providers: [ FileSizePipe ];
			
			constructor (
				private filesizePipe: FileSizePipe;
			){}
		
		
			// NOW WE CAN USE transform():- this.filesizePipe.transform( somevar, 'mb');

few examples:-
{{ text | shorten:5 }}
{{ text | shorten:15:2ndparam }} // param1 and param2 will be argument2 and argument3 in the transform() method.
*ngFor = "let server of servers | filter: filteredStatus: 'status'	
	(filteredString is ngModel and is a class var too)
	('status' is a column)

Creating a filter pipe:- (Pure vs Impure Pipe)
eg. u have a table of contents and u want to search some content in it:-
 ng g p filter
 	... 
	transform ( value: any, filteredString: string): any {
		if (value.length === 0 || filterString === '') {
			return value;
		}
 	}

>> angular is NOT re-running the pipe when the data changes. (thanksfully).
	When ur data (in arrays / objects changes), then angular will not rerun the pipe.
>> if u add a space to the filteredString, then it will start showing the new changes.
This is because, changing the input of the pipe (param1 i.e. filteredString) will trigger angular to rerun the pipe.

The reason such a filtering condition exists is because, there is a high performance cost. (pure: true by default)
If u still wanted the pipe to re-run when the data changes, we have to create an impure pipe:-	
		pure: false;
	if u make the pipe impure, then it will respond to data changes.

---
Asyncpipe
| async 
	> if an observable, it auto subscribes and unsubscribes
	> if a promise, then it watches the promise object and if the promise returns a string, it will display that string.
		someclassVar = new Promise ( (resolve, reject) => {
			...
		});

======================================================================================

Building custom-elements with @angular/elements
	https://medium.com/@tomsu/building-web-components-with-angular-elements-746cd2a38d5b 

ng add @angular/elements	(adds to package.json) . interesting, we dont have to use "npm install --save"
ng g component button --inline-style --inline-template -v Native
ng g c button --inline-style --inline-template -v Native
	-v Native means:- 
	   We use ViewEncapsulation.Native so that the styles are bundled with the template and the component’s class into one file.
	   
Note:- The compiler takes the @NgModule.bootstrap:[] and const appRoutes: Routes and populates the @NgModule.entryComponents:[] automatically, so by default entryComponents: [] is not required explicitly, but when using @angular/elements, we will require to use it. So, by default, whatever is declared in bootstrap:[] will be added to entryComponents:[]

- createCustomElement() from @angular/elements.
- customElements.define() is from customElements, which is a TypeScript Object defined in lib.dom.d.ts
app.module.ts 
	import { NgModule, Injector } from '@angular/core';	// NOTE: Injector is an abstract class.
	import { createCustomElement } from '@angular/elements';

	bootstrap: [AppComponent],
  	entryComponents: [ButtonComponent]

	export class AppModule { 
	   constructor( private injector: Injector){   // Injector is an abstract Class
    		// const customButton = createCustomElement( ButtonComponent, { injector: injector } );
		// const customButton = createCustomElement( ButtonComponent, { 'injector': injector } ); // same as above.
    		   const customButton = createCustomElement( ButtonComponent, { injector } ); 		  // same as above.
    			 customElements.define('custom-button', customButton);
  	   }

  	   ngDoBootstrap(){} // u can write custom code here to manually bootstrap. Note, there is NO "implements DoBootstrap"
  		// https://blog.angularindepth.com/how-to-manually-bootstrap-an-angular-application-9a36ccf86429
	}

app.component.html
	<app-button btnLabel="ClickHere"></app-button>

===================================
ShadowDOM & ViewEncapsulation

   /*
    Shadow DOM is the concept of using a DOM tree within a DOM tree. Its an inbuilt browser feature.
    The concept also exists in HTML (webcomponents in polymer JS), where an element is placed in <slot></slot> as a placeholder (?)
    However, some browsers, may not have shadow dom, in which angular can be instructed to still implement its own shadow DOM.
      Angular does this by using its inbuilt feature i.e. ViewEncapsulation. (Note, ViewEncapsulation is an Enum)
        https://blog.thoughtram.io/angular/2015/06/29/shadow-dom-strategies-in-angular2.html
      Angular implements shadow DOM by assigning all elements to #shadow-root. A shadow root has 2 modes: open + closed.
      ViewEncapsulation mostly deals with style encapsulation (?)

        ViewEncapsulation.None - No Shadow DOM at all. Therefore, also no style encapsulation.
        ViewEncapsulation.Emulated - No Shadow DOM but style encapsulation emulation.
        ViewEncapsulation.Native - Native Shadow DOM with all it’s goodness. (will be deprecated)
	ViewEncapsulation.ShadowDom - replaces ViewEncapsulation.Native

        A) Problems with:-
          ViewEncapsulation.None:- This is called an "unscoped strategy".
              1. problem here is styles with same names could get overwritten. So, if comp1 has .test{} css class,
                  and app-comp doesnt have .test{} css class (u forgot to define it), but an html element in app-comp. is using .test{},
                  then the .test{} class frm comp1 will be applied to the html-element in app-comp (which is what we DONT want)
              2. problem:- If there is any <ng-content></ng-content> tag in the comps template, those will get replaced with script-tags
                  <script type="ng/contentStart"></script>
                    ...
                  <script type="ng/contentEnd"></script>
		  (Unable to replicate it now in v6)

        B) ViewEncapsulation.Emulated
          - is default
          - even if browser does not support shadow dom, angular will create/emulate it.
          - give a unique _ng-host_uniqueid class too.
          - NOTE: #shadow-root is NOT Created
          - Problem A1. is solved, html-element (in app-comp) will NOT get the style of comp1

        C) ViewEncapsulation.Native //. Deprecated from v6.1.0. Use ViewEncapsulation.ShadowDom instead.
          - will put it inside #shadow-root reference. Q. can this reference be picked up using viewchild() ??
          - inside #shadow-root, angular will provide the .test{} in the comp & also the global .test{} style.
              (so that the global can be used if required)
          - it will have the comps html element too within #shadow-root
          - Problem A1. is solved, html-element (in app-comp) will NOT get the style of comp1

        D) ViewEncapsulation.ShadowDom: replaces ViewEncapsulation.Native
    */

eg.
	@Component({ 
		encapsulation: ViewEncapsulation.Emulated // default. u can see some styles like _ng-host_NSOMEUNIQUEKEY
	})	

eg.2.
u can have application wide encapsulation set in main.ts like this:-
      platformBrowserDynamic().bootstrapModule(AppModule, {defaultEncapsulation: ViewEncapsulation.Native})
Note:- here the key is "defaultEncapsulation" and not "encapsulation" (which is used in @Component({})      
      

More:- 
https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813

Terminologies:-
	1. Shadow Root: 
	    > It's what gets attached to an element to give that element it's shadow DOM. 
	      Technically it's a non-element node, a special kind of "Document Fragment".
	2. Shadow Host: The element to which the shadow root gets attached. 
	      A host can access it's shadow root via a property on itself. .shadowRoot.
	      VIMP NOTE: The elements in a shadow tree are NOT descendants of the shadow host in general (including for the purposes of Selectors like the descendant combinator) - Spec
	3.  Light DOM: - 
		- The DOM that lives outside shadow DOM
		- The set of DOM elements we can sandwich between the opening and closing tags.       
		eg. 
		<custom-picture>
    				^^^^^^^^^^^^^^^^^^^^^^^^^^^
    				#shadow-root
    				___________________________

    			<!--Light DOM-->
    			<img src="https://path.to/a-kitten.png">
    			<cite>A Nice Kitten!</cite>
    			<!--Light DOM ends-->
		</custom-picture>
	4. DocumentFragment: The DocumentFragment interface represents a minimal document object that has no parent. It is used as a light-weight version of Document to store a segment of a document structure comprised of nodes just like a standard document. The key difference is that because the document fragment isn't part of the actual DOM's structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made. - MDN
	
Extra gyan:-	
Q. IN Vanilla JS, How to create Shadow DOM?
A.	<div class="dom"></div>
	let el = document.querySelector(".dom");
	el.attachShadow({mode: "open"});
	// Just like prototype & constructor bi-directional references, we have...
	el.shadowRoot // the shadow root.
	el.shadowRoot.host // the element itself.

	// put something in shadow DOM
	el.shadowRoot.innerHTML = "Hi I am shadowed!";

	// Like any other normal DOM operation.
	let hello = document.createElement("span");
	hello.textContent = "Hi I am shadowed but wrapped in span";
	el.shadowRoot.appendChild(hello);

Note:- Shadow DOM, cannot be removed once created. It can only be replaced with a new one.
Read https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813 for more gyan	


===================================
Viewchid & ViewChildren+QueryList<samecomp>:-

1. ViewChild:-
	- access html elements using #localref.
	eg. @ViewChild('localref') lref: ElementRef;
	this can now be access as this.lref in ngOnInit, etc.
	
   Usage:-
   	- simple use is in child component with html elements (with local refs)
	- advanced use:= other than local refs, it can also be used to get a JS-obj of the component itself
		eg. In app.comp.ts
			import { ComponeComponent } from './compone/compone.component';
			@ViewChild(ComponeComponent) x: ComponeComponent;
			this.x is now available as a JS-obj of that child comp. 

2. ViewChildren + QueryList<samecomp>:-
   Usage:- used in a parent which has multiple childs
   eg. in app.component.html
   	<app-compone><app-compone>
	<app-compone><app-compone>
		+
	import { ComponeComponent } from './compone/compone.component';
	@ViewChildren(ComponeComponent) xx: QueryList<ComponeComponent>;

Now this.xx will give us access to both the component-instances.
this.xx, this.xx.length (2 in this case), this.xx._results (is an array and u can loop over it).
	
===================================

Module:
	- @NgModule (declarations, imports, providers, bootstrap, entryComponents) Note :- import is a TS-keyword, where imports:[] is an angular feature.
				(exports, etc.) 
	- Feature module: L271 , say RecipesModule
		- IMP NOTE:- You cannot declare components, directives and pipes, in more than 1 module. Duplications not allowed.
		- In RecipesModule, in @NgModule({}). add CommonModule from @angular/common to imports:[] array of the new Feature Module. Gives access to ngClass, etc.
			NOTE: The AppModule has BrowserModule, instead of CommonModule. BrowserModule is a superset of CommonModule.
		- Add RecipesModule to the AppModule.	
	- Registering routes to a feature module: L272
		- Maintain import order in the imports:[] array in AppModule. 
		- If routing is in an AppRoutingModule, it should be the last item in imports:[] array, so that all wildcards can be accounted for.
		- create RecipesRoutingModule.
			-- const recipesRoutes: Routes = [
					{ path: 'new', component: 'Parent1', children: [
							{ path: 'new', component: 'Comp1', canActivate: [AuthGuard] },
							{ path: '', redirectTo: 'DefaultComp', pathMatch: 'full' },
							{ path: ':id', component: 'Comp2' },
						] // children ends.
					}, // parent1 ends	
				]; // recipesRoutes ends
			-- NOTE:- RouterModule.forRoot() should ALWAYS be used in AppModule, RouterModule.forChild() should always be used in the child component.
			-- 
				@NgModule ({
					imports:[
						RouterModule.forChild(recipesRoutes)
					],
					exports: [RouterModule]			//<<<<===== NOTE how we are exporting from the current RecipesRoutingModule
				})
		- goto the feature module RecipesModule and add RecipesRoutingModule to the imports:[] array.
		- the feature module RecipesModule will be in the AppModule::imports:[]
	- Shared module
		-- AppModule = FeatureModule1 + FeatureModule2
						-- FM1 and FM2 uses SharedModule
						
		-- L274 
		-- shared/shared.module.ts 
			@NgModule({
				declarations: [
					DropDownDirective	// has to be declared ONCE, somewhere. Its accessible only in current module.
				],
				exports: [
					DropDownDirective	// so that it can be imported in FM1 and FM2. It should be be accessible outside too.
				],
			})
		-- Add SharedModule to the RecipesModule::imports:[]	
		-- Add SharedModule to the AppModule::imports:[]
	
	-- 	Another Feature Module : ShoppingListModule
		- import {CommonModule} from '@angular/common'
		- imports:[ CommonModule, FormsModule]
		- Add ShoppingListModule to AppModule.
		- For routing, we could use RouterModule.forChild() which is fine, but lets c another way i.e. "Loading Components Via Selectors":-
			Loading Components Via Selectors:- 
					- 1. include the <app-shopping-list> </app-shopping-list>, add it to the declarations:[] array. (else u will get errors)
				-- OR--
					- 2. u have to import (TS-style) a module, which exports app-shopping-list component. (this we already saw with RecipesRoutingModule/ RecipesModule ?)
					
					1. 
					- FormsModule can be a problem, if its used @ multiple places, then should be mentioned everywhere.
					- OR it should be exported . But its a bad practise to export a module from a FM1 to be used in FM2.
			
	- Lazy Loading: Improving App Performance
		(Note: Opp. of Lazy Loading is Eagerly Loading, which loads everything)
		AppModule
			-- RootRouter
				-- ChildRoutes
				
		FM1 (RecipesModule) :-
			-- child router 
			-- component
			-- directive
			
		All Angular code is downloaded at the beginning.	
		But, If the user NEVER visits the FM1, then that particular code is never used and we downloaded too much code at the beginning.
		We can lazyload, FM1 and its children.
			-- i.e. FM1 is loaded ONLY if the route for FM1 is hit.
			
			
	- Adding Lazy load to the RecipesModule		
		- ng g c home --spec false
		- { path: '', redirectTo: 'HomeComp'},
			- { path: 'recipes', component: RecipesModule }, // Before: EAGERLY LOADING
			- { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule', }, //After: LAZY LOADING.
					IMPNOTE:- loadChildren takes a string, which of the format: '<path>#<ModuleName>' 
		- restart ng serve
		- network tab: disable caching is checked
			-- check chunk.js was added when the route was requested for.
	
	- Protect Lazy loaded Routes with ...
		-- using canActivate with lazy loaded is useless as the code wont be reachable until the route is loaded.
		-- we need something which can help us check before the route is called.
		-- use canLoad guard.
			eg. - { path: 'recipe', loadChildren: './recipes/recipe.module#RecipesModule', canLoad: [AuthGuard] }, 
			Note: AuthGuard should implement the "canLoad" interface.
			
	- Understanding Modules & Service Injection (when using FMs and Lazy Loaded modules)
		eg. 1. 
		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			Because, FM1 is injected into AppModule, using it at two places, wont hurt as the Root Injector will create ONLY one instance of the Serv1.
			LLM1, since its lazy loaded will also use the same global instance of Serv1 (provided by the Root Injector).	
			
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since no providers are used, LLM1 also uses the global instance of Serv1
			
		eg. 2. 	
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			LLM1 (Serv1) , providers: Serv1
			Here, LLM1, angular will create a child injector i.e. a local instance of Serv1.
	
			- Since, AppModule and FM1 are eagerly loaded, it uses the global instance of Serv1
			- Since providers are used @ module level, LLM1 will use a local instance of Serv1.
			
		Q. In eg.1., can FeatureModule1 be forced to use a local instance of Serv1 ?
		A. Yes, it can be done.
			If FeatureModule1, needs to be forced to use a local instance of Serv1, Serv1 should be removed from FeatureModule1::providers[] 
				and should be added to its child comp., say FMChild1::providers[]
				
		Q. In eg.1., 		
			AppModule (Serv1), providers: Serv1	
			FM1 (Serv1), providers: Serv1
			SharedModule (Serv1), providers: Serv1
			LLM1 (Serv1) , no providers for Serv1
			(i.e. AppModule, FM1 and SharedModule are eagerly loaded)

			- Here, SharedModule will have access to global instance of Serv1 
			- LLM1 will NOT have global instance, it will have a local instance of Serv1. 
			- So, be very careful when adding services to SharedModule !!!
			
			V. V.IMP:- DO NOT add services to shared modules, especially, if those services will be used in Lazy Loaded Modules !!!!

	- Understanding the core module:-
			AppModule: AppComponent + Component + Directive 
									> Component + Directive should be move to a Core Module, because they apply to our App Module.
	- Core module 
			- will be used ONLY in AppModule.
			- should NOT be used anywhere else like LLM, SharedModule or FM1.
			- U can move providers (services) from AppModule to CoreModule. Keeping the AppModule leaner is a good practise.
			- CoreModule should ALWAYS be eagerly loaded.
	- Ahead of time compilation
			- 2 types of compiling the code. :- JIT or AOT.
				-- What is compiling the code? It does NOT mean angular is moving TS code to ES5, that is done by the cli.
					A. Angular needs to compile ur templates by parsing. It moves html-code to JS-code. (html-elements have JS-equivalents).
					   Ang. does this because accessing JS-equivalents is much faster than parsing DOMs.
				Such compilation can be done using Just in Time / Ahead of time compilation.		
			- Just in time:- is default and what we regularly do using ng-serve
				-- Development -> production -> App downloaded to browser -> Angular parses and compiles the templates to JS
				Here, in the last step, parsing and compilation happens on the browser.
				- Bulkier. Because the compiler is shipped.
			-- Ahead of time:-
				-- Development -> Angular parses and compiles the templates to JS -> Production -> App downloaded to browser
				This has advantages:-
				- Faster startup. ZERO parsing and compilation on the browser.
				- Templates are checked during development.
				- Smaller File Size. Compiler is NOT shipped. Any other features which are NEVER used are never shipped.
				
			AOT using cli:-
			- open network tab and the vendor.js/anyother file are very bulky. It has the compiler and so on.
			- cancel "ng serve"
			- ng build (uses JIT)
			- ng build --prod (uses minification + JIT )
			- ng build --prod --aot (uses minification + AOT)
			- see dist folder and check sizes of all files.
			
			Usually servers gzip it, but that is another discussion.
			
	- Pre-Loading lazy loaded routes
			- if LL, u will load the chunk of LLMs at that time, when the route is visited, so there may be a lag of few secs.
			- it would be nice to use LL, but still pre-load the code, so that there is no lag.
			
			AppRoutingModule, where we define all our routes.
			import { Routes, RouterModule, PreloadAllModules } from '@angular/router';

			before:- RouterModule.forRoot(appRoutes)	// Hidden Default is { preloadingStrategy: DontPreload }		// ???
			after:- RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules } // This property takes a type-definition. PreloadAllModules
			
---
Interceptors.

import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
app.module.ts
	imports: [ HTTP_INTERCEPTORS, HttpClientModule, n other modules ]
	providers: [
		{
			provide: HTTP_INTERCEPTORS,
			useClass: MyHttpInterceptor,
			multi: true
		}
	]
	
.ts
import { Injectable, Injector } from '@angular/core';
import { HttpClient, HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';

export class MyHttpInterceptor implements HttpInterceptor: Observable<HttpEvent<any>> {
	intercept (req: HttpRequest<any>, next: HttpHandler) {
		console.log("intercepted request ... ");

		// Clone the request to add the new header.
		const authReq = req.clone({ headers: req.headers.set("headerName", "headerValue")});
		console.log("Sending request with new header now ...");
		
		//send the newly created request
		return next.handle(authReq)
				   .catch((error, caught) => {
						//intercept the respons error and displace it to the console
						console.log("Error Occurred");
						console.log(error);
						//return the error to the method that called it
						return Observable.throw(error);
					}) as any;
	}
} // class ends

---
										); 
Observable
	- operators
	- queryparams L126, L127
Subjects:-
	- using them as observables


---

FormsModule + ReactiveFormsModule
	import { FormModule } from '@angular/forms'; // shouls be inthe imports[] too of app.module.ts

Template-Driven Forms:-
- Angular infers the form object from the DOM, based on foll. conditions:-
- FormsModule 

Reactive Forms:-
- Form is created programmatically and synchronized with the DOM.
- Gives finer control.
- ReactiveFormsModule

Template-Driven forms:-
  > Add ngModel (yes, just 'ngModel') as an attribute on the control.
  > Give it a name. name = "username"
  > eg. 
  	<form #f = "ngForm" (ngSubmit) = "doSubmit(f)">	<!-- Dont forget the "" -->
  		<input ... ngModel name="username">
		<button ... type="submit"> <!-- imp: bcoz it triggers the default submission behavior -->
	</form>
	where f : HTMLFormElement in typescript in doSubmit()
	u can also get it using:-
		@ViewChild('f')signupForm: NgForm (note: Its NgForm in typescript and ngForm in HTML)
  
  > Adding Validation (HTML Validators to be precise)
  	required
	minlength = 8
	email
	[disabled]="!f.valid" + CSS rules like:- input.ng-invalid.ng-touched select.ng-invalid.ng-touched { border: 1px solid red }
  
  > Adding custom-error msgs.
    <input ... ngModel name="email" #email="ngModel"> <!-- Note: how ngModel is mentioned twice -->
    <span class="help-block" *ngIf="!email.valid && email.touched"> Email format is incorrect </span-block>
    	<!-- help-block is a bootstrap class -->
	
  > Defining default values:-
    Before:-
	    <select ... ngModel name="secret"> 
		<option value = 'pet'>What is ur fav.pet</option>
		<option value = 'teacher'>What is ur fav.teacher</option>
	    </select>
    After:-
	    <select ... [ngModel] = "defaultQuestion" name="secret"> </select>
	    where defaultQuestion is a class var i.e. defaultQuestion = 'pet';
  
  > Custom-Grouping Values in our form-structure:-
  	Use ngModelGroup on ur parent-element and give it a name.
	eg. 
	<div id= ... ngModelGroup="userData"> 
		where userData will be shown as a key in the #f obj. i.e. in NgForm::value::userData
		-OR-
	<div id= ... ngModelGroup="userData" #userData="ngModelGroup"> (to access the userData as a JS object)
		and add custom-error msgs.
	
  > Handling radio buttons : they are not a special case. 
  	<div *ngFor="let gender of genders">
	  <label>
	  	<input type="radio" 
			     ngModel name="gender" [value] = "gender">
	  </label> {{ gender }}
	</div>
	
  > setValue() and patchValue() helpers (setting and patching form values):
  	NOTE:- the @ViewChild('f')signupForm: NgForm  is still in use:-
	
  	Q. what if u wanted to initialize the whole form with initial set of value?
	A.1. this.signupForm.setValue({})
		setValue() takes and object which should represent the exact form-structure.
		use it <button type="button" ...>
		
		Problem:- this may overwrite all the already entered value, since its input object requires ALL values
		
	A.2. this.signupForm.form.patchValue({ })	
		To solve the problem in A.1., use this.signupForm.form.patchValue({ })
			its input object DOES NOT require all form-controls, but only the names of the ones u want to overwrite.
	
	IMP GOTCHA: this.signupForm.form.setValue({ }) is also available.
	IMP Q. So, whats the difference between this.signupForm.form.setValue({ }) and this.signupForm.setValue({})
	    A. Dunno Yet.

  > Using Form Data:-
	this.signupForm.get('username')
	this.signupForm.value.username
	
  > resetting the form:-
  	this.signupForm.reset() for reset all form values -OR- this.signupForm.reset({}) for specific form values.
	
	Q. Whats the difference between this.signupForm.reset() and this.signupForm.setValue() ?
	A. this.signupForm.reset() will also reset the angular classes on the shadow-DOM like valid, touched, etc.
	
---
Xtra1:=
Just some code for extra knowlege :- 
  <!-- Email error block -->
    <div *ngIf="email.invalid && email.touched"
        class="col-sm-3 text-danger">
 
        <div *ngIf = "email.errors?.required">
            Email field can't be blank
        </div>
 
        <div *ngIf = "email.errors?.pattern">
            The email id doesn't seem right
        </div>
    </div>
    
---

Reactive-driven:- L193:  @angular/forms : 
You are not creating the form in template, u r creating it in the class; but u r syncing with the template.
  Steps in short:-
  >> FormGroup(), FormControl() in TS
  >> [formGroup] = classvarForSignupForm, formControlName="username" where username was a key defined in FormGroup()
  >> formGroupName="userData" + userData.username in ngif custom errors ( both r in HTML)
  >> formControlName := assigned to a property in signupForm: FormGroup. used for singular elements. used to sync with HTML.
     formArrayName := assigned to a property in signupForm: FormGroup. used for grouping singular elements 
     formGroupName := assigned to a property in signupForm: FormGroup. used for nested FormGroup-s
          
	- ReactiveFormsModule
	- Class Variable
		import { FormGroup } from '@angular/forms';
		...
		signupForm: FormGroup
	- form
		this.signupForm = new FormGroup({
			'username' : new FormControl (null),
			'email': new FormControl (null),
			'gender': new FormControl('male'),
		});
		
		// method signature for FormControl().
			new FormControl (null),
			new FormControl (null, SingleValidator -OR- ArrayOfValidators),
			new FormControl (null, SingleValidator -OR- ArrayOfValidators, Single -OR- Array of Asynchronous Validators),
		
		- sync HTML template with FormGroup, using formControlName.
VIMP: note : formControlName is a string here and hence NO property binding is reqd. but if you want to do property binding, then formControlName ="username" is same as writing [formControlName] ="'username'"
VIMP note:- if an index is used, then PROPERTY binding will be REQUIRED. (like in formArrayName)
			<form [formGroup]="signupForm">
				<input ... id="username" formControlName ="username" ... >
				<input ... id="email" formControlName ="email" ... >
				<input ... id="gender" formControlName ="gender" ... >
				
		- submit the form using ngSubmit (no 
				<form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
					<input ... id="username" formControlName ="username" ... >
					<input ... id="email" formControlName ="email" ... >
					<input ... id="gender" formControlName ="gender" ... >		
					
				onSubmit(){ ... }  // this.signupForm, this.signupForm.controls, this.signupForm.value (user-typed)
	- Validators
		this.signupForm = new FormGroup({
			'username' : new FormControl (null, Validators.required), 
	// VIMP:-DO NOT execute it like Validators.required(); angular will execute it; it just needs to know the reference.
			'email': new FormControl (null, [Validators.required, Validators.email]),
			'gender': new FormControl('male'),
		});
		
	- Getting access to controls:- (for custom-errors)
		<span *ngIf="signupForm.get('username').valid && signupForm.get('username').touched">  
	        	// Note:- .get(name) or path-to-the-name, if its nested.
		  Please enter a valid username.
		</span>
		>>> unlike template driven, we dont have to write like:- #email="ngModel", etc.
		+ 
		input.ng-invalid.ng-touched { border: 1px solid red  } (same as in )
	
	- .get() also takes "path to an element": Nested FormGroups. (Grouping controls, unlike ngModelGroup in TD)
		// add a new nested FormGroup.
		this.signupForm = new FormGroup({
			'userData' = new FormGroup ({  // added a nested FormGroup
				'username' : new FormControl (null, Validators.required), 
				'email': new FormControl (null, [Validators.required, Validators.email]),
				});
			'gender': new FormControl('male'),	
		});
		
		+ // add a wrapper div with formGroupName, formGroupName="userData"
		
		<form [formGroup] = "signupForm" (ngSubmit) = "doSubmit()" >
			<div formGroupName="userData">
				<div > ... previous form elements username + email are here </div>
			</div>
		</form>

		+ // structure ur paths using dots (and NOT slashes!!!) eg. userData.username
		
		<span *ngIf="signupForm.get('userData.username').valid && signupForm.get('username').touched">  
	        	// Note:- .get(name) or path-to-the-name, if its nested.
		  Please enter a valid username.
		</span>
		
	- FormArray (Array of Form Controls)
		-- previously we saw Array of Validators, 
		
		'hobbies': new FormArray([]); -OR-
		'hobbies': new FormArray([ new FormControl() ... ]);
		
		<div formArrayName='hobbies'>
			<button type="button" (click) = "OnAddHobby()"
		</div>
		
		onAddHobby() {
		  const control = new FormControl(null, Validators.required);	
		  (<FormArray>this.signupForm.get('hobbies')) // typecasting + we r telling angular everything in here is a FormArray
		  			     .push(control);  // control wont be visible in view without formArrayName directive.
		}	
		
	       -- extend the html more:- formControlName is required to sync it with HTML.
	VIMP note:- if an index is used, then PROPERTY binding will be REQUIRED. (like in formArrayName)
	       	<div formArrayName='hobbies'>
			<button type="button" (click) = "OnAddHobby()"
		</div>
		<div class="form-group" <!-- form-group, form-control these are bootstrap classes -->
			*ngFor = "let hobbyControl of signupForm.get('hobbies').controls; let i = index">
			<input type = "text" class="form-control" [formControlName]="i">
		</div>
		
	- Creating custom validators:- (say custom validator for forbidden usernames)
		- Custom-Validators should return a value; should be a JS obj.
		- [s: string]: boolean
		class variable:-
			forbiddenUsernames = ['Chris', 'Anna'];
			
		forbiddenNames (control: FormControl): {[s: string]: boolean } {
			if(this.forbiddenUsername.indexOf(control.value) !== -1) { 
				//NOTE:= -1 if it is not found, but it is interpreted as true in JS, so we will have to use !== -1
				return {'nameIsForbidden': true};
			}
		   return null; // VIMP !!! NOTE: U SHOULD NOT PASS return {'nameIsForbidden': false} or OMIT this return statement
		}
		where 
			"[s: string]: boolean" is TS, which implies a key-value pair, with the key being a string. VIMP!!!
		
		+ 
		// NOTE:- this.forbiddenUserNames and NOT this.forbiddenUserNames()
		this.signupForm = new FormGroup({
			'userData' = new FormGroup ({  
				'username' : new FormControl (null, [ Validators.required, this.forbiddenUserNames]), 
				'email': new FormControl (null, [Validators.required, Validators.email]),
				});
			'gender': new FormControl('male'),	
		});
		
		// this will give error
		'username' : new FormControl (null, [ Validators.required, this.forbiddenUserNames.bind(this)]), 

	- Using Error Codes :- (custom-errors for our custom-validator)
		<span *ngIf = "signupForm.get('userData.username').errors['nameIsForbidden']" > ... </span>
		

        - create async validator (querying a web-server for validations)
		forbiddenEmails(control: FormControl): Promise<any> | Observable<any> // note the return type has changed
		
		forbiddenEmails(control: FormControl): Promise<any> | Observable<any> {
			const promise = new Promise<any>((resolve, reject) => {
				setTimeout(() => {
					if (control.value === 'some@someemail.com') {
						// Validation failed. Since its a promise, we dont return(), we resolve()
						resolve({'emailIsForbidden': true});
					} else {
						resolve(null);
					}
				}, 1500);
			});
			return promise; // NOTE THIS
		} // forbiddenEmails ends
		
		+
		// Note: DONOT execute i.e. this.forbiddenEmails(), use this.forbiddenEmails.
		
		'email': new FormControl (null, [Validators.required, Validators.email], this.forbiddenEmails ),
		
		// if u observe the DOM now, u will see ng-invalid -> ng-pending -> ng-valid or vice-versa. 
			// ng-pending is the directive angular inserts while it is still evaluating.
		
        - reacting to valueChanges(), statusChanges(), setValue({}), patchValue({}) 
	There is a form state, which u can track in general 
	on the signupform i.e. this.signupform -OR- on any control i.e. this.signupform.get('username'), u have 2 observables which u can listen to 
		*.valueChanges() -OR- *.statusChanges()
	1.
// this.signupform.valueChanges() can be used whenever we change something on the form. It return an object notation of the form.		this.signupform.valueChanges().subscribe( 
			(value) => { console.log(value); }
		);	
	2.
// STATUS means INVALID, PENDING, VALID, etc.
		this.signupform.statusChanges().subscribe( 
			(status) => { console.log(status); }
		);	
	3. this.signupform.setValue({ complete obj })       // same as TD
	4. this.signupform.patchValue({ specific keys in an obj }) // same as TD
	5. this.signupform.reset() -OR- this.signupform.reset({})
		eg. of this.signupform.reset({}) can be to reset radio buttons

	  
---

Life-cycle hooks:- https://codecraft.tv/courses/angular/components/lifecycle-hooks/ 
	- (hooks are executed in this order)
		- constructor, 
		- ngOnChanges (invoked when input properties are changed), ngOnInit (invoked on initialized, invoked ONLY ONCE after the 1st ngOnChanges), 
		- ngDoCheck (invoked when the change detector of the given component is invoked, allows us to implement alternative change detection algo).
			IMP: ngDoCheck and ngOnChanges should NOT be implemented on the SAME Component
		- ngOnDestroy
			-- invoked just before angular destroys the component.
	- Hooks for the components children	
			-- ngAfterContentInit ( invoked after any content projection is done into the components-view. )
			-- ngAfterContentChecked ( invoked each time the CONTENT of the given component has been checked. )
			-- ngAfterViewInit ( invoked when the components view has been fully initialized)
			-- ngAfterViewChecked ( invoked each time the VIEW of the given component has been checked. )
	
	- ngOnChanges eg.
		ngOnChanges(changes: SimpleChanges) {
		  console.log(`ngOnChanges - data is ${this.data}`);
		  for (let key in changes) {
			console.log(`${key} changed.
		Current: ${changes[key].currentValue}.
		Previous: ${changes[key].previousValue}`);
		  }
		}	
			
Types of communications:- https://angularfirebase.com/lessons/sharing-data-between-angular-components-four-methods/
	- Parent to child
	- child to parent using ViewChild 
	- child to Parent using @output + EventEmitter
	- Using Subjects/BehaviorSubjects
Simple API unit testing using jasmine
Angular animations

Ultimate angular:-
- Content Projection n its types
	ng-content :- to form pieces of the form. 
		eg.1. simple ng-content
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> ></auth-form>
						<auth-form () = "" <h3>Login<h3> ></auth-form>
			AuthFormComp: Put <ng-content></ng-content> as placeholder, to show where the h3 should be inserted.
		
		eg.2. ng-content with projection/injection slots. (same for login)
			AppComp: 		
						<auth-form () = "" <h3>Create Account<h3> 
										   <button type="submit">Join Us</button>
						></auth-form>
						
			AuthFormComp: 
						<ng-content select="h3"></ng-content>		where it requires to be projected/injected
						<ng-content select="button"></ng-content>	where it requires to be projected/injected

			Do same for Login
			
		eg.3. Content-project a component & bind to it 
			AuthRemember:
			AppComp: 
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>	
			checked is of EventEmitter
			
			AuthFormComp: 
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<ng-content select="button"></ng-content>	
						
			Note:= we can also use <ng-content select = ".somecssclass"	> </ng-content>		
			Binding can be done using class-var.
			
		eg.4. @ContentChild and ngAfterContentInit
			In eg.3., h3, auth-remember and button are contentchild of auth-form 
			
			AuthFormComp:
				
				In its template:-
						<ng-content select="h3"></ng-content>
						<ng-content select="auth-remember"></ng-content>						
						<div *ngIf="showMessage"> 
							You will be logged in for 30 days.
						</div>
						<ng-content select="button"></ng-content>	
			
				import { AuthRememberComp } from '';  // We r importing, so that we can query it after the content has been initialized.
				import { ContentChild, AfterContentInit} ... 
				
				@ContentChild(AuthRememberComp) remember: AuthRememberComp ;
				
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.checked.subscribe( (checked: boolean) => {
							this.showMessage = checked;
						});
					}
				}
			
			
		eg.5. @ContentChildren and QueryLists
				
				AppComp: 
			
						<auth-form (submitted) = "loginuser($event)" <h3>Login<h3> 
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <auth-remember (checked) = "rememberUser($event)></auth-remember>
										   <button type="submit">Login</button>
						></auth-form>
			
			
				import { ContentChildren, QueryList, AfterContentInit} ... 
				@ContentChildren(AuthRememberComp) remember: QueryList<AuthRememberComp> ;
			
				ngAfterContentInit() {
					if(this.remember) {
						this.remember.forEach( (item) => {
							item.checked.subscribe( (checked:boolean) => this.showMessage = checked; );
						});
					}
				}
			
			
		eg.6. ViewChild and ngAfterViewInit 
		
				AuthMessageComp: 
					<div *ngIf="showMessage"> 
							You will be logged in for 7 days.
						</div>
						
				Pending.		
					
		eg.7. ViewChildren and ngAfterViewInit 	
			
						
- ngTemplateOutletContext

- Change Detection & immutability:
	OnPush + Immutable Data Objects :- Angular is faster when using immutable objects;
	We can build stateless/presentation/dummy components. (?)
	
	SomeComp:-
		changeDetection: ChangeDetectionStrategy.Default
		changeDetection: ChangeDetectionStrategy.OnPush 
		
- Dynamic components using ComponentFactoryResolver:-
	What we are going to do:-
		import {AuthFormComp}...
		<div>					// this serves as a container
			<div #entry></div>  // We will use the ComponentFactoryResolver to inject the AuthFormComp here. We will create a factory method for it.
		</div>
		- Note:  @Output()Submitted = new EventEmitter(); 

	App Comp implement AfterContentInit:-
		@ViewChild('entry', { read: ViewContainerRef}) entry: ViewContainerRef;  
		// the 2nd param here by default is an ElementRef, until we explicitly ask for a ViewContainerRef
		
		constructor(
			private resolver: ComponentFactoryResolver		// from @angular/core
		){}
	
		ngAfterContentInit() {
			const authFormFactory = this.resolver.resolveComponentFactory(AuthFormComp);
			const component = this.entry.createComponent(authFormFactory); // We will get error. Add entryComponents:[AuthFormComp] to auth-form.module.ts 
		}
		
		

Services:- egghead:-
Interceptors:-

PrimeNg:-
	PrimeNg v4.1, font-awesome v4.7.0
		npm install primeng --save 
		npm install primeicons --save
		npm install font-awesome --save 
		npm install @angular/animations --save 
	
	angular-cli.json:-
		styles: [ font-awesome.min.css, primeng/resources/themes/omega/theme.css, primeng/resources/primeng.min.css ]
	module.ts: 
		import { BrowserModule } from '@angular/platform-browser';
		import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
		import { AngularFontAwesomeModule } from 'angular-font-awesome';
		import { AccordionModule } from 'primeng/components/accordion/accordion';
		import { MenuItem } from 'primeng/components/accordion/accordion';
		import { MenuModule, MenubarModule } from 'primeng/primeng';

		Add to imports:[]

	AppComp:-
		{
			label: 'label1',
			icon: 'edit',
			items: [
				{label: 'Undo', icon: 'fa-mail-forward'}.
				{label: 'Undo', icon: 'fa-mail-forward'}
			]
		}
		
	<link rel="stylesheet" type="text/css" href="/node_modules/primeicons/primeicons.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/themes/omega/theme.css" />
	<link rel="stylesheet" type="text/css" href="/node_modules/primeng/resources/primeng.min.css" />
	
---
	ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
	app/app-routing.module.ts
		
		- RouterModule.forRoot(appRoutes);
		
			@NgModule({ 
				imports: [ RouterModule.forRoot(appRoutes) ],
				Exports: [ RouterModule ]
			})
			
			export class AppRouting {}
		
		- <router-outlet></router-outlet> 
		
		
---

ElementRef,
ViewContainerRef, ViewContainerRef::createEmbeddedView, TemplateRef<any>, 
OOS:- ViewContainerRef::createComponent()

---
http://qnimate.com/post-series/ecmascript-6-complete-tutorial/ 

ES6:-
- call, apply & bind
	Obj1: properties & methods 	 
	Obj2: properties & methods 
	
	var obj = { num: 10};
	var addToThis = function (p1) {
		return this.num + p1;  // num is not yet accessible here
	};
	addToThis.call(obj, 20); //fn-name.call(obj, fn-args);
	addToThis.apply(obj, [20, 30]);
	addToThis.bind(obj, [20, 30])(); // bind returns a call

- Spread (... operator). 
	[1,2,3] ==> ...numbersArray
- Generics, interfaces
	interface:- is a contract that needs to be implemented.
	generics:- allow us to be less flexible 
		let numberArray: Array<number>;
- type alias

---

Angular Material Design:- Adding a custom theme 
	http://github.com/angular/material2

style.scss
	/* You can add global styles to this file, and also import other style files */

	@import "~@angular/material/theming";	// actual filename is _theming.scss, _ because its a partial. sass pre-processor ignores _ files.

	// Include non-theme styles for core.
	@include mat-core();

	// Define a theme.
	$primary: mat-palette($mat-pink);	// -OR- mat-palette($mat-indigo)  -OR-  $mat-red
	$accent:  mat-palette($mat-deep-purple, A200, A100, A400);	// -OR- $mat-pink

	$theme: mat-light-theme($primary, $accent); // we could also use mat-dark-theme().

	// Include all theme styles for the components.
	@include angular-material-theme($theme);

Add to to styles: [] in angular.json and restart ng serve

---

Rxjs6 In Practise:-
		Rxjs6:-
		git clone https://github.com/angular-university/rxjs-course.git
		git checkout -b 1-operators

		npm start (will start the dev-server which provides courses & lessons rest apis)

		interval(1000), timer(3000, 1000), fromEvent(document, 'click');

		1. 
		Non-Completing streams:- keeps emitting, but never completes.
			document.addEventListener('click', (event) => {
				console.log (event);
			});
			
			const counter = 0;	// emits a value after every 1 sec but never completes.
			setInterval(() => { counter++; c.log(counter); }, 1000);

		Completing stream:- executes only once.
			setTimeout(() => { console.log('Finished...'); }, 3000);
			
		2.
		Observable is a blueprint of a stream.
		subscribe() gives us an instance of the stream.
		 
			const interval$ = interval(1000); // rxjs interval() does same thing as setInterval();
			interval$.subscribe(	// instance of a stream.
				(val) => { console.log(val); }
			);
			interval$.subscribe(
				(val) => { console.log(val); }
			);
			
		3.	Wait for 3 seconds and then emit the values. Use timer()
				const interval$ = timer(3000, 1000);	// waits for 3 seconds before starting to emit.
				interval$.subscribe(
					(val) => { console.log(val); }
				);
				
		4. Define a stream of clicks: use fromEvent()

				const click$ = fromEvent(document, 'click');
				click$.subscribe(	// instance of a stream.
					(event) => { console.log(event); }
				);
			
		5. Stream Errors & Stream Completion.

				click$.subscribe(
					(event) => {},
					(err) => {},
					() => { console.log ('completed'); }
				);

			Subscription & Cancellation using unsubscribe
				// subscription
				const subscription = interval$.subscribe(	// instance of a stream.
										(val) => { console.log(val); }
									);
				
				// cancellation/unsubscribe
				subscription.unsubscribe();					
				
		6.  
		- How do observables work under the hood?
		- Build ur own http observable.

		fetch() is a browser api. it can be used to call rest apis.
		fetch('/api/courses') will return a promise.
			- promise get executed as soon as they r defined.
			-	observer.next()  to emit a value. will only be called on subscribe() call.
				observer.error()
				observer.complete() to complete it.
				

			const http$ = Observable.create( observer => {
				fetch('/api/courses')
					.then( response => response.json())  // response.body(), response.ok(), response.status() are few other.
					.then ( body => {					 // body here meants the json-body/json-data
						observer.next(body);
						observer.complete();
					})
					.catch ( err => {
						observer.error(err);
					})
					;	
			});

			http$.subscribe(
				( data ) => console.log(courses),
				noop, // -OR- ( err ) => {}, // noop is an rxjs function for no operation
				() => {}
			);
			
		7. 
			pipe operator: chain multiple observables eg. pipe(map ( ... ) )
			Map operator: eg. map (x => 10*x)
			
			const courses$ = http$.pipe(
				map( res => Object.values (res["payload"]) );	// payload is a property which has array of objects. REST API response is : obj-of-payload: Arr-of-objects
			);
			
			courses$.subscribe( ... );
		---

		L10:- stopped. to be continued later.
			
---

morgan project:-

ng new primeproj1 --style=sass
	npm install primeng --save 
	npm install primeicons --save
	npm install font-awesome --save 
	npm install @angular/animations --save 
	
- json server for products 
	-- unit test for same
- App Routing Module
app.module.ts
		-> imports app-routing.module.ts			
			-> imports FM products.modules.ts
			-> imports CommonModule
				-> declarations + imports products.component.ts
		-> exports RouterModule + FM Products Module		
		
- Products Featured Module ( Component + Service + Directive ) 
		Products.Component.ts	
			-- dispatch an action 
			-- reducer
				-- products service
			-- comp has data 
			
npm install @ngrx/core @ngrx/store --save
create store/
	step 1: create App level interface AppStore (app.store.ts).
			>>  { products: any } 
	
	step 2: StoreX.module.ts  (StoreXModule class)
		Maps interface-keys of app.store.ts to reducers (defined in various *.reducer.ts file) using ActionReducerMap<AppStore>
			>> 
				export const reducers: ActionReducerMap<AppStore> = {
					products: ProdReducer.productreducerFn
				};
			
				import * as ProdReducer from './product.reducer';
				NOTE.:- productreducerFn in ProdReducer.productreducerFn will be an exported function name "productreducerFn"
	
	step 3: store/reducers/products.reducer.ts
			export function productreducer(state = initialState, action, any) {}
				where 
					- initialState implement an interface like IProducts for string-type.
					- action is of type any for now, but it should change to ALLACTIONS (from store/actions/products.action.ts)

	step 4: store/actions/products.actions.ts 
			- import { Action } from 'ngrx/store';
			- export type AllActions = Class1implementsAction | Class2implementsAction ;
			
			- export class class1 implements Action {  // Here u can name the class1 anything, its not of significance outside this file.
					readonly type = someConstValue;	   // This is v.imp
				}
				
			- export const someConstValue = 'GetProducts'; // RHS is very imp. Will be used in the switch-case in the reducers.	

			eg. 
				import { Action } from 'ngrx/store';
				export const getProducts = 'GetProducts';
				export class FetchProducts implements Action {
					readonly type = getProducts;
				}
				export type ALLACTIONS = FetchProducts;

- Shared Module
	- Shared components ( Prime Ng )
		-- Data Table Component
		-- Shared Prime Ng button.
- Ngrx
	- Storemodule
	- action creators, reducer
	- Unit test for reducer

	
