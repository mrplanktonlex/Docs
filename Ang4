 TS: examples list 1
//number, string, boolean, null, undefined,
//enum, void, generics, interfaces, decorators, method decorators and class decorators
// testing TS code 

1.ts

let global = 'I am global';
let global2 : string = 'I am global 2';
//console.log (global, global2);

const count: number = 1;

if (count < 10){
  console.log(global, global2);
  let local1 = 'tmp1';
}

//console.log(local1); //error

2.ts
//explicit
let xname: string = 'Plankton';
console.log (xname);

//implicit
let firstname = 'plankton';
//firstname = 10; //not assignable. error
console.log (firstname);

tsc 2.ts
node 2.js (no need to link to html and open in browser)


+++++++++++++++++++++++++++++++++++++++++

var = mutable (allows redefining, if of the same data type )
    eg.1. Allowed
    var x:string = 'x';
    var x:string = 'y'; //redefining is allowed
   
    eg. 2. NOT Allowed
    var x:string = 'x';
    var x:number = 10; //error
   
let = mutable (does not allow redefining)
    let x:string = 'x';
    let x:string = 'y'; //redefining is NOT allowed
   
const = immutable

+++++++++++++++++++++++++++++++++++++++++ 

 UDM: es6, es7, es8 (part 1 -setup)
arrow functions,
enhanced collections,
generators
etc.

Babel + webpack

Transpiler = Reads code written in one language and produces equivalent code in another lang.
eg. coffeescript, typescript, etc.

Why do we need transpilers?
- browsers only recognize old JS
- make advanced js code compatible with such browsers

Webpack:-
- Its a bundler for modules. bundles modules into one .js file. This reduce errors and resources on the client-side.
- comes with a dev-server

Setting up with webpack :- (v 1.14.0)
mkdir es6
cd es6
npm init -y (for package.json file)
npm install --save-dev webpack
atom .
create new folder "build/"
create an index.html file in es6/build/index.html
    index.html should refer to bundle.js
    <body>
    <script type="text/javascript" src = "bundle.js" > </script>

create another folder es6/app/
index.js is created  with:
console.log ('hello world from webpack')

es6/webpack.config.js file:-
module.exports = {
    entry: ['./app/index.js'],
    output: {
        path: './build',
        filename: 'bundle.js'
    }
}
Note: my webpack version was: "webpack": "^2.5.1" (see package.json)
Also, this version requires the absolute path, so changed it to :
output: {
    path: 'D:\\js\\es6\\build',
    filename: 'bundle.js'
  }

----

goto package.json
lets update the "scripts" component.
"scripts" : {
    "build": "webpack"
}

//this means run webpack

goto cmd and run:
npm run build

this creates build/bundle.js

----

If errors occur, plz note, bundle.js wont be created. 
If success, u will get below message of bundle.js created
D:\js\es6>npm run build> es6@1.0.0 build D:\js\es6
> webpack

Hash: 9a212640681719bdad30
Version: webpack 2.5.1
Time: 73ms
    Asset    Size  Chunks             Chunk Names
bundle.js  2.8 kB       0  [emitted]  main
   [0] ./app/index.js 45 bytes {0} [built]
   [1] multi ./app/index.js 28 bytes {0} [built]
 
--------------------------------



open index.html on http and see if the console.log is displayed

------------------------------

1) You might need to change your webpack version.
The version of webpack that you'll need is ^1.14.0. Change the webpack version in your package.json file to match this.
Then delete your node_modules folder, and run npm install.
2) Install webpack globally with `npm install webpack -g'.
3) In webpack.config.js change the path in output to 'path: __dirname + '/build' in this file.
4) If the above path does not work, also try: path: __dirname + '/dist/js'
5) Clone the repo, run npm install and npm start and you should be good to go!

------------------------------

npm install  babel-core  babel-loader  webpack-dev-server  babel-preset-es2015  babel-polyfill  --save-dev

open webpack.config.js  and add

,
module: {
    loaders: [ //specify objects for each loader
    {
        loader: 'babel-loader' ,
        test: /\.js$/,
        exclude:  /node_modules/, //we dont want to transpile the .js on node_modules
    }
    ]
},
devServer: {
    port: 3000,
    contentBase: './build',
    inline: true, //allows us to run automatic live code update
}

So, finally, webpack.config.js should look like this:-

module.exports = {
  entry : ['./app/index.js'], //entrypoint
  output: {
    path: 'D:\\js\\es6\\build',
    filename: 'bundle.js'
  },
  module: {
      loaders: [ //specify objects for each loader
        {
          loader: 'babel-loader' ,
          test: /\.js$/,
          exclude:  /node_modules/, //we dont want to transpile the .js on node_modules
        }
      ]
  },
  devServer: {
      port: 3000,
      contentBase: './build',
      inline: true, //allows us to run automatic live code update
  }
} //module.exports ends.

-----------------------------------

package.json

after "scripts", add a new "babel" property

"babel": {
    "presets" : ["es2015"]
   
},


Also add one more line to "scripts" section
so that it looks like:

"scripts" : {
    "build": "webpack",
    "start": "webpack-dev-server"
},

----------------------

go back to terminal and run : npm start
http://localhost:3000/ and see console.log (hello world from webpack )

change the console.log and see if automatic update (remember we set inline: true ??) is working
console.log should work without restarting the web server

---------------------

Forking the coding environment:

https://github.com/15Dkatz/es6-in-depth-tutorial

---------------------
//dont do:
npm install (to install devDependencies: in package.json). npm install will auto install .
but lets not do that.

jasmine setup for es6

npm install -g jasmine-core

 

jasmine -v 

D:\js\es6>jasmine -v
jasmine v2.6.0
jasmine-core v2.6.1 

 

npm install -g karma-cli
npm install karma jasmine karma-jasmine --save-dev
karma init
edit karma.conf.js
    files: [
      'tests/*.js',
    ],
    
 singleRun:true

karma start 
npm start (to run webpack)   
 


++++++++++++++++++++++++++++++++++++++++++++++

Template literals: ``

let a = `good`;
let b = `${a} morning`;
console.log(b);

See how the interpolation is done using ${a}

-----------------------------

Operating & Destructuring

- spread operator (...)
    let a = [20, 30, 40];
    let b = [10, 50];

//combining a n b, spread and interpolates
let b = [10, ...a, 50 ]
   
- rest parameter
function (...){} ;
-destructuring assignment: this simplies extracting data on arrays and objects into distinct variables

eg.
function (...a){
c.log(a);
}

a(1,2,3,4,5);

----------------------------

-destructuring assignment: this simplies extracting data on arrays and objects into distinct variables


let z = [4,5,6];
let four = z[0];
let five = z[1];

console.log(four, five)

-OR-

let [four, five] = z;
console.log(four, five);


with object:=

let king = { name: 'mufasa', kids : 1};
let name = king.name;
let kids = king.kids;

console.log(name, kids);

-OR-

let {name, kids} = king; //note the curlies
console.log(name, kids);

Note:-
we cannot write like this:=
let name, kids;
{name, kids} = king;

This will not work.
if u wanna make this work, then do this:-
({name, kids} = king);


------------------------------

Methods & Modules:-

1. Arrow functions:-
function(){ ... }
-becomes-
() => {}

By default arrow functions are anonymous
2.
Modules:-
- Code living in separate files
- Split code into unique files based on relevant data

Handled in es6 using the export and import keywords

------------------------------

function cheer(){
    console.log('woohoo');
}
cheer();

var cheer = function(){
   c.log('woohoo2');
};
cheer();


setTimeout(function(){
     console.log('woohoo3');
}, 3000);

//es6 code.

setTimeout(() => {
     console.log('woohoo3');
}, 3000);

//es6
let cheer = () => {
  c.log('woohoo4');
};
cheer();

------------------------------------

arrow functions in helper methods like map, filter.

let values = [1, 2, 3];
let double = (n) => {
   return n * 2;
}
let doubled = values.map(double); //double is a callback .
console.log(doubled);

- OR-
let doubled = values.map((n) => {
 return n*2;
});
console.log(doubled);

- OR-
since it is only one loc, we can shorten it by
- removing the curlies
- removing the return keyword

let doubled = values.map((n) => n*2;);
console.log(doubled);

--------------------------------

es6 additional helper methods

- String.repeat() //returns string of concatenated copies
- searching with startsWith, endsWith, includes and more ...
- number checking for type and safety

------------------------------

string helper methods:

String.repeat(

let b = "wooh" + "oo".repeat(50);
console.log(b);

let b = `wooh${"oo".repeat(50)}`;  //using literals.
console.log(b);
See how "oo".repeat(50) is put in ${} to make interpolation work.

------------------------------
console.log("butterfly".includes("cater"));
console.log("butterfly".startsWith("cater"));

.startsWith, endsWith and .includes all return boolean values.

-----------------------------
v 51
checking numbers: (validating data input in application)

eg1.

const addToCart = (item, number) => {
     return Number.isFinite(number); //allows to check input data.
}

console.log(addToCart('shirt', Infinity));

 -OR-
....
return Number.isSafeInteger(number); //returns false. so even though finite, JS cannot handle it.
}
console.log(addToCart('shirt', Math.pow(2,54)
                                     ));

==========================

Modules:-

import = get primitive values, objects and functions from another module
export = just export

default: fallback expression when it exports multiple



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 UDM es6, es7. es8 -- part 2
Pre-requisite:- get ur environment working
index.js
eg.1  
console.log("hellow world from webpack ! Welcome to the matrix neo !!!");

let fname = 'sachin';
//let comment = fname + 'is a great guy';
//let comment = `is a great guy`; //multiline backticks
/*
let comment = `is a
 great
 guy`;
*/

//template literals
//let comment = ` ${fname} is a great guy`;
let comment = ` ${fname + " Tendulkar"} is a great guy`;
console.log (comment);

eg. 1.2.

let fnames = ['sachin', 'ramesh'];
let comment = ` ${fnames + " Tendulkar"} is a great guy`; //works fine
console.log (comment);

let comment = ` ${fnames[0] + " Tendulkar"} is a great guy`;
console.log(comment);

//eg.1.3.
let names = {
    fname1: 'sachin',
    fname2: 'manjrekar'
};

let comment = ` ${names['fname1'] + " Tendulkar"} is a great guy`; //works fine
console.log (comment);

let comment = ` ${names + " Tendulkar"} is a great guy`; //[object object] Tendulkar is a great guy
console.log (comment);

//eg.1.4.
let boolVal = true;
let comment = ` ${boolVal + " Tendulkar"} is a great guy`;
console.log (comment);

----------------------------------------------

eg.2. Arrow functions

//eg.2. function declaration (named function)
function sayHello(){
  console.log ('Plz say hello');
}
sayHello();

//function expression
var sayHello = function(){
  console.log ('sayHello as function expression');
};
sayHello();

//single line: arrow function
var sayHello = () => console.log('sayHello as arrow function') ;
sayHello();

//multiline arrow function
var sayHello = () => {
  var a = 1;
  var b = 2;
  console.log ('multiline arrow function')
  return a + b;
}
sayHello();

//arrow function with parameters
var calc = (x, y) => {
  console.log ('arrow function with multiple params', x + y);
  return x+y;
}
calc(1, 2);

//arrow function with single param
var calc = (x) => {
  console.log('arrow function with single param: ' + x);
};
calc(10);

//arrow function with single param and single line and single line is a return statement.
//remove return keyword

var calc = ((n) => n * 2); //valid. Note: no return keyword. Preferred.
//var calc = (n) => n * 2; //valid. Same as above. no return keyword
//var calc = ((n) => n * 2;); //INVALID. No semicolon on the line of return. VIMP.
console.log(calc(10));

//NOTE: var keyword from ES5 allows for re-creation and re-assignment of an existing variable
//Es6 does not have a var keyword, instead it has let. and let does not allow in re-creation and re-assignment
//const are immutable .

eg. 3
function expressions: let and const. 
f.exs. with const cannot be re-defined, but f.exs. with let can be re-defined. 

 let func1 = () => {};
//console.dir(func1);

func1 = () => {
  console.log('func1: overriding above function expression');
};
console.log(func1());


const func2 = () => {};
/*
func2 = () => {
  console.log('func2: overriding above function expresssion');
};
*/
console.log(func2());
//console.dir(func2);

eg.4 const and its gotchas with objects.

//eg. 4.1 . number . immutable.
const length = 10;
//length = 20; //NOT Allowed. immutable.
console.log('length is ' + length);

//eg. 4.2 . string . immutable.
const tenLength = 'ten';
//tenLength = 'twenty'; //NOT Allowed. immutable.
console.log('tenLength is ' + tenLength);

//eg. 4.3 boolean. immutable.
const someFlag = true;
//someFlag = false; // NOT Allowed. Immutable
console.log(someFlag);

//eg. 4.4

/*
For objects, complete re-assignment is NOT allowed.
However, existing set of values can be modified/pushed/popped, etc.
*/

//objects
const o = {}; //deviation: const on objects are modifiable
o['one'] = 1;
o['two'] = 2;
//o = {'villian': 'joker'}; //re-assignment is not possible
console.log(o);

let newO = JSON.parse(JSON.stringify(o)); //creating a new copy.
newO['two'] = 'T.W.O.';
console.log (newO);
console.log('-----------');

//arrays
const a = []; // deviation: const on objs (array is an object) are modifiable
a[0] = 10; //pushing is possible
console.log(a);
a.push(20); a.unshift(0);
console.log(a); //pushing & unshifting is possible
a.pop(); a.shift(); //popping & shifting is possible
console.log(a);

//a = [10, 20, 30]; //re-assigning is not possible

let newA = a.slice();
console.log('newA is: ' + newA); //possible

++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 UDM es6, es7. es8 -- part 3 (import n export)
es6/app/recipe.js

let recipeNames = ['kebab', 'dosa'];
let recipeObject = {
  name: 'Dum biryani',
  author: 'sanjeev kapoor'
};

let func1 = () => {
  console.log('this is func1: recipe.js');
};

const func2 = () => {
  console.log('this is func2: recipe.js');
};

export {recipeNames, recipeObject, func1, func2} ;
export default recipeObject ;

/*
http://2ality.com/2015/07/es6-module-exports.html

Exporting: ES6 modules export immutable bindings ; CommonJS modules export values.
bindings are live connections to values.

styles of importing:
1. import * from './recipe' ;
2. import {recipeNames, recipeObject, func1, func2} from './recipe';

Styles of exporting:
1. inline exporting:
export let var1 = 10;
export let var2 = 'var2';

2. explicit exporting
export {recipeNames, recipeObject, func1, func2} ;
export default recipeObject ;

3. u can export variables/constants, functions, array, objects
- also classes 
- Q. how to import classes?

*/

es6/app/index.js

console.log("hellow world from webpack ! Welcome to the matrix neo !!!");

import {recipeNames, recipeObject, func1, func2} from './recipe'; //.js is understood

console.log (recipeNames, recipeObject);
recipeNames.push('jackass'); //modifiable as if they r local
recipeObject['age'] = 50; //modifiable as if they r local
console.log (recipeNames, recipeObject);

//recipeNames = ['recipe1', 'recipe2']; //NON re-assignable
//recipeObject = {name : 'horsecrap'}; //NON re-assinable.

console.dir(func1);
func1(); //let function
//func1 = () => {}; //error . func1 is readonly

console.dir(func2);
func2(); //const function
//func2 = () => {} ; //error. func2 is readonly

console.log('-----------------------');

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

 UDM es6, es7. es8 xxxx
Arrow functions dont create their own this scope (by default).
they will use the this which was created by the outer scope.
(inner functions can still reference the data in the parent scope)

Note:- Arrow functions do not create a this obj. for the function prototype to reference. 
 So, Class.prototype.getInfo() will not have the same this as the function Class () {} had.

Author says, this is where the arrow function fails.
Hence, when we use the prototypes, always use an anonymous function

DONT use:
Class.prototype.getInfo = () => {
     ....
     //this is not available
 }

INSTEAD use:
Class.prototype.getInfo = function (){
     ....
     //this is NOW available
 }

---------------------------------------------------------------

Data Structures in ES6 

set:- stores unique values . add(), delete() and has()  (has returns boolean), size(for # of elemnts)

let a = new Set();
arr = [10, 20, 30]
let newSet = new Set(arr);

- u can add primitive values to objects

a.add(10);
a.add(20);
a.add ({x:20,y:30}) 
console.log(a, a.size, a.has(5));

.values returns an iterator object to get all values one by one. for this use the enhanced for-of loop

for (let item of newSet.values()){
   console.log(item);
}

map:= maps have keys and values
=each key is unique.
- similarity to objects.
- key can be anything , even functions ,

let a = new Map();
let key1 = 'k1';

a.set(key1, 'sdfsdfsfd');
console.log(a);

.has() , .get() method is available.

object can be made a key as well.
function can be made a key as well.

Convert an arr into a map:=
let newMap = new Map(arr);

if arr is an array of arrays, then it is better.

for (let [key, value] of newMap.values()){
   console.log(key, value);
}

Set iteration frequently occurs through the values() helper method.
Map iterate frequently occurs through the entries() helper method.

=====================================

closures in ES6

- remember the environment in which they were created
- can reference independent variables in that env.

- function factories can be created.
- enable private data

- closures using arrow functions, closures help us to build function factories
- callbacks using A.Fs.
- revealing module pattern using A.F.s
- Prototype pattern using A.F.s
- singleton using A.F.s


====================================

Generators
- break the typical "run to completion" model for functions
- generators can pause and resume in the middle. using yield-keyword and next() respectively
- they help us to construct controlled flow functions and iterators.

function* letterMaker(){
     yield 'a';
     yield 'b';
     yield 'c';     
}

let x = letterMaker();
console.log(x.next().value);
console.log(x.next().value);
console.log(x.next().value);
console.log(x.next().value); //undefined.

try .next() with a while().
 

Adding a reset functionality to a generator:-

.next() take a parameter which defines the state of the generator.
arguments is an inbuilt datastructure which captures everything passed to it.
so u can traverse arguments like this:

for (let arg of arguments){
    yield arg;
}

=OR=

yield* arguments ;
(so that u can skip the for-of loop)

We will see this later 




In this example, we can actually make use of an infinite while loop

function* evens(){
        let count = 0;
        while (true){
           count += 2;
           yield count;
        }
}

let sequence = evens();
console.log(sequence.next().value);
console.log(sequence.next().value);
console.log(sequence.next().value);
console.log(sequence.next(true).value);
console.log(sequence.next().value);

To add the reset functionality, we need to do 2 things:-
 - call .next(true)
- modify the above function like this:

function* evens(){
        let count = 0;
        while (true){
           count += 2;
         
        let reset = yield count;
        if (reset){
           count = 0;
        }
           

        }
}


Generators vs Iterators: v 80

Iterators: in any prog. lang. will access items from a collection / array one at a time.
And it keeps track of its position as it does so.

 Q. how to create a custom iterator in es6?
- create a function with module pattern and implement a next-function in the return section.

Q. how to convert an iterator into a generator?

<<<some screenshot>>>>

Q. Generators vs iterators vs iterables


===================================================

Promises

let p = new Promise((resolve, reject) => {
     //resolve();
     //reject();
     setTimeout(() =>{resolve('resolvvved promise data')}, 3000);
})

p.then (response => console.log(response))
  .catch (error => console.log(error));

console.log('--------------------')'; //this executes before the setTimeout.

http://jsonplaceholder.typicode.com

A promise has 3 states: pending, fulfilled and rejected.
Promise executor is the name of the anony function. 
===================================================

fetch method (to make GET HTTP calls).
- fetch is a new api in ES6

const root = 'http://jsonplaceholder.typicode.com/posts/1';

fetch(root, {method: "GET"})
.then(response => console.log(response))

NOTE :- in the console.log, we are interested in the json() section, so lets see how to get that.

fetch(root, {method: "GET"})
.then(response => response.json())
.then (json => console.log(json)); 

 //https://www.googleapis.com/books/v1/volumes?q=isbn:0747532699




===================================================

Resolve API
-
-

===================================================

ES7: (ES2016)
- math operator
- more array functions. 


npm install babel-preset-es2016 --save-dev
      once done, make sure package.json has "es2016" as one of the pre-sets

eg.1.power operator
es6:-
let a = Math.pow(2,5);
console.log(a); //32

es7:-
let a = 2**5;

eg.2.  

es5:-  String includes
let b = "wonderful".includes("wonder");
console.log(b); //true.

In es7, we can use array .includes() 
let b = [10, 20, 30, 40].includes(40);
console.log(b);


==================================================

ES8

- More object manipulate with .values() and .entries()
- Async Functions

npm install babel-preset-es2017 --save-dev

eg.1.
.keys() in es6:
let obj = { a: 'one', b: 'two', c: 'three'};
let keys = Object.keys(obj);
console.log(keys);

in es8, we have .values() and .entries()
let obj = { a: 'one', b: 'two', c: 'three'};

let values = Object.values(obj);
console.log(values);

let entries = Object.entries(obj);
console.log(entries); //returns an array of arrays with each key-value pair as an array

https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/entries

for (let entry of entries) {
    console.log(`key is: ${entry[0]}, value is : ${entry[1]}`);
}

---- 

I think, in es6, we have Array.Prototype.entries(), but to make it work, u have to use a for-of loop:
- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/entries?v=control 
- for-of loop was introduced in ES6, and to use it u require a pre-requisite of Symbol.iterator(). (as a key i think, i.e. ur data structure should be iterable, i think. not sure. RND when u have time)

----

es8 proposal : Promise Async functions

async function async_one(){
   return "one";
}

async function async_two(){
  // throw new Error ('Issue with async!');
  return "two";
}

//combining 2 promises/async functions using "await". (USE JUDICIOUSLY)
//await-keyword: wait for a resolved value before continuing to execute code

async function async_three(){
   const one = await async_one(); //await no matter how long this may take to resolve
   console.log(one);
   const two = await async_two();
   console.log(two);
}


async function async_four (){
    const [res_one, res_two] = await Promise.all(  [async_one(), async_two()]  );
    console.log(res_one, res_two);
}


async_one().then(response => console.log(response));
//async_two().catch(error => console.log(error));

async_three();
async_four(); 

++++++++++++++++++++++++++++++++++++++++++++++++ 


 ES6 consolidated
es6_2:-

Template literals: ``       
let a = `good`;
let b = `${a} morning`;
console.log(b);
See how the interpolation is done using ${a}

---

Pre-requisite:- get ur environment working using babel and webpack !

index.js
eg.1 re
console.log("hellow world from webpack ! Welcome to the matrix neo !!!");

let fname = 'sachin';
//let comment = fname + 'is a great guy';
//let comment = `is a great guy`; //multiline backticks

/*
let comment = `is a
 great
 guy`;
*/

//template literals
//let comment = ` ${fname} is a great guy`;
let comment = ` ${fname + " Tendulkar"} is a great guy`;
console.log (comment);
NOTE: how the variable and string are concatenated; its not necessary but its possible.

eg. 1.2.
let fnames = ['sachin', 'ramesh'];
let comment = ` ${fnames + " Tendulkar"} is a great guy`; //works fine. all array contents are displayed
console.log (comment);
let comment = ` ${fnames[0] + " Tendulkar"} is a great guy`; //only 1st element is interpolated.
console.log(comment);

//eg.1.3.
let names = {
    fname1: 'sachin',
    fname2: 'manjrekar'
};

let comment = ` ${names['fname1'] + " Tendulkar"} is a great guy`; //works fine . only 1st value in object is interpolated.
console.log (comment);

let comment = ` ${names + " Tendulkar"} is a great guy`; //[object object] Tendulkar is a great guy
console.log (comment);

//eg.1.4.
let boolVal = true;
let comment = ` ${boolVal + " Tendulkar"} is a great guy`;
console.log (comment);

---

Arrow functions (using var is ES5, let/const is ES6)


eg.2. Arrow functions
//eg.2. function declaration (named function)
function sayHello(){
  console.log ('Plz say hello');
}
sayHello();

//function expression
var sayHello = function(){
  console.log ('sayHello as function expression');
};
sayHello();

//single line: arrow function
var sayHello = () => console.log('sayHello as arrow function') ;
sayHello();

//multiline arrow function
var sayHello = () => {
  var a = 1;
  var b = 2;
  console.log ('multiline arrow function')
  return a + b;
}
sayHello();

//arrow function with parameters
var calc = (x, y) => {
  console.log ('arrow function with multiple params', x + y);
  return x+y;
}
calc(1, 2);
//arrow function with single param
var calc = (x) => {
  console.log('arrow function with single param: ' + x);
};
calc(10);

//arrow function with single param and single line and single line is a return statement.
//remove return keyword

var calc = ((n) => n * 2); //valid. Note: no return keyword. Preferred.
//var calc = (n) => n * 2; //valid. Same as above. no return keyword
//var calc = ((n) => n * 2;); //INVALID. No semicolon on the line of return. VIMP.
console.log(calc(10));
//NOTE: var keyword from ES5 allows for re-creation and re-assignment of an existing variable
//Es6 does not have a var keyword, instead it has let. and let does not allow in re-creation and re-assignment
//const are immutable .

---

NOTE:- this section is only for stupid people who want to write ES5 OOP using ES6 arrow functions.

Q. Can ES6 classes (using class use ".prototype") ??

We need to understand how arrow functions can be used in: closures, callbacks, OOPS (like ES5) , promises
in OOPS (ES5) we have to understand how to use it in:-
1. Constructor pattern
2. Factory pattern
3. Dynamic prototype pattern .
    - Arrow functions dont have their own this. (by default)
    - they get the this from outside/parent. So, while using prototypes make sure to use function() instead of arrow functions.    
4. module pattern
5. revealing module pattern

3. Dynamic prototype pattern
    Arrow functions dont create their own this scope (by default).
    they will use the this which was created by the outer scope.
    (inner functions can still reference the data in the parent scope)
    Note:- Arrow functions do not create a this obj. for the function prototype to reference.
     So, Class.prototype.getInfo() will not have the same this as the function Class () {} had.
    Author says, this is where the arrow function fails.
    Hence, when we use the prototypes, always use an anonymous function

    DONT use:
Class.prototype.getInfo = () => {
     ....
     //this is not available
 }

    INSTEAD use:
Class.prototype.getInfo = function (){    //only this way will the new method have access  to the this-object in the constructor()
     ....
     //this is NOW available
 }

NOTE:- Same is true with ES6 style(using classes):-

 class Animal{
          constructor(name, height){
            this.name = name;
            this.height = height;
          }

          hello(){
            console.log('say hello');
          }
        } //Animal class ends

        Animal.prototype.roar = function () {
          console.log(`${this.name} is roaring`);
        };

        /* WONT WORK
        Animal.prototype.roar = () => {
          console.log(`${this.name} is roaring`); //name is undefined.
        };
        */
       
    The above is an example of when NOT TO USE arrow functions.   
---
    Lets c an example of when to use a.f.s
   
    Problem:-
        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){
              return this.members.map(function(x){
                return `${x} is a member of ${this.org}`; //croaks. cannot find property 'org' on undefined.
              });
          } //func ends.
        }; //obj ends.

        console.log(team.teamSummary());

Solution 1:- (old-school)
        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){
            let self = this;    //<<==
              return this.members.map(function(x){
                console.log(self);
                return `${x} is a member of ${self.org}`;    //<<==
              });
          }
        };

        console.log(team.teamSummary());
O/p:-       
["Hitman is a member of assassins", "XXX is a member of assassins", "James bond is a member of assassins"]

Solution 2: using fat arrow functions.
        - this is because a.f. do not have their own this-scope. it uses the this from its immediate-parent.

        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){ //we have this here
              return this.members.map((x) => {
                return `${x} is a member of ${this.org}`; //A.f. do not have this. uses this from above.
              });
          }
        };

        console.log(team.teamSummary());


O/p:-
["Hitman is a member of assassins", "XXX is a member of assassins", "James bond is a member of assassins"]

---
Default Arguments:-


---
Q. Can you write IIFE with arrow functions? YES!!!

//eg.1 IIFE without params
//IIFE in es5
(function () {
   console.log('xxxx');
})();

//IIFE in es6
(() => {
   console.log('yyyy');
})();


//eg.2 IIFE with params
//IIFE in es5
(function (a, b) {
   console.log('xxxx', a + b);
})(10, 20);

//IIFE in es6
((a, b) => {
   console.log('yyyy', a+b);
})(30, 40);

Q. Write singleton class (using IIFE) in ES6 ;
A. Find the plunk.

Another plunk showing use of IIFE.
http://plnkr.co/edit/l5cvXhcEreuSRdCZhquv?p=info

//ES5

(function(){
var createworker = function(){
  var task1 = function(){
    console.log('task1');
  };

  var task2 = function(){
    console.log('task2');
  };

  return {
    d1: task1,
    d2: task2
        };
};

var worker = createworker();
worker.d1();
worker.d2();

}());         //})() is allowed too.


//ES6

(() => {
 let createworker = () => {
    let task1 = () => {
      console.log('task1');
    };

    let task2 = () => {
      console.log('task2');
    };

    return {
      d1: task1,
      d2: task2
          };
}; //createworker ends.

  var worker = createworker();
  worker.d1();
  worker.d2();

})();

---

closures in ES6 :- (skipped)
Closures in general:-
    - remember the environment in which they were created
    - can reference independent variables in that env.
    - function factories can be created.
    - enable private data

- closures using arrow functions, closures help us to build function factories
- callbacks using A.Fs.
- singleton using A.F.s

---

eg. 3 let n const
- block scope,
- let is mutable and const is immutable (with exceptions)
    -- ONLY for objects, const allows modification, but not re-assignment

- function expressions: let and const.
f.exs. with const cannot be re-defined, but f.exs. with let can be re-defined.

let func1 = () => {};
//console.dir(func1);
func1 = () => {
  console.log('func1: overriding above function expression');
};
console.log(func1());
const func2 = () => {};

/* This croaks
func2 = () => {
  console.log('func2: overriding above function expresssion');
};
*/

console.log(func2());
//console.dir(func2);

---

eg.4 const and its gotchas with objects.
//eg. 4.1 . number . immutable.
const length = 10;

//length = 20; //NOT Allowed. immutable.
console.log('length is ' + length);

//eg. 4.2 . string . immutable.
const tenLength = 'ten';
//tenLength = 'twenty'; //NOT Allowed. immutable.
console.log('tenLength is ' + tenLength);

//eg. 4.3 boolean. immutable.
const someFlag = true;
//someFlag = false; // NOT Allowed. Immutable
console.log(someFlag);
//eg. 4.4

/*
For objects, complete re-assignment is NOT allowed.
However, existing set of values can be modified/pushed/popped, etc.
*/

//objects
const o = {}; //deviation: const on objects are modifiable
o['one'] = 1;
o['two'] = 2;
//o = {'villian': 'joker'}; //re-assignment is not possible
console.log(o);
let newO = JSON.parse(JSON.stringify(o)); //creating a new copy.
newO['two'] = 'T.W.O.';
console.log (newO);
console.log('-----------');

//arrays
const a = []; // deviation: const on objs (array is an object) are modifiable
a[0] = 10; //pushing is possible
console.log(a);
a.push(20); a.unshift(0);
console.log(a); //pushing & unshifting is possible
a.pop(); a.shift(); //popping & shifting is possible
console.log(a);
//a = [10, 20, 30]; //re-assigning is not possible

let newA = a.slice();
console.log('newA is: ' + newA); //possible

---
eg.5.
Spread operator:- ...

5A) Spreading on arrays
eg.5.1. //simple spreading
let a = [10, 20, 30];
let b = [0, ...a, 40];
console.log(b); //0, 10, 20, 30, 40

eg.5.2.
let a = [10, 20, 30];

function add (...x){
  console.log(a); //10, 20, 30. original
  console.log(x); //10, 20, 30. a new copy
  x[0] = 0;
  console.log(a); //10, 20, 30. orig is as is .
  console.log(x); //0, 20, 30
}
add(...a);


eg.5.3. //local copy by same name (as global)
let a = [10, 20, 30];

function add (...a){ //local copy
  console.log(a); //10, 20, 30. copy created by same name
  a[0] = 0;
  console.log(a); //0, 20, 30. copy is modified.
}

add(...a);
console.log('--------');
console.log(a); //10, 20, 30. orig global array is as is.


eg.5.4. //avoiding local copies will updated globals
let a = [10, 20, 30];

function add (){ //no param to create a local copy
  console.log(a); //10, 20, 30. reference to global array
  a[0] = 0;
  console.log(a); //0, 20, 30. orig is modified.
}

add(...a);
console.log('--------');
console.log(a); // 0, 20, 30 . orig is modified.

eg.5.5 VIMP //passing more than one spread-array will result in pass by reference and not pass by value.
//Only if 1 spread is passed will it be pass by value

    let a1 = [10, 20, 30];
    let a2 = [101, 201, 301];

    //let add = (...x1) => {
    let add = (...x1, ...x2) => { //pass by reference
      x1[0] = 0; //updates a1[0] as well
       console.log(x1);
       console.log(x2);
    };

    add(...a1, ...a2);
    console.log('----------');
    console.log(a1); //0, 20, 30
    console.log(a2);

eg. 5.6
    //for PDT, PDT, spread op. copy is created is 3rd param is mentioned in function definition

    let var1 = 'var1';
    let var2 = 'var2';

    let arr1 = [1, 2, 3];

    //let append = (v1, v2, a1) => { //a1 is pass by reference; orig will be modified.
    let append = (v1, v2, ...a1) => { //a1 is now a copy
        console.log(v1, v2, a1);
        a1[0] = 0;
        console.log(v1, v2, a1);
    };

    //append(var1, var2, arr1); //arr1 is pass by ref. which we already know
    append(var1, var2, ...arr1); //arr1 is pass by value
    console.log(var1, var2, arr1); //var1, var2, [0, 2,3]

eg. 5.7

    let arr1 = [1, 2, 3];
    let arr2 = [11, 21, 31];

    //let append = (...a1, ...a2) => { //error. this is NOT allowed
    let append = (...a1) => { //allowed. a1 now is a copy
                              //a1 now is arr1 + arr2
        console.log(a1);
    };

    append(...arr1, ...arr2);
    console.log('-------------');
    console.log(arr1, arr2);
           
NOTE:-    
1. PDT, PDT, spread op. (in func def n func call ) : works
2. PDT, PDT, spread op., PDT (in func def n func call ) : error. last PDT will not work
3. spread op, spread op (call) //allowed
   spread op( func def) //allowed. see 5.7 //spread op, spread op is NOT ALLOWED in func def

---

5B)Spreading on objects (DONT USE). Just RnD
(lets use arrow functions too, not that it matters).
we are focusing on spread operators.

eg. 5.b.1 //no local param

    let a = {'name': 'jack bauer'};

    let add = () => { //no local param
      console.log(a['name']); //Jack Bauer. //reference to global variable
      a['name'] = 'Ethan Hunt'; //modifying existing value
      console.log(a['name']); //Ethan Hunt
    };

    add(...a);
      console.log(a['name']); //Ethan Hunt

eg. 5.b.2
    //if u want to choose a local param, then that wont work with objects
    let a = {'name': 'jack bauer', 'name2': 'johnny english' };

    let add = (...x) => { //a local copy is NOT created; instead x remains undefined
      console.log(x);
    };

    add(...a);

eg. 5.b.3
  let obj1 = {name1: 'jack bauer'};
  let obj2 = {name2: 'xxx',
                  stats:{ successratio: '9/10', failration: '1/10'}
             }; //works for obj of objs. , arr of objs.
  let obj3 = {...obj1, name3: 'ethan hunt', ...obj2};
  console.log(obj3); //works

eg. 5.b.4.
//let obj1 = {name1: 'jack bauer', name1: 'batman'};
  //Duplicate "name1" keys are not allowed in strict mode.
  let obj1 = {name1: 'jack bauer'};
  let obj2 = {name2: 'xxx',
                  stats:{ successratio: '9/10', failration: '1/10'}
             }; //works for obj of objs. , arr of objs.
       //let obj3 = {...obj1, name3: 'ethan hunt', ...obj2}; //orig commented
      //no error., but duplicate removed, latest value is preserved
      //1. let obj3 = {...obj1, name1: 'ethan hunt', ...obj2};
        //only name1: ethan hunt. NO duplicate name1
        //only one unique & latest entry for "name1" key is ALLOWED.
        //ethan hunt is latest "name1" is preserved.
      //2. if order of injection is changed, jack bauer is preserved
      let obj3 = { name1: 'ethan hunt',...obj1, ...obj2};  //only name1: jack bauer
        console.log(obj3);

---
Rest parameter : (in above examples, whereever in func def, we are using ...a1 parameter, those are rest parameters

eg.
    function (...a){
    c.log(a);
    }
    a(1,2,3,4,5);

---
6) Destructing assignment
Previously in ES5,
    let z = [4,5,6];
    let four = z[0];
    let five = z[1];
    console.log(four, five)


6A) Destructing Assignment(Arrays)
eg. 6.1.
    let arr1 = [10, 20, 30];
    //let x, y = arr1; //x is undefined and y = arr1
    let [x,y] = arr1; //x is 10, y is 20.
    console.log(x,y);


eg. 6.2

    let arr2 = [1, 2, 3];
    let arr1 = [10, 20, 30, ...arr2];
    //let x, y = arr1; //x is undefined and y = arr1
    let [x,y,z,xxx] = arr1; //x is 10, y is 20, z is 30, xxx is 1.
    console.log(x,y,z,xxx);

6B) Destructing Assignment (Objects)
    //objects: in ES5 we used to do this:
    let king = { name: 'mufasa', kids : 1};
    let name = king.name;
    let kids = king.kids;
    console.log(name, kids);

eg. 6.b.1.
    let king = { name: 'mufasa', kids : 1};

    let {name, kids} = king; //note the curlies on LHS
    console.log(name, kids);   
   

Note:- we cannot write like this:=
    let name, kids;
    {name, kids} = king;    //WONT work.
//if u wanna make this work, then do this:-
    ({name, kids} = king); //note the round braces.
   
---

http://plnkr.co/edit/T8yGp5pqqlufUcU7gCQP?p=info
plnkr showing traceur embedded in plnkr

---   

Classes in detail:-
- Classes are no longer functions in ES6, ES5 had constructor functions; but not in ES6

eg. 7.1
    class Person { // Note : it is NOT Person (){ in ES6 . Remove (). Thats wrong. This is not ES5.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }
    } //Person ends

    let p1 = new Person ('Jack Bauer', 40, 'New York');
    console.dir (p1);

eg. 7.2
    class Person { // No Person (){ in ES6 . Thats wrong.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }

       //See how the wakeUp() is written. its NOT using arrow functions
       wakeUp(){
         console.log('wake up Jack, POTUS is in danger');
       }

       //Cannot use arrow functions
       /*
       let findTheCriminal = () => {
         console.log('Times against us Jack, find the criminals behind these');
       };
       */

       findTheCriminal(){
       console.log('Times against us Jack, find the criminals behind these');
       };
      
       /* Cannot use IIFE within a class.
       //IIFE within a class
           //(() => {
             sleepWithLoadedGun(){
                  console.log('Jack Bauer has a loaded gun under his pillow');
                }
            // })();

       */
      
        //static-keywords
        //static methods can be called directly by the Class name. they dont require an object instantiation to be called.
        //p1.sleepWithLoadedGun(); //WRONG. Croaks
        //Person.sleepWithLoadedGun(); //Right method signature
       
        static sleepWithLoadedGun(){
            console.log('STATIC: Jack Bauer has a loaded gun under his pillow');
        }

        //constructor properties are accessible in other functions.
        whoami(){
            console.log(this.name, this.age, this.city);
        }

    } //Person ends

    let p1 = new Person ('Jack Bauer', 40, 'New York');
    console.dir (p1);.
    Person.sleepWithLoadedGun();
    p1.wakeUp(); p1.findTheCriminal();

    p1.whoami(); //prints jack bauer, 40, New York

eg. 7.3

    class Person { // No Person (){ in ES6 . Thats wrong.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }
    } //Person ends

    class Assassin extends Person {
      constructor(id, weapon){
        super(Person); //gets properties from the Person class

        this.id = id;
        this.weapon = weapon;
      }
    } //Assassin ends

    let p1 = new Person ('Johnny English', 35, 'Liverpool');
    console.dir(p1);

    let p2 = new Assassin('007', 'Baretta');
    p2.name = 'James';
    console.dir(p2); //age and city are undefined. Plz note this.

eg. 7.4
// multiple inheritance in ES6 is frowned upon.
    use npm's mixins library: https://medium.com/@leocavalcante/es6-multiple-inheritance-73a3c66d2b6b
D:\js\es6>npm install mixins --save-dev

// method overloading
// operator overloading
// method overriding

eg. 7.5
eg. 7.6
eg. 7.7 

D:\js\es6\node_modules\webpack\bin>node webpack.js -v
2.5.1
   
---

8) https://stephengrider.github.io/JSPlaygrounds
Lodash/Underscore helper methods now implemented as Array methods in ES6:-
- helps u greatly when working with collections of data.

ARRAY helper methods:-
- forEach, map, filter, find, every, some, reduce

Pre-requisite: understand of collections i.e. array of objects && how to access their individual elements (without any helper methods).
This is basic stuff

    Basic(1)
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
    ] ;

    console.log(assassins[0].name, assassins[0].age );            //works.
    console.log(assassins[0]['name'], assassins[0]['age'] );    //same as above.

    ----
   
    Basic(2) : function as a property . This will be important to understand iterables when we get there.
   
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {getKey: 'XXX', organization: 'IMF', age: 41} //notice this !!! we are NOT using getKey() with (). Simply getKey.
    ] ;

    let getKey = () => 'name';
    //console.log(getKey()); //works

    console.log(assassins[4].getKey, assassins[4].age );        //XXX, 41. works
    console.log(assassins[4]['getKey'], assassins[4]['age'] );  //XXX, 41. works

    ---
   
    Basic(3): function --> called by an obj ---> collection using the prev. obj (value)
   
    let getKey = () => 'name';

    //creating an obj. 1
    let obj = {
      getKey: 'Hitman', age: 22
    }

    //getting obj into assassins.
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {getKey: 'XXX', organization: 'IMF', age: 41}, //notice this !!! we are NOT using getKey() with (). Simply getKey.
      {getKey: obj['getKey']}      //Q. how can LHS be derived from obj.key??
    ] ;

    //console.log(assassins[4].getKey, assassins[4].age );
    //console.log(assassins[4]['getKey'], assassins[4]['age'] );
   
    console.log(assassins[5].getKey); //Hitman

8.1) forEach
eg. 8.1.1

var colors = ['blue', 'blanc', 'rouge', 'red'];

colors.forEach(function(x){
  console.log(x);
});

eg. 8.1.2
//here the function is called the iterator function. it runs one time for each of the element.
//the iterator function can be decoupled and kept separate as well

let iteratorFunc = (x) => {
  console.log(x);
};
colors.forEach(iteratorFunc);

---

8.2) map

eg. 8.2.1
var nums = [10, 20, 30];
var doubledNums = nums.map(function(x){
  return x*2; //very imp. line
});
console.log(doubledNums);

eg. 8.2.2 //using fat arrow

let nums = [10, 20, 30];

let multiplier = x => x*3;

let doubledNums = nums.map(multiplier);
console.log(doubledNums);

---
8.3) filter
eg.8.3.1
let assassins = [
  {name: 'Ethan Hunt', organization: 'IMF', age: 50},
  {name: 'James Bond', organization: 'Mi6', age: 49},
  {name: 'Money Penny', organization: 'Mi6', age: 28},
  {name: 'Benji', organization: 'IMF', age: 30},
] ;

let people = assassins.filter(function(item){
  return item.organization === 'IMF'; //Vimp return is necessary. this is a truthy exp.
  //return item.organization === 'IMF' && item.age > 30;
});
console.log(people);


eg. 8.3.2 //using fat arrow
let assassins = [
  {name: 'Ethan Hunt', organization: 'IMF', age: 50},
  {name: 'James Bond', organization: 'Mi6', age: 49},
  {name: 'Money Penny', organization: 'Mi6', age: 28},
  {name: 'Benji', organization: 'IMF', age: 30},
] ;

let finder = (item) => item.organization === 'Mi6' && item.age > 30; 
let people = assassins.filter(finder);

console.log(people);

---

eg. 8.4 find == returns only 1st record/object found . This is how it is different from filter.

    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {name: 'Benji', organization: 'IMF', age: 29}
    ] ;

    let finder = (item) => item.name === 'Benji';
    let found_assassings = assassins.find(finder); //returns only first element found
    console.log(found_assassings);
   
---

eg. 8.5 every  & some : returns a boolean value.
        every: returns true, if every element matches the condition. else false.
        some: returns true, if some elements match the condition. else false.
       
        this is how they r different from filter. (filter doesnt give the boolean ; it returns the matched list objects.
       
        let assassins = [
          {name: 'Ethan Hunt', organization: 'IMF', age: 50},
          {name: 'James Bond', organization: 'Mi6', age: 49},
          {name: 'Money Penny', organization: 'Mi6', age: 28},
          {name: 'Benji', organization: 'IMF', age: 30},
          {name: 'Benji', organization: 'IMF', age: 29}
        ] ;

        let everyFunc = (item) => item.age < 30 ;

        let found_assassins = assassins.some(everyFunc);
        //let found_assassins = assassins.every(everyFunc);
       
        console.log(found_assassins);

---       
       
eg. 8.6 reduce
        - toughest to understand, people think it is only for summing.
        - requires an array object to work with .
       
        eg. 8.6.1
       
        let numbers = [10, 20, 30];
        //let sum = 0;

        let x = numbers.reduce (function(total, item){ //total is any tmp local var. into which we will keep on adding
          console.log (total, item, total + item);
          return total + item;
        }, 2);
        //2 is initial value and is optional.
        //if 2, 2+10 = 12, 12+20 = 32, 32+30 = 62. 3 iterations.
        //if 1, 1+10 = 11, 11+20 = 31, 31+30 = 61. 3 iterations.
        //if 0, 0+10 = 10, 10+20 = 30, 30+30 = 60. 3 iterations.
        //if not mentioned, then, 10+20 = 30, 30+30 = 60. 2 iterations.

        console.log(x);
       
        eg. 8.6.2
       
        //the first param of reduce is tricky to name.
            - u can call it total if summing
            - u can call it previous/acc , acc meaning accumulator , because it accumulates.
        //optional initial value is the next tricky part.
            - sometimes it maybe required, other times not.
            - u can keep it as [], in which case the previous-var/acc-var will be an array.   
           
        let colors = [
          {color: 'red'},
          {color: 'blue'},
          {color: 'green'}
        ];

        let x = colors.reduce (function(prev, primaryColor){
           prev.push(primaryColor.color);
           return prev; //vimp.
        }, []);

        console.log(x);

----
Reducing on objects

https://stackoverflow.com/questions/15748656/javascript-reduce-on-object

var o = { 
    a: {value:1}, 
    b: {value:2}, 
    c: {value:3} 
};

Object.keys(o).reduce(function (previous, key) {
    return previous + o[key].value;
}, 0);

 

---

Mastering reduce function. 

 

NOTE: if default value is NOT given, then accumulator becomes previous value. VIMP!!! 

 

---

eg. 

we r trying to delete the obj assigned to 123123 and other ids.

 

Attempt1:-

 let myObject= {
 123123: { id: 123123, text: 'hello world!', status: 'active' },
 456789: { id: 456789, text: 'hello there', status: 'active' } 
}

//console.log (myObject['123123']['id']);

let x = Object.keys(myObject).reduce(function(acc, item){
  console.log(item);
}, ''); 


O/p:-
"123123" "456789"

 Attempt 2:-


let myObject= {
 123123: { id: 123123, text: 'hello world!', status: 'active' },
 456789: { id: 456789, text: 'hello there', status: 'active' }
}

//console.log (myObject['123123']['id']);

let x = Object.keys(myObject).reduce(function(acc, item){
  //console.log(item, myObject[item]);
  delete myObject[item];  
  //console.log(item, myObject[item]);
  //console.log(isEmpty(myObject[item]));
  myObject[item] = isEmpty(myObject[item]);
  console.log(item, myObject[item]);
  return acc;
}, '');

//console.log(x);


function isEmpty(val1){
  return (val1 === undefined);
}

O/p:-

123123 true,
456789 true

https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&debug=false&code=%0A%0Alet myObject%3D {%0A 123123%3A { id%3A 123123%2C text%3A 'hello world!'%2C status%3A 'active' }%2C%0A 456789%3A { id%3A 456789%2C text%3A 'hello there'%2C status%3A 'active' } %0A}%0A%0A%2F%2Fconsole.log (myObject['123123']['id'])%3B%0A%0Alet x %3D Object.keys(myObject).reduce(function(acc%2C item){%0A %2F%2Fconsole.log(item%2C myObject[item])%3B%0A delete myObject[item]%3B %0A %2F%2Fconsole.log(item%2C myObject[item])%3B%0A %2F%2Fconsole.log(isEmpty(myObject[item]))%3B%0A myObject[item] %3D isEmpty(myObject[item])%3B%0A console.log(item%2C myObject[item])%3B%0A return acc%3B%0A}%2C '')%3B%0A%0A%2F%2Fconsole.log(x)%3B%0A%0A%0Afunction isEmpty(val1){%0A return (val1 %3D%3D%3D undefined)%3B%0A}%0A%0A

---    
        eg. 8.6.3
        //balanced parantheses function . eg. "()()()()", "(((())))",
        //unbalanced:- ")("   
       
        //let input = `((()))(`;
        let input = `)(`;
        let arrInput = input.split(''); //convert into an array.
        console.log(arrInput, Array.isArray(arrInput) );

        let x = arrInput.reduce(function(prev, item){
           if (prev < 0) { return prev }

           if (item === '('){
              ++prev;
           }
           else{
             --prev;
           }
           return prev;
        },0);

        console.log(x);
        (!x) ? console.log('Balanced string') : console.log('Unbalanced string') ;

---
MORE EXPLANATION ON REDUCE: plz read . VIMP!!!
reduce function executed in ts-env

eg.1. without initialization, without newval
a1.reduce((previousval)=>{
  // console.log(previousval); //josh's record x 2 times //if no initial value.
  console.log(previousval);
  return previousval;
}); <<<======== NO INITIALISATION

---
eg.2. without initialization, with newval
//a1 same as in eg.1

a1.reduce((previousval, newval)=>{
  console.log(previousval, newval);
  //josh's record + js's
  //josh's record + sarah's
  return previousval;
}); <<<======== NO INITIALISATION
 
// Chrome 58.0.3029 (Windows 8 0.0.0): Executed 3 of 13 (skipped 10) SUCCESS (0.056 secs / 0.008 secs)
// Chrome 58.0.3029 (Windows 8 0.0.0) LOG: Object{age: 10, name: 'josh'}, Object{age: 18, name: 'js'}
// Chrome 58.0.3029 (Windows 8 0.0.0) LOG: Object{age: 10, name: 'josh'}, Object{age: 18, name: 'js'}

// Chrome 58.0.3029 (Windows 8 0.0.0) LOG: Object{age: 10, name: 'josh'}, Object{age: 18, name: 'sarah'}
// Chrome 58.0.3029 (Windows 8 0.0.0) LOG: Object{age: 10, name: 'josh'}, Object{age: 18, name: 'sarah'}
// Chrome 58.0.3029 (Windows 8 0.0.0): Executed 3 of 13 (skipped 10) SUCCESS (0.104 secs / 0.054 secs)

---
eg. 3. with initialization, with newval
//a1 same as in eg.1

a1.reduce((previousval, newval)=>{
  console.log(previousval, newval);
  return previousval;
},''); <<<======== YES! INITIALISATION

All values are now found only in newval.
previousval can now be used as an accumulator

Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 10, name: 'josh'}
Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 10, name: 'josh'}
Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 18, name: 'js'}
Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 18, name: 'js'}

Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 18, name: 'sarah'}
Chrome 58.0.3029 (Windows 8 0.0.0) LOG: '', Object{age: 18, name: 'sarah'}

---

eg.4. this is what is happening actually:
accumulator, currentvalue, currentindex, orig_whole_arr.

a1.reduce((acc, newval, index, orig_arr)=>{
  //console.log(acc, newval, index, orig_arr); //works
  //console.log(acc, newval, index); //works
  return acc;    <<<=========YES! acc should be returned. CROAKS if u put newval !!!
},''); <<<======== YES! INITIALISATION

---

eg. 5.
reduce as a .filter() from es6 :-

let arrs = [];
a1.reduce((acc, current_val, index, orig_arr)=>{
  if(current_val.age > 15){
      arrs.push(current_val);
  }
  return acc;
},'');
console.log(arrs); // [Object{age: 18, name: 'js'}, Object{age: 18, name: 'sarah'}]

NOTE:- reduce CANNOT be used a .find() from es6
 - bcoz, u CANNOT exit reduce prematurely

let arrs = [];
a1.reduce((acc, current_val, index, orig_arr)=>{
  if(current_val.age > 15){
      arrs.push(current_val);
      //return; //DOES NOT WORK does not short-circuit.
      //acc = false; // DOES NOT WORK
      //NOTE: There is no way, of course, to get the built-in version of reduce to exit prematurely.
  }
  return acc;
},'');
console.log(arrs);
































9) Destructuring:-

    eg. 9.1.

    let obj = {
      name: 'James Bond',
      org : 'mi6'
    };

    //without destructuring -- LHS can be any variable name
    //let agent_name = obj.name;
    //let agent_org = obj.org;

    //with destructuring.
    //Sol.1.:-
    //{} is syntax for destructuring. We are NOT creating an object here.
    //LHS var name has to match the property name in the obj.
    //RHS only has the obj name
    //let { name } = obj;
    //let { org } = obj;

    //Sol.2. :-
    let {name, org} = obj;
    console.log(name, org);

NOTE:- if u destruct with a property that does NOT exist, then it WONT croak, it will give "undefined"

    let {name, org, joker} = obj;
    console.log(name, org, joker); // , , undefined

    eg. 9.1.2
       
    //destructuing in functions
    //previously
    /*
    let printSome = function(objItem){
      return `${objItem.name} is in ${objItem.org}` ;
    };
    */

    //sol1:- single obj param
    /*
    let printSome = function({name, org}){
      return `${name} is in ${org}` ;
    };
    */ //james bond is in mi6

    //Sol2: multiple obj params
    let printSome = function({name, org}, {weapon}){
      return `${name} is in ${org} and uses a ${weapon}` ;
    };
    //2 params in call
    console.log(printSome(obj, { weapon:'sniper' }
                         ));
    //james bond is in mi6 and uses a sniper                     

---























---
Reflect API

https://ponyfoo.com/articles/es6-reflection-in-depth
    https://ponyfoo.com/articles/es6-proxies-in-depth
    https://ponyfoo.com/articles/es6-proxy-traps-in-depth
    https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth

https://ponyfoo.com/articles/cross-tab-communication
https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth

https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/
https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/

    The new APIs in ES6 come in three flavours: Symbol, Reflect, and Proxy. Upon first glance this might be a little confusing - three separate APIs all for metaprogramming? But it actually makes a lot of sense when you see how each one is split:

    Symbols are all about Reflection within implementation - you sprinkle them on your existing classes and objects to change the behaviour.
    Reflect is all about Reflection through introspection - used to discover very low level information about your code.
    Proxy is all about Reflection through intercession - wrapping objects and intercepting their behaviours through traps.

---

http://qnimate.com/difference-between-set-and-weakset-in-javascript/

~~~~~~~~~~~~~~~~~~~~~~~~~~


es6_2:-

Template literals: ``      
let a = `good`;
let b = `${a} morning`;
console.log(b);
See how the interpolation is done using ${a}

---

Pre-requisite:- get ur environment working using babel and webpack !

index.js
eg.1 
console.log("hellow world from webpack ! Welcome to the matrix neo !!!");

let fname = 'sachin';
//let comment = fname + 'is a great guy';
//let comment = `is a great guy`; //multiline backticks

/*
let comment = `is a
 great
 guy`;
*/

//template literals
//let comment = ` ${fname} is a great guy`;
let comment = ` ${fname + " Tendulkar"} is a great guy`;
console.log (comment);
NOTE: how the variable and string are concatenated; its not necessary but its possible.

eg. 1.2.
let fnames = ['sachin', 'ramesh'];
let comment = ` ${fnames + " Tendulkar"} is a great guy`; //works fine. all array contents are displayed
console.log (comment);
let comment = ` ${fnames[0] + " Tendulkar"} is a great guy`; //only 1st element is interpolated.
console.log(comment);

//eg.1.3.
let names = {
    fname1: 'sachin',
    fname2: 'manjrekar'
};

let comment = ` ${names['fname1'] + " Tendulkar"} is a great guy`; //works fine . only 1st value in object is interpolated.
console.log (comment);

let comment = ` ${names + " Tendulkar"} is a great guy`; //[object object] Tendulkar is a great guy
console.log (comment);

//eg.1.4.
let boolVal = true;
let comment = ` ${boolVal + " Tendulkar"} is a great guy`;
console.log (comment);

---

Arrow functions (using var is ES5, let/const is ES6)


eg.2. Arrow functions
//eg.2. function declaration (named function)
function sayHello(){
  console.log ('Plz say hello');
}
sayHello();

//function expression
var sayHello = function(){
  console.log ('sayHello as function expression');
};
sayHello();

//single line: arrow function
var sayHello = () => console.log('sayHello as arrow function') ;
sayHello();

//multiline arrow function
var sayHello = () => {
  var a = 1;
  var b = 2;
  console.log ('multiline arrow function')
  return a + b;
}
sayHello();

//arrow function with parameters
var calc = (x, y) => {
  console.log ('arrow function with multiple params', x + y);
  return x+y;
}
calc(1, 2);
//arrow function with single param
var calc = (x) => {
  console.log('arrow function with single param: ' + x);
};
calc(10);

//arrow function with single param and single line and single line is a return statement.
//remove return keyword

var calc = ((n) => n * 2); //valid. Note: no return keyword. Preferred.
//var calc = (n) => n * 2; //valid. Same as above. no return keyword
//var calc = ((n) => n * 2;); //INVALID. No semicolon on the line of return. VIMP.
console.log(calc(10));
//NOTE: var keyword from ES5 allows for re-creation and re-assignment of an existing variable
//Es6 does not have a var keyword, instead it has let. and let does not allow in re-creation and re-assignment
//const are immutable .

---

NOTE:- this section is only for stupid people who want to write ES5 OOP using ES6 arrow functions.

Q. Can ES6 classes (using class use ".prototype") ??

We need to understand how arrow functions can be used in: closures, callbacks, OOPS (like ES5) , promises
in OOPS (ES5) we have to understand how to use it in:-
1. Constructor pattern
2. Factory pattern
3. Dynamic prototype pattern .
    - Arrow functions dont have their own this. (by default)
    - they get the this from outside/parent. So, while using prototypes make sure to use function() instead of arrow functions.   
4. module pattern
5. revealing module pattern

3. Dynamic prototype pattern
    Arrow functions dont create their own this scope (by default).
    they will use the this which was created by the outer scope.
    (inner functions can still reference the data in the parent scope)
    Note:- Arrow functions do not create a this obj. for the function prototype to reference.
     So, Class.prototype.getInfo() will not have the same this as the function Class () {} had.
    Author says, this is where the arrow function fails.
    Hence, when we use the prototypes, always use an anonymous function

    DONT use:
Class.prototype.getInfo = () => {
     ....
     //this is not available
 }

    INSTEAD use:
Class.prototype.getInfo = function (){    //only this way will the new method have access  to the this-object in the constructor()
     ....
     //this is NOW available
 }

NOTE:- Same is true with ES6 style(using classes):-

 class Animal{
          constructor(name, height){
            this.name = name;
            this.height = height;
          }

          hello(){
            console.log('say hello');
          }
        } //Animal class ends

        Animal.prototype.roar = function () {
          console.log(`${this.name} is roaring`);
        };

        /* WONT WORK
        Animal.prototype.roar = () => {
          console.log(`${this.name} is roaring`); //name is undefined.
        };
        */
      
    The above is an example of when NOT TO USE arrow functions.  
---
    Lets c an example of when to use a.f.s
   
    Problem:-
        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){
              return this.members.map(function(x){
                return `${x} is a member of ${this.org}`; //croaks. cannot find property 'org' on undefined.
              });
          } //func ends.
        }; //obj ends.

        console.log(team.teamSummary());

Solution 1:- (old-school)
        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){
            let self = this;    //<<==
              return this.members.map(function(x){
                console.log(self);
                return `${x} is a member of ${self.org}`;    //<<==
              });
          }
        };

        console.log(team.teamSummary());
O/p:-      
["Hitman is a member of assassins", "XXX is a member of assassins", "James bond is a member of assassins"]

Solution 2: using fat arrow functions.
        - this is because a.f. do not have their own this-scope. it uses the this from its immediate-parent.

        const team = {
          members : ['Hitman', 'XXX', 'James bond'],
          org: 'assassins',
          teamSummary : function(){ //we have this here
              return this.members.map((x) => {
                return `${x} is a member of ${this.org}`; //A.f. do not have this. uses this from above.
              });
          }
        };

        console.log(team.teamSummary());


O/p:-
["Hitman is a member of assassins", "XXX is a member of assassins", "James bond is a member of assassins"]

---
Default Arguments:-


---
Q. Can you write IIFE with arrow functions? YES!!!

//eg.1 IIFE without params
//IIFE in es5
(function () {
   console.log('xxxx');
})();

//IIFE in es6
(() => {
   console.log('yyyy');
})();


//eg.2 IIFE with params
//IIFE in es5
(function (a, b) {
   console.log('xxxx', a + b);
})(10, 20);

//IIFE in es6
((a, b) => {
   console.log('yyyy', a+b);
})(30, 40);

Q. Write singleton class (using IIFE) in ES6 ;
A. Find the plunk.

Another plunk showing use of IIFE.
http://plnkr.co/edit/l5cvXhcEreuSRdCZhquv?p=info

//ES5

(function(){
var createworker = function(){
  var task1 = function(){
    console.log('task1');
  };

  var task2 = function(){
    console.log('task2');
  };

  return {
    d1: task1,
    d2: task2
        };
};

var worker = createworker();
worker.d1();
worker.d2();

}());         //})() is allowed too.


//ES6

(() => {
 let createworker = () => {
    let task1 = () => {
      console.log('task1');
    };

    let task2 = () => {
      console.log('task2');
    };

    return {
      d1: task1,
      d2: task2
          };
}; //createworker ends.

  var worker = createworker();
  worker.d1();
  worker.d2();

})();

---

closures in ES6 :- (skipped)
Closures in general:-
    - remember the environment in which they were created
    - can reference independent variables in that env.
    - function factories can be created.
    - enable private data

- closures using arrow functions, closures help us to build function factories
- callbacks using A.Fs.
- singleton using A.F.s

---

eg. 3 let n const
- block scope,
- let is mutable and const is immutable (with exceptions)
    -- ONLY for objects, const allows modification, but not re-assignment

- function expressions: let and const.
f.exs. with const cannot be re-defined, but f.exs. with let can be re-defined.

let func1 = () => {};
//console.dir(func1);
func1 = () => {
  console.log('func1: overriding above function expression');
};
console.log(func1());
const func2 = () => {};

/* This croaks
func2 = () => {
  console.log('func2: overriding above function expresssion');
};
*/

console.log(func2());
//console.dir(func2);

---

eg.4 const and its gotchas with objects.
//eg. 4.1 . number . immutable.
const length = 10;

//length = 20; //NOT Allowed. immutable.
console.log('length is ' + length);

//eg. 4.2 . string . immutable.
const tenLength = 'ten';
//tenLength = 'twenty'; //NOT Allowed. immutable.
console.log('tenLength is ' + tenLength);

//eg. 4.3 boolean. immutable.
const someFlag = true;
//someFlag = false; // NOT Allowed. Immutable
console.log(someFlag);
//eg. 4.4

/*
For objects, complete re-assignment is NOT allowed.
However, existing set of values can be modified/pushed/popped, etc.
*/

//objects
const o = {}; //deviation: const on objects are modifiable
o['one'] = 1;
o['two'] = 2;
//o = {'villian': 'joker'}; //re-assignment is not possible
console.log(o);
let newO = JSON.parse(JSON.stringify(o)); //creating a new copy.
newO['two'] = 'T.W.O.';
console.log (newO);
console.log('-----------');

//arrays
const a = []; // deviation: const on objs (array is an object) are modifiable
a[0] = 10; //pushing is possible
console.log(a);
a.push(20); a.unshift(0);
console.log(a); //pushing & unshifting is possible
a.pop(); a.shift(); //popping & shifting is possible
console.log(a);
//a = [10, 20, 30]; //re-assigning is not possible

let newA = a.slice();
console.log('newA is: ' + newA); //possible

---
eg.5.
Spread operator:- ...

5A) Spreading on arrays
eg.5.1. //simple spreading
let a = [10, 20, 30];
let b = [0, ...a, 40];
console.log(b); //0, 10, 20, 30, 40

eg.5.2.
let a = [10, 20, 30];

function add (...x){
  console.log(a); //10, 20, 30. original
  console.log(x); //10, 20, 30. a new copy
  x[0] = 0;
  console.log(a); //10, 20, 30. orig is as is .
  console.log(x); //0, 20, 30
}
add(...a);


eg.5.3. //local copy by same name (as global)
let a = [10, 20, 30];

function add (...a){ //local copy
  console.log(a); //10, 20, 30. copy created by same name
  a[0] = 0;
  console.log(a); //0, 20, 30. copy is modified.
}

add(...a);
console.log('--------');
console.log(a); //10, 20, 30. orig global array is as is.


eg.5.4. //avoiding local copies will updated globals
let a = [10, 20, 30];

function add (){ //no param to create a local copy
  console.log(a); //10, 20, 30. reference to global array
  a[0] = 0;
  console.log(a); //0, 20, 30. orig is modified.
}

add(...a);
console.log('--------');
console.log(a); // 0, 20, 30 . orig is modified.

eg.5.5 VIMP //passing more than one spread-array will result in pass by reference and not pass by value.
//Only if 1 spread is passed will it be pass by value

    let a1 = [10, 20, 30];
    let a2 = [101, 201, 301];

    //let add = (...x1) => {
    let add = (...x1, ...x2) => { //pass by reference
      x1[0] = 0; //updates a1[0] as well
       console.log(x1);
       console.log(x2);
    };

    add(...a1, ...a2);
    console.log('----------');
    console.log(a1); //0, 20, 30
    console.log(a2);

eg. 5.6
    //for PDT, PDT, spread op. copy is created is 3rd param is mentioned in function definition

    let var1 = 'var1';
    let var2 = 'var2';

    let arr1 = [1, 2, 3];

    //let append = (v1, v2, a1) => { //a1 is pass by reference; orig will be modified.
    let append = (v1, v2, ...a1) => { //a1 is now a copy
        console.log(v1, v2, a1);
        a1[0] = 0;
        console.log(v1, v2, a1);
    };

    //append(var1, var2, arr1); //arr1 is pass by ref. which we already know
    append(var1, var2, ...arr1); //arr1 is pass by value
    console.log(var1, var2, arr1); //var1, var2, [0, 2,3]

eg. 5.7

    let arr1 = [1, 2, 3];
    let arr2 = [11, 21, 31];

    //let append = (...a1, ...a2) => { //error. this is NOT allowed
    let append = (...a1) => { //allowed. a1 now is a copy
                              //a1 now is arr1 + arr2
        console.log(a1);
    };

    append(...arr1, ...arr2);
    console.log('-------------');
    console.log(arr1, arr2);
          
NOTE:-   
1. PDT, PDT, spread op. (in func def n func call ) : works
2. PDT, PDT, spread op., PDT (in func def n func call ) : error. last PDT will not work
3. spread op, spread op (call) //allowed
   spread op( func def) //allowed. see 5.7 //spread op, spread op is NOT ALLOWED in func def

---

5B)Spreading on objects (DONT USE). Just RnD
(lets use arrow functions too, not that it matters).
we are focusing on spread operators.

eg. 5.b.1 //no local param

    let a = {'name': 'jack bauer'};

    let add = () => { //no local param
      console.log(a['name']); //Jack Bauer. //reference to global variable
      a['name'] = 'Ethan Hunt'; //modifying existing value
      console.log(a['name']); //Ethan Hunt
    };

    add(...a);
      console.log(a['name']); //Ethan Hunt

eg. 5.b.2
    //if u want to choose a local param, then that wont work with objects
    let a = {'name': 'jack bauer', 'name2': 'johnny english' };

    let add = (...x) => { //a local copy is NOT created; instead x remains undefined
      console.log(x);
    };

    add(...a);

---
Rest parameter : (in above examples, whereever in func def, we are using ...a1 parameter, those are rest parameters

eg.
    function (...a){
    c.log(a);
    }
    a(1,2,3,4,5);

---
6) Destructing assignment
Previously in ES5,
    let z = [4,5,6];
    let four = z[0];
    let five = z[1];
    console.log(four, five)


6A) Destructing Assignment(Arrays)
eg. 6.1.
    let arr1 = [10, 20, 30];
    //let x, y = arr1; //x is undefined and y = arr1
    let [x,y] = arr1; //x is 10, y is 20.
    console.log(x,y);


eg. 6.2

    let arr2 = [1, 2, 3];
    let arr1 = [10, 20, 30, ...arr2];
    //let x, y = arr1; //x is undefined and y = arr1
    let [x,y,z,xxx] = arr1; //x is 10, y is 20, z is 30, xxx is 1.
    console.log(x,y,z,xxx);

6B) Destructing Assignment (Objects)
    //objects: in ES5 we used to do this:
    let king = { name: 'mufasa', kids : 1};
    let name = king.name;
    let kids = king.kids;
    console.log(name, kids);

eg. 6.b.1.
    let king = { name: 'mufasa', kids : 1};

    let {name, kids} = king; //note the curlies on LHS
    console.log(name, kids);  
   

Note:- we cannot write like this:=
    let name, kids;
    {name, kids} = king;    //WONT work.
//if u wanna make this work, then do this:-
    ({name, kids} = king); //note the round braces.
   
---

http://plnkr.co/edit/T8yGp5pqqlufUcU7gCQP?p=info
plnkr showing traceur embedded in plnkr

---  

Classes in detail:-
- Classes are no longer functions in ES6, ES5 had constructor functions; but not in ES6

eg. 7.1
    class Person { // Note : it is NOT Person (){ in ES6 . Remove (). Thats wrong. This is not ES5.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }
    } //Person ends

    let p1 = new Person ('Jack Bauer', 40, 'New York');
    console.dir (p1);

eg. 7.2
    class Person { // No Person (){ in ES6 . Thats wrong.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }

       //See how the wakeUp() is written. its NOT using arrow functions
       wakeUp(){
         console.log('wake up Jack, POTUS is in danger');
       }

       //Cannot use arrow functions
       /*
       let findTheCriminal = () => {
         console.log('Times against us Jack, find the criminals behind these');
       };
       */

       findTheCriminal(){
       console.log('Times against us Jack, find the criminals behind these');
       };
     
       /* Cannot use IIFE within a class.
       //IIFE within a class
           //(() => {
             sleepWithLoadedGun(){
                  console.log('Jack Bauer has a loaded gun under his pillow');
                }
            // })();

       */
     
        //static-keywords
        //static methods can be called directly by the Class name. they dont require an object instantiation to be called.
        //p1.sleepWithLoadedGun(); //WRONG. Croaks
        //Person.sleepWithLoadedGun(); //Right method signature
      
        static sleepWithLoadedGun(){
            console.log('STATIC: Jack Bauer has a loaded gun under his pillow');
        }

        //constructor properties are accessible in other functions.
        whoami(){
            console.log(this.name, this.age, this.city);
        }

    } //Person ends

    let p1 = new Person ('Jack Bauer', 40, 'New York');
    console.dir (p1);.
    Person.sleepWithLoadedGun();
    p1.wakeUp(); p1.findTheCriminal();

    p1.whoami(); //prints jack bauer, 40, New York

eg. 7.3

    class Person { // No Person (){ in ES6 . Thats wrong.
       constructor(name, age, city){
         this.name = name;
         this.age = age;
         this.city = city;
       }
    } //Person ends

    class Assassin extends Person {
      constructor(id, weapon){
        super(Person); //gets properties from the Person class

        this.id = id;
        this.weapon = weapon;
      }
    } //Assassin ends

    let p1 = new Person ('Johnny English', 35, 'Liverpool');
    console.dir(p1);

    let p2 = new Assassin('007', 'Baretta');
    p2.name = 'James';
    console.dir(p2); //age and city are undefined. Plz note this.

eg. 7.4
// multiple inheritance in ES6 is frowned upon.
    use npm's mixins library: https://medium.com/@leocavalcante/es6-multiple-inheritance-73a3c66d2b6b
D:\js\es6>npm install mixins --save-dev

// method overloading
// operator overloading
// method overriding

eg. 7.5
eg. 7.6
eg. 7.7 

D:\js\es6\node_modules\webpack\bin>node webpack.js -v
2.5.1
   
---

8) https://stephengrider.github.io/JSPlaygrounds
Lodash/Underscore helper methods now implemented as Array methods in ES6:-
- helps u greatly when working with collections of data.

ARRAY helper methods:-
- forEach, map, filter, find, every, some, reduce

Pre-requisite: understand of collections i.e. array of objects && how to access their individual elements (without any helper methods).
This is basic stuff

    Basic(1)
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
    ] ;

    console.log(assassins[0].name, assassins[0].age );            //works.
    console.log(assassins[0]['name'], assassins[0]['age'] );    //same as above.

    ----
   
    Basic(2) : function as a property . This will be important to understand iterables when we get there.
   
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {getKey: 'XXX', organization: 'IMF', age: 41} //notice this !!! we are NOT using getKey() with (). Simply getKey.
    ] ;

    let getKey = () => 'name';
    //console.log(getKey()); //works

    console.log(assassins[4].getKey, assassins[4].age );        //XXX, 41. works
    console.log(assassins[4]['getKey'], assassins[4]['age'] );  //XXX, 41. works

    ---
   
    Basic(3): function --> called by an obj ---> collection using the prev. obj (value)
   
    let getKey = () => 'name';

    //creating an obj. 1
    let obj = {
      getKey: 'Hitman', age: 22
    }

    //getting obj into assassins.
    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {getKey: 'XXX', organization: 'IMF', age: 41}, //notice this !!! we are NOT using getKey() with (). Simply getKey.
      {getKey: obj['getKey']}      //Q. how can LHS be derived from obj.key??
    ] ;

    //console.log(assassins[4].getKey, assassins[4].age );
    //console.log(assassins[4]['getKey'], assassins[4]['age'] );
   
    console.log(assassins[5].getKey); //Hitman

8.1) forEach
eg. 8.1.1

var colors = ['blue', 'blanc', 'rouge', 'red'];

colors.forEach(function(x){
  console.log(x);
});

eg. 8.1.2
//here the function is called the iterator function. it runs one time for each of the element.
//the iterator function can be decoupled and kept separate as well

let iteratorFunc = (x) => {
  console.log(x);
};
colors.forEach(iteratorFunc);

---

8.2) map

eg. 8.2.1
var nums = [10, 20, 30];
var doubledNums = nums.map(function(x){
  return x*2; //very imp. line
});
console.log(doubledNums);

eg. 8.2.2 //using fat arrow

let nums = [10, 20, 30];

let multiplier = x => x*3;

let doubledNums = nums.map(multiplier);
console.log(doubledNums);

---
8.3) filter
eg.8.3.1
let assassins = [
  {name: 'Ethan Hunt', organization: 'IMF', age: 50},
  {name: 'James Bond', organization: 'Mi6', age: 49},
  {name: 'Money Penny', organization: 'Mi6', age: 28},
  {name: 'Benji', organization: 'IMF', age: 30},
] ;

let people = assassins.filter(function(item){
  return item.organization === 'IMF'; //Vimp return is necessary. this is a truthy exp.
  //return item.organization === 'IMF' && item.age > 30;
});
console.log(people);


eg. 8.3.2 //using fat arrow
let assassins = [
  {name: 'Ethan Hunt', organization: 'IMF', age: 50},
  {name: 'James Bond', organization: 'Mi6', age: 49},
  {name: 'Money Penny', organization: 'Mi6', age: 28},
  {name: 'Benji', organization: 'IMF', age: 30},
] ;

let finder = (item) => item.organization === 'Mi6' && item.age > 30; 
let people = assassins.filter(finder);

console.log(people);

---

eg. 8.4 find == returns only 1st record/object found . This is how it is different from filter.

    let assassins = [
      {name: 'Ethan Hunt', organization: 'IMF', age: 50},
      {name: 'James Bond', organization: 'Mi6', age: 49},
      {name: 'Money Penny', organization: 'Mi6', age: 28},
      {name: 'Benji', organization: 'IMF', age: 30},
      {name: 'Benji', organization: 'IMF', age: 29}
    ] ;

    let finder = (item) => item.name === 'Benji';
    let found_assassings = assassins.find(finder); //returns only first element found
    console.log(found_assassings);
   
---

eg. 8.5 every  & some : returns a boolean value.
        every: returns true, if every element matches the condition. else false.
        some: returns true, if some elements match the condition. else false.
      
        this is how they r different from filter. (filter doesnt give the boolean ; it returns the matched list objects.
      
        let assassins = [
          {name: 'Ethan Hunt', organization: 'IMF', age: 50},
          {name: 'James Bond', organization: 'Mi6', age: 49},
          {name: 'Money Penny', organization: 'Mi6', age: 28},
          {name: 'Benji', organization: 'IMF', age: 30},
          {name: 'Benji', organization: 'IMF', age: 29}
        ] ;

        let everyFunc = (item) => item.age < 30 ;

        let found_assassins = assassins.some(everyFunc);
        //let found_assassins = assassins.every(everyFunc);
      
        console.log(found_assassins);

---      
      
eg. 8.6 reduce
        - toughest to understand, people think it is only for summing.
        - requires an array object to work with .
      
        eg. 8.6.1
      
        let numbers = [10, 20, 30];
        //let sum = 0;

        let x = numbers.reduce (function(total, item){ //total is any tmp local var. into which we will keep on adding
          console.log (total, item, total + item);
          return total + item;
        }, 2);
        //2 is initial value and is optional.
        //if 2, 2+10 = 12, 12+20 = 32, 32+30 = 62. 3 iterations.
        //if 1, 1+10 = 11, 11+20 = 31, 31+30 = 61. 3 iterations.
        //if 0, 0+10 = 10, 10+20 = 30, 30+30 = 60. 3 iterations.
        //if not mentioned, then, 10+20 = 30, 30+30 = 60. 2 iterations.

        console.log(x);
      
        eg. 8.6.2
      
        //the first param of reduce is tricky to name.
            - u can call it total if summing
            - u can call it previous/acc , acc meaning accumulator , because it accumulates.
        //optional initial value is the next tricky part.
            - sometimes it maybe required, other times not.
            - u can keep it as [], in which case the previous-var/acc-var will be an array.  
          
        let colors = [
          {color: 'red'},
          {color: 'blue'},
          {color: 'green'}
        ];

        let x = colors.reduce (function(prev, primaryColor){
           prev.push(primaryColor.color);
           return prev; //vimp.
        }, []);

        console.log(x);
   
        eg. 8.6.3
        //balanced parantheses function . eg. "()()()()", "(((())))",
        //unbalanced:- ")("  
      
        //let input = `((()))(`;
        let input = `)(`;
        let arrInput = input.split(''); //convert into an array.
        console.log(arrInput, Array.isArray(arrInput) );

        let x = arrInput.reduce(function(prev, item){
           if (prev < 0) { return prev }

           if (item === '('){
              ++prev;
           }
           else{
             --prev;
           }
           return prev;
        },0);

        console.log(x);
        (!x) ? console.log('Balanced string') : console.log('Unbalanced string') ;

---
9) Destructuring:-

    eg. 9.1.

    let obj = {
      name: 'James Bond',
      org : 'mi6'
    };

    //without destructuring -- LHS can be any variable name
    //let agent_name = obj.name;
    //let agent_org = obj.org;

    //with destructuring.
    //Sol.1.:-
    //{} is syntax for destructuring. We are NOT creating an object here.
    //LHS var name has to match the property name in the obj.
    //RHS only has the obj name
    //let { name } = obj;
    //let { org } = obj;

    //Sol.2. :-
    let {name, org} = obj;
    console.log(name, org);

NOTE:- if u destruct with a property that does NOT exist, then it WONT croak, it will give "undefined"

    let {name, org, joker} = obj;
    console.log(name, org, joker); // , , undefined

    eg. 9.1.2
      
    //destructuing in functions
    //previously
    /*
    let printSome = function(objItem){
      return `${objItem.name} is in ${objItem.org}` ;
    };
    */

    //sol1:- single obj param
    /*
    let printSome = function({name, org}){
      return `${name} is in ${org}` ;
    };
    */ //james bond is in mi6

    //Sol2: multiple obj params
    let printSome = function({name, org}, {weapon}){
      return `${name} is in ${org} and uses a ${weapon}` ;
    };
    //2 params in call
    console.log(printSome(obj, { weapon:'sniper' }
                         ));
    //james bond is in mi6 and uses a sniper                    

---























---
Reflect API

https://ponyfoo.com/articles/es6-reflection-in-depth
    https://ponyfoo.com/articles/es6-proxies-in-depth
    https://ponyfoo.com/articles/es6-proxy-traps-in-depth
    https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth

https://ponyfoo.com/articles/cross-tab-communication
https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth

https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/
https://www.keithcirkel.co.uk/metaprogramming-in-es6-part-2-reflect/

    The new APIs in ES6 come in three flavours: Symbol, Reflect, and Proxy. Upon first glance this might be a little confusing - three separate APIs all for metaprogramming? But it actually makes a lot of sense when you see how each one is split:

    Symbols are all about Reflection within implementation - you sprinkle them on your existing classes and objects to change the behaviour.
    Reflect is all about Reflection through introspection - used to discover very low level information about your code.
    Proxy is all about Reflection through intercession - wrapping objects and intercepting their behaviours through traps.

---

http://qnimate.com/difference-between-set-and-weakset-in-javascript/

   
   



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx



2.
Modules:-
- Code living in separate files
- Split code into unique files based on relevant data
Handled in es6 using the export and import keywords
------------------------------
function cheer(){
    console.log('woohoo');
}
cheer();
var cheer = function(){
   c.log('woohoo2');
};
cheer();
setTimeout(function(){
     console.log('woohoo3');
}, 3000);
//es6 code.
setTimeout(() => {
     console.log('woohoo3');
}, 3000);

//es6
let cheer = () => {
  c.log('woohoo4');
};
cheer();
------------------------------------
arrow functions in helper methods like map, filter.
let values = [1, 2, 3];
let double = (n) => {
   return n * 2;
}
let doubled = values.map(double); //double is a callback .
console.log(doubled);
- OR-
let doubled = values.map((n) => {
 return n*2;
});
console.log(doubled);
- OR-
since it is only one loc, we can shorten it by
- removing the curlies
- removing the return keyword
let doubled = values.map((n) => n*2;);
console.log(doubled);
--------------------------------
es6 additional helper methods
- String.repeat() //returns string of concatenated copies
- searching with startsWith, endsWith, includes and more ...
- number checking for type and safety
------------------------------
string helper methods:
String.repeat(
let b = "wooh" + "oo".repeat(50);
console.log(b);
let b = `wooh${"oo".repeat(50)}`;  //using literals.
console.log(b);

See how "oo".repeat(50) is put in ${} to make interpolation work.
------------------------------
console.log("butterfly".includes("cater"));
console.log("butterfly".startsWith("cater"));
.startsWith, endsWith and .includes all return boolean values.
-----------------------------
v 51
checking numbers: (validating data input in application)
eg1.
const addToCart = (item, number) => {
     return Number.isFinite(number); //allows to check input data.
}
console.log(addToCart('shirt', Infinity));

 -OR-
....
return Number.isSafeInteger(number); //returns false. so even though finite, JS cannot handle it.
}

console.log(addToCart('shirt', Math.pow(2,54)
                                     ));
==========================
Modules:-
import = get primitive values, objects and functions from another module
export = just export
default: fallback expression when it exports multiple

==========================
==========================PART 3 (export/ import)

es6/app/recipe.js

let recipeNames = ['kebab', 'dosa'];
let recipeObject = {
  name: 'Dum biryani',
  author: 'sanjeev kapoor'
};

let func1 = () => {
  console.log('this is func1: recipe.js');
};

const func2 = () => {
  console.log('this is func2: recipe.js');
};
export {recipeNames, recipeObject, func1, func2} ;
export default recipeObject ;

/*
http://2ality.com/2015/07/es6-module-exports.html
Exporting: ES6 modules export immutable bindings ; CommonJS modules export values.
bindings are live connections to values.

styles of importing:
1. import * from './recipe' ;
2. import {recipeNames, recipeObject, func1, func2} from './recipe';
Styles of exporting
1. inline exporting:
export let var1 = 10;
export let var2 = 'var2';
2. explicit exporting
export {recipeNames, recipeObject, func1, func2} ;
export default recipeObject ;
3. u can export variables/constants, functions, array, objects
- also classes
- Q. how to import classes?
*/

es6/app/index.js
console.log("hellow world from webpack ! Welcome to the matrix neo !!!");
import {recipeNames, recipeObject, func1, func2} from './recipe'; //.js is understood
console.log (recipeNames, recipeObject);
recipeNames.push('jackass'); //modifiable as if they r local
recipeObject['age'] = 50; //modifiable as if they r local
console.log (recipeNames, recipeObject);

//recipeNames = ['recipe1', 'recipe2']; //NON re-assignable
//recipeObject = {name : 'horsecrap'}; //NON re-assinable.
console.dir(func1);
func1(); //let function
//func1 = () => {}; //error . func1 is readonly
console.dir(func2);
func2(); //const function
//func2 = () => {} ; //error. func2 is readonly
console.log('-----------------------');

===============================
===============================PART xxxx

---------------------------------------------------------------
Data Structures in ES6
set:- stores unique values . add(), delete() and has()  (has returns boolean), size(for # of elemnts)
let a = new Set();
arr = [10, 20, 30]
let newSet = new Set(arr);
- u can add primitive values to objects
a.add(10);
a.add(20);
a.add ({x:20,y:30})
console.log(a, a.size, a.has(5));
.values returns an iterator object to get all values one by one. for this use the enhanced for-of loop
for (let item of newSet.values()){
   console.log(item);
}

map:= maps have keys and values
=each key is unique.
- similarity to objects.
- key can be anything , even functions ,
let a = new Map();
let key1 = 'k1';
a.set(key1, 'sdfsdfsfd');
console.log(a);
.has() , .get() method is available.
object can be made a key as well.
function can be made a key as well.
Convert an arr into a map:=
let newMap = new Map(arr);
if arr is an array of arrays, then it is better.
for (let [key, value] of newMap.values()){
   console.log(key, value);
}

Set iteration frequently occurs through the values() helper method.
Map iterate frequently occurs through the entries() helper method.
=====================================
====================================
Generators
- break the typical "run to completion" model for functions
- generators can pause and resume in the middle. using yield-keyword and next() respectively
- they help us to construct controlled flow functions and iterators.

function* letterMaker(){
     yield 'a';
     yield 'b';
     yield 'c';    
}

let x = letterMaker();
console.log(x.next().value);
console.log(x.next().value);
console.log(x.next().value);
console.log(x.next().value); //undefined.
try .next() with a while().

Adding a reset functionality to a generator:-
.next() take a parameter which defines the state of the generator.

arguments is an inbuilt datastructure which captures everything passed to it.
so u can traverse arguments like this:

for (let arg of arguments){
    yield arg;
}
=OR=
yield* arguments ;


(so that u can skip the for-of loop)
We will see this later
In this example, we can actually make use of an infinite while loop
function* evens(){
        let count = 0;
        while (true){
           count += 2;
           yield count;
        }
}
let sequence = evens();
console.log(sequence.next().value);
console.log(sequence.next().value);
console.log(sequence.next().value);
console.log(sequence.next(true).value);
console.log(sequence.next().value);
To add the reset functionality, we need to do 2 things:-
 - call .next(true)
- modify the above function like this:
function* evens(){
        let count = 0;
        while (true){
           count += 2;
        let reset = yield count;
        if (reset){
           count = 0;
        }
        }
}

Note:-
- yield; is a perfectly valid line
- once the generator has finished execution, done is set to true i.e. {done:true}

---
Generators vs Iterators: v 80
Iterators: in any prog. lang. will access items from a collection / array one at a time.
And it keeps track of its position as it does so.
 Q. how to create a custom iterator in es6?
- create a function with module pattern and implement a next-function in the return section.
Q. how to convert an iterator into a generator?
Q. Generators vs iterators vs iterables

---
Generator delegation (v55, v56 of The complete guide ) -- VIMP.
- yield*
-




---
Iterables:- http://exploringjs.com/es6/ch_iteration.html
http://exploringjs.com/es6/ch_iteration.html#sec_plain-objects-not-iterable (objects are not iterables in JS)

ES6 introduces a new mechanism for traversing data: iteration. Two concepts are central to iteration:
    An iterable is a data structure that wants to make its elements accessible to the public.
        It does so by implementing a method whose key is Symbol.iterator. That method is a factory for iterators.
    An iterator is a "pointer" for traversing the elements of a data structure (think cursors in databases).
        -- implements a .next() method.
        -- on-demand iteration can be implemented in a generator using this.

Expressed as interfaces in TypeScript notation, these roles look like this:
interface Iterable {
    [Symbol.iterator]() : Iterator;
}
interface Iterator {
    next() : IteratorResult;
}
interface IteratorResult {
    value: any;
    done: boolean;
}

The following values are iterable:

    Arrays
    Strings
    Maps
    Sets
    DOM data structures (work in progress)

(Yes, PLAIN objects are not iterables !!!)
Language constructs that access data via iteration:
- Destructuring via an Array pattern:
    const [a,b] = new Set(['a', 'b', 'c']);
- for-of loop:

  for (const x of ['a', 'b', 'c']) {
      console.log(x);
  }

-  Array.from(): //for convertin array-like objects into arrays
  const arr = Array.from(new Set(['a', 'b', 'c']));

- Spread operator (...):
  const arr = [...new Set(['a', 'b', 'c'])];

- Constructors of Maps and Sets:

  const map = new Map([[false, 'no'], [true, 'yes']]);
  const set = new Set(['a', 'b', 'c']);

Promise.all(), Promise.race():

  Promise.all(iterableOverPromises).then(···);
  Promise.race(iterableOverPromises).then(···);

yield*:

  yield* anIterable;


Iterator: The iterator is an object that returns values via its method next(). We say: it iterates over the items (the content) of the iterable, one per method call.

NOTE:- for-of can be used only with ITERABLES. for-op requires the Data Structure to have a Symbol.iterator property.

> const arr = ['a', 'b', 'c'];
> const iter = arr[Symbol.iterator]();

Then you call the iterator’s method next() repeatedly to retrieve the items “inside” the Array:

> iter.next()
{ value: 'a', done: false }
> iter.next()
{ value: 'b', done: false }
> iter.next()
{ value: 'c', done: false }
> iter.next()
{ value: undefined, done: true }

NOTE:- Maps are iterables, WeakMaps are not iterable.
Sets are iterable, WeakSets are not iterable. 
 
   

---
Array-like Objects:-

Array-like objects look like arrays. They have various numbered elements and a length property.
But that’s where the similarity stops. Array-like objects do not have any of Array’s functions, and for-in loops don’t even work!

You’ll come across these more often than you might expect. A common one is the arguments variable that is present inside of every js function.


+++++++++++++++++++++++++++++++++++++++++++++++

Symbols:

http://exploringjs.com/es6/ch_symbols.html#sec_primitive-type-symbol

++++++++++++++++++++++++++++++++++++++++++++++

Syne training:-



ES6:-

1) Destructuring  objects

<script type="module">
 let comp = {name: 'synechron', site: 'hinjewadi'};
 let {name, site} = comp;
 console.log (name,site);

</script>

//compName and compSite are two new objects
<script type="module">
 let comp = {name: 'synechron', site: 'hinjewadi'};
 let {name : compName, site : compSite} = comp;
 console.log (compName, compSite);

</script>

<script type="module">
 let comp = {name: 'synechron',
             site: 'hinjewadi',
             projects:
                 {
                     project01: 'DMT',
                     project02: 'xyz'
                 }
            };

 //read from right to left.
 //RHS to LHS: From comp, i want the key "projects", from which i want project01, and assign project01 to a new variable "p1"
 let {projects: {project01: p1}, projects: {project02: p2}} = comp;
 console.log(p1, p2);
</script>

 
---

destructuring arrays :-

let arr=['10', '20', '30'];
console.log (arr[0], arr[1], arr[2]); // 3 lines to create new vars a1, a2,a3
let [a1, a2, a3] = arr;
console.log (a1, a2, a3); // we can do it in one line



---

---
destructuring using functions:-

Earlier:-
 function somefunc(){
     const x1 = 10;
     const x2 = { name: 'Sachin', lastname: 'Tendulkar'};
     return {
         xone: x1,
         xtwo: x2
     };
 }
 let someobj = somefunc();
 console.log(someobj.xone, someobj.xtwo);


 Now:-

function somefunc(){
     const x1 = 10;
     const x2 = { name: 'Sachin', lastname: 'Tendulkar'};
     const x3 = new Array(3, 10, 20, 30); //3 elements and the elements are 10, 20, 30.
     return {
        x1, x2, x3
     };
 }

 //---

 method1: works

//  let {x1, x2} = somefunc(); //method1
//  console.log(x1, x2);    // works

method2: works
   let {x1:xone, x2:xtwo, x3:xthree} = somefunc();  //method2: using a new variable
   console.log(xone, xtwo, xthree);

 // let {xone, xtwo} = somefunc();
// console.log(xone, xtwo);

 //method3: works


 let {x1:xone, x2:xtwo, x3:[a10, a20, a30]} = somefunc();  //method2: using a new variableconsole.log(a10, a20, a30);


---
https://github.com/vijayshivakumar/ng4

---
https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone

---

Temportal dead zone:-

---
https://github.com/vijayshivakumar/ng4
https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone

let and const have two broad differences from var:
    They are block scoped.
    Accessing a var before it is declared has the result undefined; accessing a let or const before it is declared throws ReferenceError:

console.log(aVar); // undefined
console.log(aLet); // causes ReferenceError: aLet is not defined
var aVar = 1;
let aLet = 2;

It appears from these examples that let declarations (and const, which works the same way) may not be hoisted, since aLet does not appear to exist before it is assigned a value.
That is not the case, however—let and const are hoisted (like var, class and function), but there is a period between entering scope and being declared where they cannot be accessed.
This period is the temporal dead zone (TDZ).

The TDZ ends when aLet is declared, rather than assigned:
//console.log(aLet)  // would throw ReferenceError

let aLet; //TDZ ends here.
console.log(aLet); // undefined
aLet = 10;
console.log(aLet); // 10

This example shows that let is hoisted:

let x = 'outer value';
(function() {
  // start TDZ for x
  console.log(x);
  let x = 'inner value'; // declaration ends TDZ for x
}());

---
Solution:-

chrome://flags/#enable-javascript-harmony

Remove transpiler code and enable experimental features in JS
Then it works as expected.

---

Rest parameters
(Rest parameters can be used to replace "arguments"??)

    //using rest parameters.
    function somefunc(...xyz){
        console.log(xyz[0], xyz[1], xyz[2], xyz[3]); //10, 20, 30, undefined
        xyz.push(40);
        console.log(xyz[3]);
    }
    somefunc(10,20,30);

    //using ES5 arguments.
    function somefunc2(){
        console.log(arguments[0], arguments[1], arguments[2], arguments[3]); //10, 20, 30, undefined
        //arguments.push(40); //we cannot do this !!! as arguments is an Array-like function.
        //console.log(arguments[3]);
    }
    somefunc2(10,20,30);

---

Spread operator:- Think of it like opp. of rest parameters.

 

let somearr1 = [10, 20, 30];
//use1let x = [...somearr1, 40];
console.log(x);
//use2console.log (Math.min(...somearr1), Math.max(...somearr1) ); //Math.min requires number-sequences and NOT an array.

---
---

Template strings:-

---
class:-

eg.1. auto property creation using this.name

<script>

    class Person {
        constructor(){

        }
        getName(){
            console.log(this.name);
        }

        setName(p1){
            this.name = p1;
            console.log(this.name);
        }
    }

    let p1 = new Person();
    p1.getName();
    p1.setName('xxx');
    p1.getName();

</script>




























GENERAL STUFF:- (not es6 related)

Promises:-
eg.1.
function  t1() {
    return new Promise(function(resolve, reject){
        resolve("t1 resolved");
    })
} //t1 ends

    console.log(t1());
//My question is what do the double brackets [[ ]] mean, and how do I retrieve the value of [[PromiseValue]].
//It's an internal property. You cannot access it directly.
// Native promises may only be unwrapped in then with promises or asynchronously in generally
//these are really private symbols. The reason they exist is for other internal methods to be able to access [[PromiseValue]]

---

eg.2.

function  t1() {
    return new Promise(function(resolve, reject){
        resolve("t1 resolved");
        console.log("t1 resolved");
    })
} //t1 ends


function  t2() {
    return new Promise(function(resolve, reject){
        resolve("t2 resolved");
        console.log("t2 resolved");
    })
} //t2 ends

function  t3() {
    return new Promise(function(resolve, reject){
        resolve("t3 resolved");
        console.log("t3 resolved");
    })
} //t3 ends

//chaining t1 and t2 only !!!

t1().then(function(resolve, reject){
    return t2();
});


//chaining t1, t2 and t3
//setTimeout( () => {
    t1().then(function (resolve, reject) {
    return t2().then(function (resolve, reject) {
        return t3();
    });
});

//}, 3000);

If u dont put setTimeout then it will merge with previous consolelogs. Why? i dont know.

---
eg.3.

function  t1() {
    console.log('t1 is done');
} //t1 ends


function  t2() {
    setTimeout(()=>{console.log('t2 is done');}, 3000);
} //t2 ends

function  t3() {
    console.log('t3 is done');
} //t3 ends

Promise.race([t3(), t2(), t1() ]);  //sequence is not maintained. t3, t1, and t2.
    //t2 is async.
   
---    
   
eg.4.

function  t1() {
    setTimeout(()=>{console.log('t1 is done');}, 2000);
} //t1 ends


function  t2() {
    setTimeout(()=>{console.log('t2 is done');}, 3000);
} //t2 ends

function  t3() {
    setTimeout(()=>{console.log('t3 is done');}, 4000);
} //t3 ends

//chaining t1 and t2 only !!!

Promise.race([t3(), t2(), t1() ]);  //sequence is not maintained. t3, t1, and t2.
    //t2 is async.

---

eg. 5    (ONLY when the timeout time is same, will Promise.race, execute in the same order)

function  t1() {
    setTimeout(()=>{console.log('t1 is done');}, 3000);
} //t1 ends


function  t2() {
    setTimeout(()=>{console.log('t2 is done');}, 3000);
} //t2 ends

function  t3() {
    setTimeout(()=>{console.log('t3 is done');}, 3000);
} //t3 ends

Promise.race([t3(), t2(), t1() ]);  //sequence is not maintained. t3, t1, and t2.
    //t2 is async.

---
Similar behavior is experienced with Promise.all

Note:- if u want a clearer Promise.race([p1, p2]) (without the executions ()), then use like this:

var p1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, 'one');
});
var p2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, 'two');
});

Promise.race([p1, p2]).then(function(value) {
  console.log(value); // "two"
  // Both resolve, but p2 is faster
});

---

eg. 6.
NOTE:- .then() and .catch() can ONLY be called when the t1() returns a newPromise(), else they cannot be used!!!
So below will FAIL:

function  t1() {
    setTimeout(()=>{console.log('t1 is done');}, 2000);
} //t1 ends

t1().then(function(resolve, reject){
   console.log(resolve('t1 completed'));
});

---   
eg. 7.
//is there anyway we can convert normal functions to return promises?
//yes. see below

function  t1() {
    setTimeout(()=>{console.log('t1 is done');}, 2000);
} //t1 ends


function  t2() {
    setTimeout(()=>{console.log('t2 is done');}, 3000);
} //t2 ends

function  t3() {
    setTimeout(()=>{console.log('t3 is done');}, 3000);
} //t3 ends


//is there anyway we can convert normal functions to return promises?
//yes. see below
function changeToPromise(p1){
    //p1 will be a function def.
    return new Promise(function(resolve, reject){ //wrapping p1 in a promise.
        p1();
        resolve('resolved p1 to true');
    })  ;
}

let changed1 = changeToPromise(t1);
console.log(changed1);//changed1 is now a promise. //we can now use .then() or .catch() on it .
changed1.then(function(resolve, reject){
    console.log('p1 was resolved');
});

---

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Self, Call, apply and bind

    var cart = {
        saleValue: function(){
            return 100;
        },
        calculateTax: function(){
            //var self = this;
            var getTaxAmount = function(){
                return this.saleValue() * 0.2;
                //return self.saleValue() * 0.2;
            } //getTaxAmount ends.

            //return getTaxAmount() + this.saleValue();
            //return getTaxAmount.call(this) + this.saleValue();
            //return getTaxAmount.apply(this) + this.saleValue();
            return getTaxAmount.bind(this)() + this.saleValue();

        } //calculateTax ends
    }; //cart ends

    console.log(cart.calculateTax());


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

This is a default import:

// B.js
import A from './A'

It only works if A contains a default export:

// A.js
export default 42

In this case it doesn’t matter what name you assign to it when importing:

// B.js
import A from './A'
import MyA from './A'
import Something from './A'

Because it will always resolve to whatever is the default export of A.
This is a named import called A:

import { A } from './A'

It only works if A contains a named export called A:

export const A = 42

In this case the name matters because you’re importing a specific thing by its export name:

// B.js
import { A } from './A'
import { myA } from './A' // Doesn't work!
import { Something } from './A' // Doesn't work!

To make these work, you would add a corresponding named export to A:

// A.js
export const A = 42
export const myA = 43
export const Something = 44

A module can only have one default export, but as many named exports as you like (zero, one, or many). You can import them together:

// B.js
import A, { myA, Something } from './A'

Here, we import the default export as A, and named exports called myA and Something, respectively.

// A.js
export default 42
export const myA = 43
export const Something = 44

We can also assign them all different names when importing:

// B.js
import X, { myA as myX, Something as XSomething } from './A'

The default exports tend to be used for whatever you normally expect to get from the module. The named exports tend to be used for utilities that might be handy, but aren’t always necessary. However it is up to you to choose how to export things: for example, a module might have no default export at all.

http://2ality.com/2014/09/es6-modules-final.html
https://stackoverflow.com/questions/36795819/when-should-i-use-curly-braces-for-es6-import/36796281 


<<<<some screenshot #2>>>>


+++++++++++++++++++++++++++++++++++++++++++++++++++++++


 ng2 explanations
ng2 start:-    (for installation see Maximilians guide ng new ... )
D:\js\test\js1>ng serve
(keep this cmd terminal running, open another terminal if u want bootstrap, etc. installed)

---

- index.html = our SPA.
    @ run time, webpack will add polyfills/bundles etc and insert it into the html .
- main.ts
uses platformBrowserDynamic().bootstrapModule(AppModule);
// AppModule implies app.module(.ts)
// PlanktonLex would imply plankton.lex(.ts)  .ts is understood.
// when we create components, (we will c components soon ), we will use the same naming convention i.e.
    //server.component(.ts) would be referred as ServerComponent in code in TS.
   
    => as u can see AppModule is bootstrapped, i.e. app.module.ts is bootstrapped 
        and if u see app.module.ts, in @NgModule, we can see it is bootstrapping AppComponent, i.e. it is bootstrapping app.component.ts
    => app.component.ts is called the ROOT component.
        - any other web component we create will be a child of this ROOT Component.
       
---

creating a module manually :-
- create app/server/ folder       
    -- create server.component.ts. It will be called by ServerComponent, when u code.
    -- create a templateUrl for it, and a selector using @Component({ ... }).
        -> selector means
            -- what html-tag will be used to reference it? eg. <app-server></app-server>
            -- if u put it in [] square braces, it becomes attribute. in that case use it as eg. <div app-server></div>
           
        -> @Component is a decorator which helps us in creating this component, using the selector & templateUrl.
            Without it, it is just a class named ServerComponent; when we use @Component, angular understands, we want to
            it to consider as a component
            -- it comes from a package called @angular/core.
       
    app/server/server.component.ts
            import { Component } from '@angular/core';
            @Component({
              selector: 'app-server',
              templateUrl: './server.component.html'
            })
            export class ServerComponent{
            }

    app/server/server.component.html
        <h3>I am a server component; take stock of me.</h3>

       
    Remember, all components are child to the ROOT app-component.
    So, inorder for the root component to pick our server component up we need to edit app.module.ts
   
    - import { ServerComponent } from './app/server.component.ts';
    - add ServerComponent to the "declarations" array.
   
    Our app-server is still not visible on UI, this is because we have not used the selector <app-server></app-server> anywhere.
    So, lets add it into app.component.html
        <app-server></app-server>
   
- Data binding:- is a mode of communication between the view and the model, and there r 4 ways to do it (in angular):-
1. String interpolation (use it when u want to display something on the view)
    -- {{ }} is the syntax.
        NOTE: it cannot be multiline and it cannot have multiline logic of if/else, etc.
2. Property binding (use it when logic is property-based and nothing is to be presently directly on the view)
    -- [] square braces is the syntax
3. Event binding (use it to bind events)
    gotcha: vanilla events like onclick, onmouseover, etc. become click, mouseover, etc. (so the "on is omitted")
    -- () round braces is the syntax
4. Two-way data binding (uses property binding + event binding)   

---
styling ServerComponent:-
create app/server/server.component.css
h3{
    color: dodgerblue
}

server.component.ts (add this line):
  ,
  styleUrls: ['./server.component.css']  

 
server.component.html
<h3>I am a server component; take stock of me.</h3>
      {{serverId}}
<button class="btn btn-default">Add Server</button>
   
---
styling app component (installing bootstrap )

installing bootstrap:- (we r going to add more components, so to make it beautiful, lets use bootstrap for now)
D:\js\test\js1>npm install --save-dev bootstrap

VIMP!!!
.angular-cli.json
    "styles": [
            "../node_modules/bootstrap/dist/css/bootstrap.min.css",
            "styles.css"
          ],
         
---
creating a new component automagically

cd D:\js\test\js1\src\app>
ng g c servers (this folder/component should NOT be existing before)
(u can run this from platformio-ide-terminal too).
app.component.ts is automatically updated.

next steps:-
app.component.html --> <app-servers></app-servers>
    servers.component.ts
        - import {ServerComponent} from '../server/server.component';
    servers.component.html
        - <app-server></app-server>
       

---

1. String interpolation:-
Some data from the model needs to be displayed on the view.
Add a variable like serverId in the ServerComponent class and u can get that variable in the view using {{10}}

2. property binding:-
lets say we now wanted to disable the button.
app.component.html
          <button class="btn btn-primary" disabled>Add Server</button><br>

lets say we now wanted to disable the button, but after 3 secs, it should become enabled.          
- declare any variable with boolean value in servers.component.ts
app.component.html
- <button class="btn btn-primary" [disabled] = !setEnableFlag>Add Server</button><br>

3. event binding:-
servers.component.html
    <button class="btn btn-primary"
      [disabled] = !setEnableFlag
      (click) = onClickCreateServer()  >Add Server</button><br>

      <div><strong>{{onClickCreated}}</strong></div>
     
4. two-way data binding:-
<div class="form-group">
  <input type="text" class="form-control serverInputClass"
  [(ngModel)]="serverInput" value="serverInput"
  >
  {{serverInput}}
</div>     

For 3 n 4,
servers.component.ts:

import { Component, OnInit } from '@angular/core';
import {ServerComponent} from '../server/server.component';

@Component({
  selector: 'app-servers',
  templateUrl: './servers.component.html',
  styleUrls: ['./servers.component.css']
})

export class ServersComponent implements OnInit {
  setEnableFlag = false;
  onClickCreated = '';
  serverInput = 'DummyServer';

  constructor() {
    setTimeout(() => {this.setEnableFlag = true
      console.log('xxxxxxxxxx');
    }, 3000);

  }//constrcutor ends

  onClickCreateServer(){
    console.log('created served');
    this.onClickCreated = 'Server created, Mr.Anderson';
  }

  ngOnInit() {
  }

} //exporting ends

=========================================================

Directives = instructions placed on the DOM
Components are directives-with-template.
There are also directives-without-template.
    2 types:-
    structural & attribute directives.
   
Built-in directives:- ngIf, etc.

*ngIf
    * is for structural directive. Without it, it would NOT work.
    - creates the control @ runtime
    - can assign it a function too
   
    servers.component.ts    
    <p *ngIf = "!setEnableFlag"> joker is back </p>

ngIf-else
    - use local reference #
    - the else part has to be in double quotes.
   
    <p *ngIf = "!setEnableFlag; else noServer"> joker is back </p>
    <ng-template #noServer>
        <p>joker is NOT back</p>
    </ng-template>

---

ngStyle
    <p[ngStyle] = "{ 'background-color': 'red' }"
    -OR-
    <p[ngStyle] = "{ backgroundColor: 'red' }"
    -OR-
    <p[ngStyle] = "{ backgroundColor: getColor() }"

    both syntaxes are valid.
   
---

ngFor : structural directive.
*ngFor

<app-server *ngFor="let server of servers"></app-server> where servers is an array.

==================================

D:\js\Ang2\proj2>npm init -y
D:\js\Ang2\proj2>ng new p2    
D:\js\Ang2\proj2>cd p2


v 61...
1)
1.1)
(Property) Binding to custom properties:- (In Angular 1 terms, we can think of it like broadcasting, but not using events)
- Top down communication .
- using custom properties.
- Root comp (app-comp) sends data.
    - child captures it using @Input() decorator.
       
Suppose we have app-comp --> server-component.
                                + any property (lets say serverName) in ServerComponent class
                                - such a property will NOT be available in app-component.
                                - this is a security feature, so that public properties are public within the SAME component class
                               
                                to make serverName available to app-component, do this:-
                               
                                server.component.ts
                                    import { ... , Input} from '@angular/core';
                                    ...
                                    @Input() serverName
                               
                                app.component.html
                                <app-server [serverName] = "..."></app-server>

Live eg.
                               
app.component.ts wants to send this data:-
    serverElements = [
    {type:'server1', name:'Testserver1', content:'Just server1'},
    {type:'server2', name:'Testserver2', content:'Just server2'},
    {type:'server3', name:'Testserver3', content:'Just server3'},
    {type:'server4', name:'Testserver4', content:'Just server4'}
                   ];

app.component.html is the "Port of Origin":-                               
    <app-server  *ngFor="let serverElement of serverElements"
      [element] = "serverElement">
      </app-server>
   
    - this requires an "element" type to be defined in the child component, so that the child can have access to it .
   
server.component.ts
    - complies and makes ready "element"
        import { Component, Input } from '@angular/core';
        ....
        @Input() element: {type:string, name:string, content:string};
       
        !!!VIMP!!!
            NOTE: that the signature of the "element" has to be same as that of the incoming data;
                    so if we change content: number, then the SPA will crash.
   
server.component.html
    - is the Port of Destination.
    - display root-component-data using "element"
   
    <p>123 {{element.type}}, {{element.name}}, {{element.content}} </p>

NOTE:- @Input() can be intercepted using:-
1. a setter (basically u define a set() and get() function)
2. ngOnChanges
    Refer https://angular.io/docs/ts/latest/cookbook/component-communication.html
   
---
eg. 1.2
(Property) Binding using alias to custom-properties:-
- ask outside / parent component to use alias ('srvrName') instead of the internal 'serverName'

                                server.component.ts                               
                                    import { ... , Input} from '@angular/core';
                                    ...
                                    @Input('srvrName') serverName
                               
                                app.component.html
                                    <app-server [srvrName] = "..."></app-server>
                                   
(see 1.1 before reading this:)
- we can encapsulate/hide "element" ; as it is an internal property of the child component.

server.component.ts
    @Input('xxx') element: {type:string, name:string, content:string};                                   

app.component.html will now have to send data (from parent to child) using the alias "xxx" instead of "element"
    <app-server  *ngFor="let serverElement of serverElements"
      [xxx] = "serverElement">
    </app-server>
   
---
DO ng serve in js1 folder:= PENDING
Binding to custom events:-
- we want to inform our parent comp. i.e. app-component that server was created.
- inside to outside. (child to parent commmunication).

app.component.html
    <app-server (serverCreated) = "onServerCreated($event)"> </app-server>
    - serverCreated is a custom-event,
    - $event will catch the data. its inbuilt
   
app.component.ts
    onServerCreated(serverData: {serverName: string, serverContent: string}) {
    ...
    }
   
server.component.html
    - create property i.e. serverCreated;
    serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();
        - allows u to emit ur own events
   
    this.serverCreated.emit({serverName: string, serverContent: string});

---

@Output: parent listening for child event
- The child component exposes an EventEmitter property with which it emits events when something happens

    @Output() onVoted = new EventEmitter<boolean>();
   
https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#parent-to-view-child

Parent and children communicate via a service
    import { Injectable } from '@angular/core';
    import { Subject }    from 'rxjs/Subject';   
        x = new Subject<string>();
        dstream$ = this.x.asObservable();
    import { Subscription }   from 'rxjs/Subscription';
   
---

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
creating a attribute directive:-

- create a new proj. and install bootstrap
- create a new folder in app/ and name it basic-highlight
    - basic-highlight.directive.ts
   
import {Directive} from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]', //we absolutely need this.  this is a unique name.
            //we have put [] to make it known that this will be used as an ATTRIBUTE.
})

export class BasicHighlightDirective{ 
}

Goal: to change background of the element in which this attribute will be used.
Sol.:- so, we need access to the element where this attribute will be used, right?

Angular gives us that access in the "ElementRef" class

- import {Directive, ElementRef} from '@angular/core';
-
export class BasicHighlightDirective{
  constructor(private elementRef: ElementRef){}
}

//private elementRef: ElementRef . What does this line do?
- creates a property called elementRef.
- assigns an instance of the ElementRef class to this property.
- note: we are writing this line in the constructor's param.

//its better to put all initialization in OnInit/ngOnInit //import {OnInit} ...

export class BasicHighlightDirective implements OnInit{
  constructor(private elementRef: ElementRef){}
  ngOnInit(){
    this.elementRef.nativeElement.style.backgroundColor = 'green';
  }
} //export class

---
we have created it. now we have to use it.
but angular doesnt scan for it. so we have to tell angular, it exists.

app.module.ts

import { BasicHighlightDirective } from './basic-highlight/basic-highlight.directive';
...
@ngModule({
    declarations:[ ..., BasicHighlightDirective]
})

Now angular knows, a new directive has been added.

---
app.component.html
<div appBasicHighlight>wassup Neo Anderson??? </div>

if u have a server (child component), u can use the same in that too.
the directive becomes available.

----
+++++++++++++++++++++++++++++++++++++++++++++++++

DOING better: Using Renderer to build a better ATTRIBUTE DIRECTIVE
- using renderer is a better approach; but y?

    its not a good practive to directly access ur elements.
        this.elementRef.nativeElement.style.backgroundColor = 'green';
    so how should be access our elements.

create better-highlight/ folder manually

D:\js\Ang2\proj2\p2\src\app\better-highlight>ng g d better-highlight
installing directive
  create src\app\better-highlight\better-highlight.directive.spec.ts
  create src\app\better-highlight\better-highlight.directive.ts
  update src\app\app.module.ts
   
Make sure to change the paths in app.module.ts  to include the better-highlight/ folder

better-highlight.directive.ts
    import { Directive, ElementRef, OnInit, Renderer2 } from '@angular/core';

    @Directive({
      selector: '[appBetterHighlight]'
    })

    export class BetterHighlightDirective implements OnInit{
      constructor(private elRef: ElementRef,
                  private renderer: Renderer2) { }

      ngOnInit(){
        this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
      }
    }

- checkout what are the other methods Renderer    
   
++++++++++++++++++++++++++++++++++++++++

v87. using HostListener to Listen to Host Events

- its not very interactive. Lets Give a blue background on mouse hover, else a transparent background

same example as above.
- Additionally we require HostListener

better-highlight.directive.ts
   import { Directive, ElementRef, OnInit, Renderer2, HostListener } from '@angular/core';
...
  @HostListener('mouseenter') mouseover(eventData: Event){
        this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
  }

  @HostListener('mouseleave') mouseleave(eventData: Event){
        this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'transparent');
  }

---

using HostBinding to bind to host properties

- even easier way (other than using the renderer).
- using the renderer is NOT wrong
- use HostBinding decorator.
- this way u can bind to any property ur element is sitting on.

better-highlight.directive.ts

    import { Directive, ElementRef, OnInit, Renderer2, HostListener, HostBinding } from '@angular/core';
    @Directive({
      selector: '[appBetterHighlight]'
    })
    export class BetterHighlightDirective implements OnInit{
    //  @HostBinding('style.backgroundColor') backgroundColor: string;
     @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';

      constructor(private elRef: ElementRef,
                  private renderer: Renderer2) { }
      ngOnInit(){
        //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
      }
      @HostListener('mouseenter') mouseover(eventData: Event){
            //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
            this.backgroundColor = 'blue';
      }
      @HostListener('mouseleave') mouseleave(eventData: Event){
            //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'transparent');
            this.backgroundColor = 'transparent';
      }
    }

---

this attribute-directive should be further customizable, using
- custom property binding (this is what we will use mostly!)
-OR-
- custom event binding (how to do this ???)

a) custom property binding on a custom-attribute-directive.
- we make use of @Input () decorator to declare variables.

better-highlight.directive.ts

    import { Input, Directive, ElementRef, OnInit, Renderer2, HostListener, HostBinding } from '@angular/core';

    @Directive({
      selector: '[appBetterHighlight]'
    })

    export class BetterHighlightDirective implements OnInit{
    @Input () defaultColor:string = 'transparent';
    @Input () highlightColor:string = 'blue';

    //  @HostBinding('style.backgroundColor') backgroundColor: string;
    // @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';
    @HostBinding('style.backgroundColor') backgroundColor: string = this.defaultColor;

      constructor(private elRef: ElementRef,
                  private renderer: Renderer2) { }

      ngOnInit(){
        //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
      }

      @HostListener('mouseenter') mouseover(eventData: Event){
            //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'blue');
            //this.backgroundColor = 'blue';
            this.backgroundColor = this.highlightColor;
      }

      @HostListener('mouseleave') mouseleave(eventData: Event){
            //this.renderer.setStyle(this.elRef.nativeElement, 'backgroundColor', 'transparent');
            //this.backgroundColor = 'transparent';
            this.backgroundColor = this.defaultColor;
      }

    }

app.component.html
    <div appBetterHighlight [defaultColor] = "'yellow'" [highlightColor] = "'red'">I am the one ! </div>
   
    Note:- values of defaultColor and highlightColor have to be string and hence within " '...' "
            Without the '' single quotes, this wont work
           
---

++++++++++++++++++++++++++++++++++++++++++++++++++++++

why does angular require * for structural directive:-
- behind the scenes, ng will transform them into something else.
    --
v 90

* basically means

<ng-template [ngIf] = "">
</ng-template>

---
++++++++++++++++++++++++++++++++++++++++++++++++++++++

Building a structural directive :

D:\js\Ang2\proj2\p2\src\app>mkdir unless

D:\js\Ang2\proj2\p2\src\app>cd unless

D:\js\Ang2\proj2\p2\src\app\unless>ng g d unless
installing directive
  create src\app\unless\unless.directive.spec.ts
  create src\app\unless\unless.directive.ts
  update src\app\app.module.ts

- we need to create a directive which is opposite of ngIf, i.e. unless

(skipped)

+++++++++++++++++++++++++++++++++++++++++++++++++++++

ngSwitch = structural Directive (instead of using several ngIfs)

<div [ngSwitch] = "value">
    <p *ngSwitchCase="5">Value is 5</p>
    <p *ngSwitchCase="15">Value is 15</p>
    <p *ngSwitchCase="25">Value is 25</p>
    <p *ngSwitchDefault>Value is Default</p>
</div>
 
++++++++++++++++++++++++++++++++++++++++++++++++++++
10. Services
10.1 Creating a Logging Service + 10.2 Injecting a Logging Service
10.3 Creating a Data Service
10.4. Hierarchial Injection
- All child components (of a parent component) will receive the SAME instance of the service automatically , if the service is defined with the component.
- All child components get the services tied to app.component.ts
- To introduce application-wide services, tie a service to app.module.ts
- child-components can override the service imported from the parent.
10.5
10.6 Injecting Services into Service
10.7

10.1

- Unlike a component/directive, we do NOT require a decorator to create a logging service
- creating a class itself means creating a service
- a service is created to implement the BL, so that the model can store data and supply it while rendering happens.


logging.service.ts

    export class LoggingService{
      logStatusChange(status:string){
        console.log('Status is : ' + status);
      }
    }

app.component.ts

    import { Component } from '@angular/core';
    import {LoggingService} from './logging.service';

    @Component({
      selector: 'app-root',
      templateUrl: './app.component.html',
      styleUrls: ['./app.component.css'],
      providers: [LoggingService]
    })
    export class AppComponent {
      title = 'app works!';

      constructor(private logger: LoggingService){
        this.logger.logStatusChange('offline');
      }

    } //AppComponent ends

---
10.3

accounts.service.ts

    export class AccountsService{
      userData = [
        {name: 'user1', age:20},
        {name: 'user2', age:30},
        {name: 'user3', age:40}
      ];
    } //AccountsService ends

app.component.ts
    - add AccountsService to the 'providers' array
   
constructor(private logger: LoggingService, private accountsData: AccountsService){
    this.logger.logStatusChange('offline');
    console.log(this.accountsData);
  }
   
---

10.6 injecting services into services

@Injectable
- ???

++++++++++++++++++++++++++++++++++++++++++++++++++++

11) Routes:


app.module.ts

    import {Routes, RouterModule} from '@angular/router';

    const appRoutes: Routes = [
      {    path:'server',    //note: this should not have /
          component: ServerComponent
      },
      {    path:'',    //note: this should not have /
          component: HomeComponent
      },
      ...
    ];

    ...
    ...
    imports:[
    ...
      RouterModule.forRoot(appRoutes)
    ],
   
app.component.html
    <router-outlet></router-outlet> and use routerLink instread of href in <a ... >

...   
<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <ul class="nav nav-tabs">

        <!-- <li role="presentation"><a href="/serv"> Server Comp </a> </li> -->
        <li role="presentation"><a routerLink="/server"> Server Comp </a> </li>
        <li role="presentation"><a routerLink="/">  Home Comp</a></li>

      </ul>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <router-outlet></router-outlet>

      <div appBetterHighlight [defaultColor] = "'yellow'" [highlightColor] = "'red'">I am the one ! </div>

    </div>
  </div>
</div>
...

---

- routerLink catches the click on <a-tag
- prevents the default behavior of (href/a-tag) to send a request to the server

---

<li role="presentation"><a [routerLink]="['/server']"> Server Comp </a> </li>
- we r using property binding on non-string data i.e. routes.

Also see:- https://www.barbarianmeetscoding.com/blog/2016/07/07/updating-your-angular-2-app-to-use-the-new-router/

---
v 116
Understanding Navigation Paths:-
- /server is preferred as it mentions relative paths in app.component
- if u miss / in child components, then clicking it means, getting absolute paths and ur app may break
- as a best practice, it is better to use / or ./ or ../server

---

routerLinkActive="active"

- use it when the /server tab does not look like its active.
- in bootstrap it is class="active", but in ng2 it becomes
routerLinkActive="active"

<li role="presentation" routerLinkActive="active" routeLinkActiveOptions="{exact: true}"><a routerLink="server"> Server Comp </a> </li>
<li role="presentation"><a routerLink="/" >  Home Comp</a></li>

---

Trigerring routes programmatically:- (using absolute paths eg. /server)
server.component.html
    <button class = "btn btn-primary" (click) = "onLoadServers()"> Goto Home Comp </button>

server.component.ts
    import {Router} from '@angular/router';
    ...
    constructor(private rtr: Router) { }
   
    ...
    onLoadServers(){
    //complex calculation
    //then navigate to another route
    this.rtr.navigate(['/']);
    }

Now when the server component is loaded, there will be a button to goto home.

---
Triggering routes programmatically (using relative path)

(skipped)

---

D:\js\Ang2\proj2\p3 
ng serve
Passing parameters to Routes

D:\js\Ang2\proj2\p3>ng g c server
installing component
  create src\app\server\server.component.css
  create src\app\server\server.component.html
  create src\app\server\server.component.spec.ts
  create src\app\server\server.component.ts
  update src\app\app.module.ts

D:\js\Ang2\proj2\p3>ng g c servers
installing component
  create src\app\servers\servers.component.css
  create src\app\servers\servers.component.html
  create src\app\servers\servers.component.spec.ts
  create src\app\servers\servers.component.ts
  update src\app\app.module.ts

D:\js\Ang2\proj2\p3>

D:\js\Ang2\proj2\p3>ng g c home
installing component
  create src\app\home\home.component.css
  create src\app\home\home.component.html
  create src\app\home\home.component.spec.ts
  create src\app\home\home.component.ts
  update src\app\app.module.ts
 
child components:-  
    - server
    - servers
    - home  

---

v121, 122 (skipped)

---
TODOS:-

http requests
import {Http} from '@angular/http';
           
            class PokemonComponent{
                constructor(private http: Http){
               
                    this.http
                        .get(`${this._baseUrl}/pokemon/?offset=${offset}&limit=${limit}`)
                          .map(response => response.json());

                }
            }
 
Services:-
    - component using a service
    - service using a service
        @Injectable
       
        ng generate service shared/services/pokemon
            - may use models, so create shared/model/ folder too.
            ng generate class shared/models/PokemonList
            ng generate class shared/models/PokemonEntry
               
        pokemon.service.ts
            import {Http} from '@angular/http';
           
            class PokemonComponent{
                constructor(private http: Http){
                }
            }
           
testing angular code.

    http://chariotsolutions.com/blog/post/testing-angular-2-0-x-services-http-jasmine-karma/
    How to bootstrap a test bed
    How to inject a service into the test bed
   
01    import {MarkdownService} from './markdown-service';
02
03    import {
04      TestBed, inject
05    } from '@angular/core/testing';
06   
07    describe('Markdown transformer service', () => {
08      beforeEach(() => {
09        TestBed.configureTestingModule({
10          providers: [
11            MarkdownService
12          ]
13        });
14      });
15   
16      it('Should translate markdown to HTML!',
17        inject([MarkdownService], (markdownService) => {
18   
19        expect(markdownService).toBeDefined();
20   
21        expect(markdownService.toHtml('hi'))
22                              .toContain('<p>hi</p>');
23      }) //inject ends
    ); //it ends
24    }); //describe ends   

To run: ng test

@HostListener/@HostBinding/renderer/etc.
@Output
view-layer & service-layer
    (would use models like /shared/models/someclass.ts)
    https://g00glen00b.be/services-angular-rxjs/
    While $http for AngularJS 1.5 returned promises, the Http service of Angular 2 doesn’t. In stead of returning promises, it will return observables.
    If you’re a fan of promises, no worries, an observable can be converted to a promise.
   
    Rxjs operators: take, timer, map, pluck, debounce
        if we take the debounce operator, this operator will make sure that only the last item will come through if many items succeed quickly.


    http://blog.brecht.io/A-scalable-angular2-architecture/
            State Management Layer (Redux/NgRx)
                Rest API Layer
                    Abstraction Layer (some sort of abstraction)
                        Presentation Layer (View Layer) DUMB COMPONENTS

            Dumb or smart components should NOT know there is a state management layer.
                Else these components would be tightly coupled with the state management layer.
               
                http://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/

---
+++++++++++++++++++++++++++++++++++++++++++++++

 rxjs
https://www.youtube.com/watch?v=ei7FsoXKPl0 

> Programming paradigm that works with asynchronous data streams
    >> Data streams can be created from :
        UI Events
        Http Requests
        File Systems
        Array like Objects
        Machine's Memory/cache
       
            >> Stream: A sequence of ongoing events ordered in time
                - emits a value, error and complete signal
                    - some events complete, thats when we get a completed-signal, else we dont get completed-signal
               
                >> The way to work with stream is by something called an "observable":
                    observable: are used to watch streams and emit functions when a value, error or completed-signal is returned
                                - can be subscribed to by an "observer".
                                    - there is no limit to how many subscriptions an observable can have.
                                - we can interact with data streams as any regular array
                               
                    Currently, we CAN'T use ES5 or ES6 to work with observables and data streams
                        Reactive extensions (Reactive X) is what allows us to do that.
                        Reactive X is a library for composing async programs by using observable sequences
                            - it provides us with a long list of operators, which allows us to filter, select , transform, combine and compose observables
                            - this library is not limited to JS. in python it is RxPY, RxPHP, c# etc.

===============================                           
Topics to cover:
> Examining data streams from events
> Creating observables from array-like Objects
> Creating observables from scratch
        > Filtering and tranforming observables
> Promises to observables
> Many helpful operators
> Error Handling
---------------------                           

Environment Setup:

www.reactivex.io
- see github repos
- if u r using cdns instead, get the rx.all.js file.

http://github.com/bradtraversy/rxjs_boiler (boiler plate for building rxjs applications with webpack and babel)
- download the zip . extract its contents in a folder called "rxjs_sandbox"
- goto rxjs_sandbox
    >> npm install (creates the node_modules/ folder)
    >> webpack -w (watch mode, creates the dist folder)
    >> open another command line
        - install live-server
        npm install live-server -g
        npm start
    >> http://127.0.0.1/8000    
       
       
--------------------
observables from events:

index.html, app.js
- add a button in index.html
- app.js

//creating an observable
const btn = $('#btn');
const btnStream$ = Rx.Observable.fromEvent(btn, 'click'); //the element to watch, the event on that element
       
//subscribing to an observable
//btnStream$.subscribe()
//takes 3 functions as params for the data/value in the stream, error in the stream, completion function
btnStream$.subscribe(
    function(e){
        console.log('clicked');
    },
    function(err){
        console.log(err);
    },
    function(){
        console.log('Completed');
    });       

    //only the first param function is mandatory, other 2 are optional
    // this coding style is using callbacks
   
---------------------

observables from arrays:

eg1.
const numbers = [10, 20, 30, 40];
const numbers$ = Rx.observable.from(numbers);

numbers$.subscribe(
    e =>{
        console.log(e);
    },
    err =>{
        console.log(err);
    },
    completed =>{
        console.log('completed');
    },
);

// here we are using arrow functions. u can use callbacks too.

eg2.
//for json
const posts = [
    {title1: 'this is title1', body1:'this is body 1'},
    {title2: 'this is title2', body2:'this is body 2'},
    {title3: 'this is title3', body3:'this is body 3'},   
];

and same code as numbers

eg.3 .

// u can use sets n maps as well

----------------------

creating an observable from scratch:

const source$ = new Rx.Observable(observer => {
        console.log('creating an observable from scratch');
       
        //emitting a value from the stream
        observer.next("Hello world"); // this is a decorator function
        observer.next("Emiting another data/value");
       
        //to show u that this is a stream and is constantly open, lets do:
        setTimeout(() => {
            observer.next("Yet another value");
            }, 3000); //so the first 2 values wiill emit, then there will be a 3 sec pause and then this value will be emitted.
           
        //notice the completed function never fires, because we havent ended our stream
        // to do this add : observer.complete(); in the setTimeout() method's last line.
            // if u put observer.complete() outside the setTimeout() then it would complete before the setTimeout() is executed.
           
        //for errors, use observer.error(new Error('Some error happened')).   
    });

//rest is same as above. the subscription part i mean
//to capture errors during subscription, use source$.catch(err=> Rx.observable.of(err))
                                                    .subscribe() syntax.

-------------------------

Observable from a promise:

Promise: represents the eventual result of an async operation .

const myPromise = new Promise((resolve, reject) => {
    console.log ('creating Promise');
    setTimeout(()=>{
        resolve('Hellow from Promise');
    }, 3000);    //setTimeout make an async call; we can also use $http.get in ang.1.
});

const source$ = Rx.observable.fromPromise(myPromise); //creating an observable
source$.subscribe(x => {console.log(x);},
);
//we r subscribing to that promise.

....
....

--------------------------

Operators: Interval, Timer & Range

const source$ = Rx.observable.interval(100)
                             .take(5); //take allows to complete.

const source$ = Rx.observable.timer(5000, 2000)
                             .take(5); //take allows to complete.

const source$ = Rx.observable.timer(25, 100);


Operators: map, Pluck

    const source$ = Rx.observable.interval(100)
                             .take(5)
                             .map(v => v*v)  //sinceonly one line {} is NOT required.
                             ;
                             
                             
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  


 Lodash
Array, Object, Collection, Function, Util, Date,
Number, String, Seq, Properties, Methods, Lang, Math
---

1. Array

chunk, compact, concat, difference, drop, fill, findIndex, flatten, flattenDeep, fromPairs, head, indexOf, intersection,
join, last, lastIndexOf, nth, pull, pullAll, remove, reverse, slice, sortedIndex, tail, take, union, uniq, unzip, without,
zip, zipObject, zipObjectDeep, zipWith

2. Object
assign, assignIn, at, create, defaults, entries -> toPairs, entriesIn -> toPairsIn,
extend, extendWith, findKey, findLastKey, forIn, forInRight, forOwn, functions, functionsIn,
get, has, hasIn, invert, invertBy, invoke, keys, keysIn, values, valuesIn, mapKeys, mapValues, omit, omitBy,
pick, pickBy, result, set, transform, unset,update,

3. Collection

countBy, forEach, every, filter, find, findLast, flatMap, flatMapDeep, forEach, forEachRight,
groupBy, includes, keyBy, map, orderBy, partition, reduce, reduceRight, reject, sample, shuffle, size, some, sortBy.

4. Function

after, before, ary, bind, bindKey, curry, debounce, defer, delay, flip, memoize, negate, once, overArgs, partial, rearg, rest,
spread,throttle, wrap, unary.

5. Util
attempt, bindAll, cond, conforms, constant, defaultTo, flow, identity, iteratee, matches, method, methodOf, mixin, noConflict, noop,
nthArg, over, overEvery, overSome, property, propertyOf, range, uniqueId, etc.

6. Date
now

7. Number
refer online

8. String
refer online

9. Seq
refer online

10. Properties
refer online

11. Methods
refer online

12. Lang 13. Math
skipped.

++++++++++++++++++++++++++++++++++++++++++++++++++++  

 typescript: (rough work)
type alias:- (v13)

type PlayerArray = Array<string>; //this will be an array, but members should be string only
let players: PlayerArray = ['Sachin', 'kapil']; //try adding a number here, it should croak.
console.log(players);

---

union types:- (v14) (using |)
- Lets say, we want the player Array to not only store string but also numbers.
| number , makes it flexible now.

eg.1
type PlayerArray = Array<string| number>;
let players: PlayerArray = ['...'];
let player_numbers: PlayerArray = [10, 20, 30];

console.log(player_numbers);

eg.2
var x :string[]; //we can also write this as var x: string[] | string; //so x can be a string array or a string in itself
var x: string[] | string;

x = ['' ...];
x = '...';


Q. Can u write type aliases without using = (equal to) ??
---
while
for - in
for - of (ES6, requires a presence of a iterable. i.e. Symbol.itera* property on it. )

for (let player in players){ // gives index ONLY if players is an array
}

for (let player of players){ // gives values ONLY if players is an array
}

Q. What happens if it is an object instead of an array ??

---

typescript functions

    function xyz(p1:number){
    }
   
    function xyz(p1:number):string{ //return type HAS TO BE A STRING
        return 'xyz'; //if u remove this line it should croak
    }

---

TS function arguments

   
    function xyz(p1:number, p2:number, p3?:string){ //notice where the question mark is .
     }   
   
---

v23.


function expression in typescript

1) Separating method signature and definition.
method 1.1
let func = (p1:number, p2: number) => string; //here => string means that is the return value.
func = function(p1:number, p2: number){
...
return 'abc';
}

- OR-

1.2 (try to avoid this)
let func = (p1:number, p2: number); //here => string means that is the return value.
func = function(p1:number, p2: number):string {
...
return 'abc'; ///
}

2)
method 2: combining the method signature and definition
let func = (p1:number, p2: number) => string = function (p1:number, p2: number) { ... }


---
 GENERICS

//why is generics required?
//1. Lets understand an identity function: its a function,
  // which returns AS IS anything that was passed to it. like an echo command.
  //1.1 identity function with number datatype.
  /*
  function identity(arg: number): number {
    return arg;
  }
  THis is not generic, so lets use any instead.
  1.2
  function identity(arg: any): any {
    return arg;
  }
  However, here we do not know what type comes in and what type goes out.
  So, the only way to do these for all types is to write 1.1. for all data types in TS other than any.
  Which is cumbersome.
  Generics solves this problem

  */

 1.1.1 //no return type yet.
 function identity(p1:number){
 }
 identity(10);
 if u add : number as return value, TS expects u to put a return value in it too
 function identity(p1:number):number{
   console.log(p1);
   return p1;
 }
 identity(10);

---

 1.3
 function identity<T>(p1:T): T{
   console.log(p1);
   return p1;
 }
 identity(100);

 Note:- <T> is after the function name and before the params begin
 T is applied, wherever necessary like, args, return type of function.

 function identity<T>(p1:T){ //works. no return type mentioned
 function identity<T>(p1){ //works. no return type and no type specified for param.

--- 
1.4 with function expressions

let identity2 = function<T>(p2:T):T{
  console.log(p2);
  return p2;
}
identity2('hello');

For FE, think of it this way: if u know 1.3,
only move the function name to LHS and everything else remains on RHS (from 1.3)
Another eg.
function add<T>(p1: T, p2: :T) : T{ ... }
let add = function <T>(p1: T, p2: :T) : T{ ...}

---

1.5 understanding return in TS Generics.

> in JS & TS if return is NOT mentioned, it is implied as undefined. (Remember: All JS functions return something. )
> in TS Generics if return is NOT mentioned (for corr. declaration), it errors.

//Lets write a function using generics:-
//Sol.1. using func declaration
function display<T>(p1:T, p2:T):T{
  console.log(p1, p2);
  return ;            //works
  // return undefined; //works; same as above return;
  // return p1;        // works
  // return p2;        //works
  //return null;       //works

    //default in JS; if return is NOT specified.
    //But when using generics, return is necessary if :T return is expected.
  //return 1;      //error. 1 is not assignable to T
  //return true;   //error. boolean/string is not assignable to T
  //return p1 + p2; //error. operator + cannot be applied to types T and T
}

// so, u cannot use operators, u cannot return number/boolean/string/objs/arrays

calling styles:-
style#1 explicit type calls
    display<number>(10, 20); //works
        NOTE:- display<number>('10', 20); //ERROR. '10' wont work as its a string
    display<string>('hello', 'panda'); //works

style#2 implied type calls. This is called "type argument inference" which is same as "type inference" for variables
(when vars types are not explicitly defined).
    display(10, 20); //works
    display('hello', 'world'); //works.
//if u have LHS in above func. calls, u will get undefined. bcoz return; is same as return undefined;

1.5.1
FE would be
let display = function <T>(p1:T, p2:T):T{ ... }
//same return rules apply.

---

1.6 handling arrays is tricky.

//2 params can be confusing, lets switch to one params
let display = function<T>(p1:T[]):T[]{
  //p1.length will give an error, bcoz length is a property of only arrays.
  //if u r using arrays but a [] next to T; so that it becomes T[] for param and return type
  console.log(p1);
  return p1;
}

let a1 = [1,2,3,4,5];
display(a1);

//p2 can be made optional using ?
let display = function<T>(p1:T[], p2?):T[]{ ... }

//Syntax changes, if u use Array obj. of JS.
let display = function<T>(p1:Array<T>, p2?):Array<T>{ ... }
Note:- how T[] got changed to Array<T> in param and return type.

Till NOW, we have see how generic identity functions work with a range of types
---
---

2. Generic Types / Generic Interfaces (of function themselves)

2.1. lets say we wanted to create a new type called myidentity which is a copy of "identity" (function)
function identity<T>(p1:T):T{
  console.log(p1);
  return; //undefined as expected.
}

//1. let myidentity = identity;               //function identity. Notice = on LHS
  //if u use this syntax to create a new method, u cannot enforce params/return values

//2.1
   let myidentity: <T>(p1:T) => T = identity; //function identity. Notice : on LHS
//2.2
// let myidentity: <U>(p1:U) => U = identity;    //function identity.
// we use these syntaxes to enforce params n returns.
  //console.log(myidentity<string>('helloxxx'), myidentity<number>(100) );

//3. DONT DO these errors.
//let myidentity: <U>(p1:U):U = identity;     //Error: => expected. => need for return type
// let myidentity: <T>(p1:T) => T;            //undefined. = identity is required on RHS

---
2.2



GENERICS ENDS
--- 

interfaces
- interfaces are a contract between ur objects and data.
- they set the rules of how data should be used.
- u r setting rules that the rest of the code has to follow.

interface user{
    first: string,
    email: string,
    last: string
};

function profile(user: User) {
}

function profile(user: User): string {
}

---
---

class Person { //Note: no () or no =
    constructor(public name:string){ //if public is not written, it becomes public by default.
        this.companyProfile = name;
    }   
}

class Student extends Person {
    constructor(public name:age){
        super(name); //get me name property from the parent class.
            //Q. what does super() do ??
    }
}

Multiple inheritance:-
- is not directly supported in TS.
- Indirectly can be achieved using:- This is called "multiple inheritance of implementation"
    -- MIXINS:- https://www.stevefenton.co.uk/2014/02/TypeScript-Mixins-Part-One/
    -- INTERFACES:- https://stackoverflow.com/questions/34513594/multiple-class-inheritance-in-typescript
        Java 8 supports multiple inheritance of implementation via Default Methods
   
---

 eg. 3.
class Person {
  name;
  constructor(){}
  setname(n1){this.name = n1}
  getname(){return this.name}

  static designation = 'Mr.';
  static getPerson = () => { return 'Mr. Person'}; //these do not have access to "this", which is possible in instance-methods
}

console.log(Person.getPerson());
let p1 = new Person;
p1.setname('jack bauer');
console.log(p1.getname());

---

eg.4.

//Abstract classes:-
//direct instantiation is disallowed.
//sub-class should only inherit
abstract class AbstractPerson{
  name: string;
  //setname(n1:any): void {}; //works. //{} is required.
  setname(n1:any): void { //this is called "implementation details of its members"
    console.log('inside setname'); //never prints
  };
  abstract sneezes(): void;
  //abstract classes can have abstract methods.
  //use it if u dun want to give implementation.
  //use it if u want to make it mandatory for sub-classes to implement sneezes()
  //access modifiers are allowed on abstract methods.
  //they r similar to interface methods, except u need to add "abstract" keyword
  protected abstract cries(): void;
}

class Person extends AbstractPerson{
  name;
  constructor(){
      super();
  }

  setname(n1){this.name = n1}
  getname(){return this.name}

  static designation = 'Mr.';
  static getPerson = () => { return 'Mr. Person'};

  sneezes(){ console.log('person sneezes'); }
  cries(){ console.log ('person cries');}
}

console.log(Person.getPerson());
let p1 = new Person;
p1.setname('jack bauer');
console.log(p1.getname());

console.log(p1.cries(), p1.sneezes());

---
eg.5.

interfaces can extend classes, because class also creates a type:-
class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};



---
see v32 if required again.
- TOPIC: connecting: loosely and tightly  interfaces with classes
---

namespaces:-
- used to be called modules in earlier versions of TS.
- it gives ur program ability to nest items and essentially protect the naming of things.
like one class name overwriting another class name
- they can be kept together or they can be kept in separate files.
- export may not be necessary in the below examples.

namespace Blog{
    export interface XPost{
    }
    export class Post implements XPost{
    }
}

namespace Blog2{
    export interface XPost{
    }
   
    export class Post implements XPost{ //classes have same name as Blog-namespace
    }
}

/* earlier
var blogPost = new Post({
    title: "",
    blog: ""
});
*/

var blogPost = new Blog.Post({
    title: "",
    blog: ""
});

Q. is @ in @angular/core a namespace ?
A. No. Its a scope. Scope is an npm way of segregating namespaces.
Scope in npm is what Namespace is in TS.

"All of the packages are now distributed under the @angular npm scope. >This changes how Angular is installed via npm and how you import the code."
"Scopes are like namespaces for npm modules. If a package's name begins >with @, then it is a scoped package. The scope is everything in between >the @ and the slash."

https://stackoverflow.com/questions/37165779/what-is-angular-in-angular-2

---

Callbacks in TS.
- what is the syntax when the argument is a function
- we will see that

VIMP!!!
function xyz(p1:() => void){
    c.log("header");
    p1();
    c.log("sidebar");
    c.log("footter");
}
- p1 is a parameter
- its a call back function and hence ()
- its return type is void, so use => void .

Expected output:-
header, sidebar, footer
p1's output.

This means that the callback was executed asynchronously.

Q. is this TS feature ? or is this JS feature?
try this in JS as well .

---

v37 , 38

Configuring TS to work with promises.
- it does not come with promises
- tsconfig.json
target: "es6" //es6-promise and es6-collections can be installed

module: "amd"
Asynchronous Module Definition (AMD) (fork from commonJS, makers of AMD were not satisfied with CommonJS)

Promises:

let funcexp = function(p1:string): Promise<{p1: string}> {
}

:Promise is the return type
:Promise<{p1: string}> is returning with a status of p1 which will be a string

Q. Is <{p1: string}> really required? Try this plz

---

TS Decorators.

configuration:-
- make 3 changes to tsconfig.json
target:"ES5",
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
}

- we need these to get decorators working .

- decorator has to return a function.

class Post {
    @processOne()
    @processTwo()
   
    somefunction(){
    }
}

function processOne(){
    c.log('processOne has run');
   
    //below is what u require to convert processOne() from a normal function to a decorator.
   
    return function(target, propertyKey: string, descriptor: PropertyDescriptor){ //target, propertyKey and descriptor
        c.log("process one has been called")
    }
}

function processTwo(){
    c.log('processTwo has run');
   
    //below is what u require to convert processOne() from a normal function to a decorator.
   
    return function(target, propertyKey: string, descriptor: PropertyDescriptor){ //target, propertyKey and descriptor
        c.log("process Two has been called")
    }
}

u can now run this .ts file. the code executes.
O/p:-
processOne has run
processTwo has run
process Two has been called
process One has been called

Note:-
- we never instantiated Class, but still the code got executed.
- they are called @runtime and not on the obj. instantiation
    - u can still do obj instantiation and it would work same.
   
- very popular to build role/access structures like is this guy authorised to do this or not .
   
---
v40
class Decorators in TS :-

eg.1.
@detailedLog('billing')
class AccountsPayable{
    constructor(){}
}

function detailedLog(p1: string){
    if (p1 === 'billing'){
        c.log('working in the billing department');
        return function(target: Object){}; //see who different class decorators are from the method decorator.
    }
    else{
        return function(target: Object){};
    }
}

var post = new AccountsPayable;

- class decorators
// needs a target mandatory parameter


eg.2.

@detailedLog('billing')
class AccountsPayable{
    constructor(){}
}

@detailedLog('warehouse')
class ProductManager{
    constructor(){}
}

function detailedLog(p1: string){
    if (p1 === 'billing'){
        c.log('working in the billing department');
        return function(target: Object){}; //see who different class decorators are from the method decorator.
    }
    else{
        return function(target: Object){};
    }
}

var post = new AccountsPayable; //prints: working in the billing department
var post = new ProjectManager; //does not print anything.    
   
So, here, we have moved our logging mechanism to be with another class (ProductManager) which does NOT have a logging mechanism of its own.'

---

v 41

method decorators in TS:

eg.1.
@detailedLog('billing')
class AccountsPayable{
    constructor(){}
   
    @admin
    deleteAccount(){
        c.log('deleting account');
    }
}

function detailedLog(p1: string){
    if (p1 === 'billing'){
        c.log('working in the billing department');
        return function(target: Object){}; //see who different class decorators are from the method decorator.
    }
    else{
        return function(target: Object){};
    }
}


function admin(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) : any {
    c.log('doing admin check');
    return descriptor;
}

var post = new AccountsPayable;

O/p:
Doing admin check    //method decorator runs before the class decorator
Working in the billing department    //class decorator
deleting account     //critical action item

this is how u implement a permission structure

Q. What is the difference between TypedPropertyDescriptor and PropertyDescriptor ?

---

next to do:

http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-ii
http://blog.wolksoftware.com/decorators-reflection-javascript-typescript

next topics:
- property decorator
- atscript
- typescript
   
---

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rx_extra (rxjs a new paradigm shift) 

<<<< some screenshots # 3 >>>>

2env. are required:-
- console to watch the build of both client n server code
- http (live-server) to c code on browser

Any code changes (on server/client) should update both envs.

---
node -v
v6.10.3
npm install npm -g
node -v
v6.10.3
node latest version

npm init -y

---
https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md
If you've previously installed gulp globally, run npm rm --global gulp before following these instructions.
Install the gulp command
    npm install --global gulp-cli
Install gulp in your devDependencies
Run this command in your project directory:
    npm install --save-dev gulp

create gulpfile.js
    var gulp = require('gulp');

    gulp.task('default', function() {
      // place code for your default task here
    });  
  
D:\js\Ang2\proj2\rx_extra>gulp
[11:04:19] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[11:04:19] Starting 'default'...
[11:04:19] Finished 'default' after 93 µs

D:\js\Ang2\proj2\rx_extra>gulp -v
[11:04:26] CLI version 1.3.0
[11:04:26] Local version 3.9.1

---
  
npm install gulpjs/gulp#4.0  gulp-load-plugins  gulp-babel  babel-preset-es2015  browserify  watchify  babelify  gulp-cached  nodemon  vinyl-source-stream --save-dev

gulpjs/gulp#4.0
- not yet released. 3.9.1 was latest . that syntax is installing from their git repo.
- this repo @ this branch, thats what that syntax means

gulp-load-plugins
gulp-babel
- to compile server side code
babel-preset-es2015
browserify
- to compile client side code
- for client side package management
watchify
babelify
gulp-cached
nodemon
- node monitor, monitors a directory. if anything changes, it runs a js file.
vinyl-source-stream
- to allow browserify to work with gulp

---

npm install jquery lodash moment colour --save

colour
- allows to change color of our console output

---
reactive extensions

npm install rxjs --save

rxjs
- is ver. 5 of reactive extensions for js

---

--save-dev saves semver spec into "devDependencies" array in your package descriptor file,
--save saves it into "dependencies" instead.

we do NOT require devDependencies (like karma, etc.) to run the app in its normal state, so it is a --save-dev type dependency.
for the app to run in its normal state, we require ONLY dependencies, so --save is required.

---

create src-server/
& build/ folder

src-server
    - examples will go
  
build
    - for build purposes
---
create ex_00.js
    import moment from 'moment';
    console.log (moment().format());  

Modify gulpfile.js
    var gulp = require('gulp')
      $ = require("gulp-load-plugins")(),
      source = require("vinyl-source-stream"),
      browserify = require("browserify"),
      watchify = require("watchify"),
      babelify = require("babelify");

    gulp.task("scripts:server", function() {
        // place code for your default task here
        return gulp.src("./src-server/**/*.js")
          .pipe($.babel())
          .pipe(gulp.dest("./build"));
      });

    gulp.task('watch:scripts:server', function() {
        // place code for your default task here
        return gulp.watch("./src-server/**/*.js", gulp.series("scripts:server"));
      });


    gulp.task('default', function() {
      // place code for your default task here
    });
  
  
D:\js\Ang2\proj2\rx_extra>gulp scripts:server
[11:24:15] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[11:24:15] Starting 'scripts:server'...
[11:24:15] Finished 'scripts:server' after 129 ms  
  
check build/ folder , we did NOT get a tranformation to es6/es2015.
in order to get the transformation, we need to have a .babelrc file (same folder as gulpfile.js)

.babelrc
    {
      "presets":["es2015"]
    }

D:\js\Ang2\proj2\rx_extra>gulp scripts:server
[11:30:01] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[11:30:01] Starting 'scripts:server'...
[11:30:01] Finished 'scripts:server' after 327 ms

(it took a little longer)
now look in build/ex_00.js and its now transformed es6 code to es5 code.

now lets launch the server
D:\js\Ang2\proj2\rx_extra>gulp watch:scripts:server
[11:34:21] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[11:34:21] Starting 'watch:scripts:server'...


Note:- if u add
console.log('hello');
in src-server/ex_00.js, its corresponding build/-file will be auto updated.

---
(we r going to keep nodemon out of gulp)
nodemon's binary is at this location: node_modules/.bin/nodemon
we do not want to type it every time, so we need some like "npm run nodemon"

    - for this we will need to edit the scripts:[] in package.json
        scripts: {
            "nodemon" (alias) : "nodemon" (thing to execute)
        }
        but we want to run nodemon only if any file changes
        scripts: {
            "nodemon" : "nodemon --watch build"
        }

to test this:-

open new cmd-prompt
npm run nodemon build/ex_00

    D:\js\Ang2\proj2\rx_extra>npm run nodemon build/ex_00
    > rx_extra@1.0.0 nodemon D:\js\Ang2\proj2\rx_extra
    > nodemon --watch build "build/ex_00"
    [nodemon] 1.11.0
    [nodemon] to restart at any time, enter `rs`
    [nodemon] watching: D:\js\Ang2\proj2\rx_extra\build/**/*
    [nodemon] starting `node build/ex_00 index.js`
    2017-05-30T11:43:40+05:30
    hello
    [nodemon] clean exit - waiting for changes before restart      
  
if u change src-server/ex_00, the output will be automatically available in this console window  

---
did not do this:
.pipe($.cached("server"))
in below task:-
gulp.task("scripts:server", function() {
    // place code for your default task here
    return gulp.src("./src-server/**/*.js")
      .pipe($.cached("server"))
      .pipe($.babel())
      .pipe(gulp.dest("./build"));
  });
 
 
did this though:

earlier:-
    gulp.task('watch:scripts:server', function() {
        // place code for your default task here
        return gulp.watch("./src-server/**/*.js", gulp.series("scripts:server"));
      });

now:- //running scripts:server task before watch:scripts:server task
gulp.task('watch:scripts:server', gulp.series("scripts:server", function() {
    // place code for your default task here
    return gulp.watch("./src-server/**/*.js", gulp.series("scripts:server"));
  })
  );
 
restart gulp:
gulp watch:scripts:server
&
npm run nodemon build/ex_00
==========================

Setting up the client:- (little bit complicated)

- basic http server installed globally
- browserify, watchify and babelify to compile our client examples
 
create public/
       public/build/
        - compile client code (the code to run on the browser)
       src-client/
        - for things i want to run on the browser
     
> use gulp-watch to check files that exist in gulp-client/
> any new files that come in we r going to launch gulp watchify      

in gulpfile.js
- lets create helper functions

https://spapas.github.io/2015/05/27/using-browserify-watchify/
Browserify
With browserify you create a single main.js for each of your HTML pages and in it you declare its requirements using require. You’ll then pass your main.js through browserify and it will create a single file (e.g bundle.js) that contains all the requirements (of course each requirement could have other requirements - they’ll be automatically also included in the resulting .js file). That’s the only file you need to put to the script tag of your HTML!

browserify not only concatenates your javascript libraries to a single bundle but can also transform your coffesscript, typescript, jsx etc files to javascrpt and then also add them to the bundle. This is possible through a concept called transforms — there are a lot of transforms that you can use.

Watchify
Using watchify, you can watch your main.js for changes (the changes may also be in the files included from main.js) and automatically generate the resulting bundle.js so that you’ll just need to hit F5 to refresh and get the new version!

---

Made lot of changes in gulpfile.js. steps are marked from 1 to 4.
gulpfile.js:-

        "use strict";

        var gulp = require('gulp'),
          $ = require("gulp-load-plugins")(),
          source = require("vinyl-source-stream"),
          browserify = require("browserify"),
          watchify = require("watchify"),
          babelify = require("babelify"),
          path = require("path"),
          fs = require("fs");

        gulp.task("scripts:server", function() {
            // place code for your default task here
            return gulp.src("./src-server/**/*.js")
              .pipe($.babel())
              .pipe(gulp.dest("./build"));
          });


        //gulp.task('watch:scripts:server', function() {
        //    // place code for your default task here
        //    return gulp.watch("./src-server/**/*.js", gulp.series("scripts:server"));
        //  });

        //running scripts:server task before watch:scripts:server task
        gulp.task('watch:scripts:server', gulp.series("scripts:server", function() {
            // place code for your default task here
            return gulp.watch("./src-server/**/*.js", gulp.series("scripts:server"));
          })
          );

        //step 3.
        //pre-requisite, make sure fs is require-d.
        gulp.task('watch:scripts:client', () => {
            //enumerate all files in our directory
            const files = fs.readdirSync('./src-client'); //bad way to do it, but we dont care.
            for (let i = 0; i< files.length; i++){
              const file = files[i];
              if (path.extname(file) !== '.js')
                continue; //moveon

                //else if extension is .js
                initBundlerWatch(path.join("src-client", file));
            }//for ends

            //watch for any new files
            return gulp.watch("./src-client/**/*.js") //if any file in client changes,
              .on ("change", initBundlerWatch);
        }); //task ends

        //step 4.
        gulp.task('watch:scripts', gulp.parallel(
          "watch:scripts:client",
          "watch:scripts:server" //dont put comma here, else gulp nukes
        ));

        //gulp.task('default', function() {
        //  // place code for your default task here
        //});

        //step 2.
        //browserify => for module loading; babel would not do it.
        let bundlers = {};

        function initBundlerWatch(file){ //helper function
          if (bundlers.hasOwnProperty(file)){
            return; //shortcircuit
          }

          const bundler = createBundler(file); //bundler is an instance of browserify
          bundlers[file] = bundler; //helps in preventing multiple builds and it make faster

          const watcher = watchify(bundler);
          const filename = path.basename(file); //import "path" in require above.
          //basename is the filename

          //internal function
            function bundle(){
              return bundler  //bundler is instance of browserify
                .bundle()
                .on("error", error => console.error(error)) //printout our errors
                .pipe(source(filename)) //browserify doesnt create files with names,
                //but inorder to work with gulp, a filename is reqd.
                .pipe(gulp.dest("./public/build")); //final output folder
            } //bundle ends

          //hook into watchify events, before calling bundle()
          //update/time are events of watchify
          watcher.on("update", bundle); //if any file changes, rebundle.
          watcher.on("time", time => console.log(`Built client in ${time} ms`));

          bundle();
        }//initBundlerWatch ends

        //step 1.
        function createBundler(file){
          const bundler = browserify(file); //instance of browserify
          bundler.transform(babelify); //do babel transformation of es6 code to es5 code.
          return bundler; //return the browserify-instance
        }

        //public ==> html files
        //src-client ==> public/build/ will be output folder for client code
        //src-server ==> build/  will be output folder for server code

D:\js\Ang2\proj2\rx_extra>gulp watch:scripts:client
[13:02:18] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[13:02:18] Starting 'watch:scripts:client'...

lets write something in src-client/ex_00.js

D:\js\Ang2\proj2\rx_extra>gulp watch:scripts:client
[13:07:41] Using gulpfile D:\js\Ang2\proj2\rx_extra\gulpfile.js
[13:07:41] Starting 'watch:scripts:client'...
Built client in 750 ms

So, u can see client was built in 750 ms.
output file is in public/build/ex_00.js
    and u can see it is transformed.
  
if u change src-client/ex_00.js, the build will run again and the public/build/ex_00.js file will be updated.  
gulp watch:scripts
    -- will now launch both tasks "watch:scripts:client" and "watch:scripts:server" in parallel.
    -- so if u edit src-server/ex_00.js or src-client/ex_oo.js, the build will automatically run.
(it will be runnning, so let the cmd run )  
---
lets run a http server (globally)
npm list -g
npm list -g grunt
    (i know grunt is not installed on my system)
    D:\js\Ang2\proj2\rx_extra>npm list -g grunt
    C:\Users\Jenson.Samuel\AppData\Roaming\npm
    `-- (empty)
npm list -g live-server
    (looks like i already have live-server installed globally, so no need to do : npm install -g live-server)
    D:\js\Ang2\proj2\rx_extra>npm list -g live-server
    C:\Users\Jenson.Samuel\AppData\Roaming\npm
    `-- live-server@1.2.0
 
Note:- live-server allows us to "serve" any directory.
just cd into a dir/
and run "live-server"

D:\js\Ang2\proj2\rx_extra\public>live-server
Serving "D:\js\Ang2\proj2\rx_extra\public" at http://127.0.0.1:8080
Ready for changes
GET /favicon.ico 404 3.796 ms - 24
GET /favicon.ico 404 1.512 ms - 24

and browser opens automatically @ http://127.0.0.1:8080/

---

so, public/ will be for html files
so, ex_00.html 
 
src_client/ex_00.js
    import moment from 'moment';
    import $$ from 'jquery';
    $$("body").text(moment().format());
    console.log('kill the schmuc joker');

public/ex_00.html
    <!DOCTYPE html>

    <html>
      <head>
      </head>
      <body>
        <h1>example 00 </h1>
        <script src="/build/ex_00.js"></script>
      </body>
    </html>

cd public/
live-server
  
see   http://127.0.0.1:8080/
click build/
click ex_oo.html (click this html file) http://127.0.0.1:8080/ex_00.html

After all this, we can now see that we have a tight-feedback loop.
we can see all client and server changes as we do it and also see it on live-server

2 consoles + 1 browser (pointing to localhost)
- gulp watch:scripts
D:\js\Ang2\proj2\rx_extra>gulp watch:scripts
- live-server
D:\js\Ang2\proj2\rx_extra\public>live-server

src-server/ex_00.js    ==> build/ex_00.js
src-client/ex_00.js    ==> public/build/ex_00.js
html file is in public/ex_00.html

gulp watch:scripts
npm run nodemon build/ex_01_observables.js
live-server

---
v 7 using the playground.
(skipped)
---

https://stackoverflow.com/questions/30794356/why-do-i-have-to-use-vinyl-source-stream-with-gulp
vinyl-source-stream
A vinyl stream is a Virtual file format, and it is fundamental for Gulp. Thanks to this vinyl streams Gulp doesn't need to write a temporal file between different transformations. And this is one of the main advantages it have over Grunt.

---
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

src-server/

D:\js\Ang2\proj2\rx_extra>gulp watch:scripts
D:\js\Ang2\proj2\rx_extra>npm run nodemon build/ex_01_observables.js
D:\js\Ang2\proj2\rx_extra\public>live-server

eg.1.
src-server/ex_01_observables.js
        import Rx from 'rxjs/Rx';
        let simple$ = new Rx.Observable(observer => {    //$ is suffixed to indicate an observable.
          setTimeout(() => {
                              observer.next('val1');
                              observer.next('val2');
                              observer.complete();
                            }, 3000);
        });
        console.log(typeof simple$); //object
        console.log('xxxyyzz');
        simple$.subscribe((e) => {console.log(e);},                    //next
                          (err)=>{console.log(err);},                //2ndparam is optional
                          ()=>{console.log('completed signal');}    //3rdparam is optional
                         );
        
NOTE: until subscribe is called, nothing is outputted.
- observables are lazy; they dont do anything until subscription.
- observable is a generator function

We can also write:-
        simple$.subscribe( e => {console.log(e);},                    //next
                           err =>{console.log(err);},                //2ndparam is optional
                           ()=>{console.log('completed signal');}    //3rdparam is optional
                         );

 
eg.2. 
        import Rx from 'rxjs/Rx';

        let simple$ = new Rx.Observable(observer => {
          setTimeout(() => {
                              observer.next('val1');
                              observer.next('val2');

                            }, 3000);

          setTimeout(()=>{observer.error(new Error('Jack Sparrow is dead'));}, 5000);
          //observer.complete();
        });

        console.log(typeof simple$); //object
        console.log('xxxyyzz');

        simple$.subscribe((e) => {console.log(e);},
                          (err)=>{console.log(err);},
                          ()=>{console.log('completed signal');});

 
---

the observer being mentioned in above examples is actually an emitter.
its not the observer. wtf ! name ur variables right.
an emitter should be able to emit values using .next(<value>)

eg. 1.1.

import Rx from 'rxjs/Rx';

//our observable is a generator.
//typeof (simple$) is object . simple$ is an observable.
let simple$ = new Rx.Observable(emitter => {
  emitter.next('this is val2');
  emitter.next('this is val3');
  emitter.complete();
});    //<<<==== name ur variables right. use emitter than observer

simple$.subscribe(
  (value) => {console.log(value);},
  (err) => {}, //has to be comma separated since these r params
  () => {}
);

---
eg. 1.2 where to place emitter.complete()

import Rx from 'rxjs/Rx';

//our observable is a generator.
//typeof (simple$) is object . simple$ is an observable.
let simple$ = new Rx.Observable(emitter => {
  setTimeout(()=>{
    console.log('xxxx');
    emitter.next('this is val1');
    //emitter.complete();
  },3000);
  emitter.next('this is val2');
  emitter.next('this is val3');
  //dont write emitter.complete() here, else the async code doesnt emit!!! IMP!!!
});

simple$.subscribe(
  (e) => { console.log(e);},
  (err) => {}, //has to be comma separated since these r params
  () => {}
);
 
// let x = simple$.subscribe( ....
//console.log(typeof(x), x); //object, Subscriber ...<obj dump> 
 
 
---

VIMP: key concepts is shown in below example.

data stream : in theory are a sequence of data/events
observable: in theory, are a way to tap into data streams, TO EMIT values, errors, completed signal(wherever applicable)
                > it can EMIT values, but ONLY during its creation. //i.e. new Rx.Observable(...).
                    >> in below example simple$ (is object type &) is "Observable { _isScalar: false, _subscribe: [Function] }"
                > observable CANNOT EMIT values AFTER ITS CREATION.
                //VIMP:-simple$.next IS NOT possible after new Rx.Observable() ...
                    >> for emitting values (after creation), use a subscriber.
                            eg. let x = simple$.subscribe(...); x is a subscriber now.
                    >> subscribers also have x.unsubscribe(). observables (like simple$) DO NOT have unsubscribe() method.      

observer: in theory, has to subscribe/unsubscribe to get the EMITTED values.
          they r not visible, but implemented internally.
          >> subscribers are an implementation of observers.
        
Subject: > observable + observer
         > allows an observable to EMIT values AFTER creation too.
                //VIMP:- sub .next IS possible after let sub = new Rx.Subject() ...
         > use it when u want the observable to emit values, even after its creation. <<=== this is the most important thing that nobody is taking about!
        
eg. 1.3
            import Rx from 'rxjs/Rx';

            //our observable is a generator.
            //typeof (simple$) is object . simple$ is an observable.
            let simple$ = new Rx.Observable(emitter => {
              setTimeout(()=>{
                console.log('xxxx');
                emitter.next('this is val1');
                //emitter.complete();
              },3000);
              emitter.next('this is val2');
              emitter.next('this is val3');
              //dont write emitter.complete() here, else the async code doesnt emit!!! IMP!!!
            });

            //i think below is the "observer". Because:
            //1. observer/subscriber can ONLY subscribe to observables(which emits values from data streams)
            //2. observer cannot emit values. (It can only be notified of new values.)
            //3. observable cannot emit values after its creation. So, below is not possible.
            //simple$.next('val4'); //error: this is not possible.
            simple$.subscribe(
              (e) => { console.log(e);},
              (err) => {}, //has to be comma separated since these r params
              () => {}
            );

            //simple$.next('val4'); //if u want this to work use a Subject.
            //Subject = observable (emitting values) + observer (subscribing to those values) +
                        //observable can emit values after its creation

Q. What if I want to add more subscribers?
A. Add more sections.

            simple$.subscribe(
              (e) => { console.log(e + 'subscriber/observer 2');},
              (err) => {}, //has to be comma separated since these r params
              () => {}
            );


            simple$.subscribe(
              (e) => { console.log(e + 'subscriber/observer 3');},
              (err) => {}, //has to be comma separated since these r params
              () => {}
            );
          
            -or-
          
            //method1:
            /*
            let x = simple$.subscribe(
              (e) => { console.log(e);},
              (err) => {}, //has to be comma separated since these r params
              () => {}
            );

            x.next('xxx is badass');
            //x.unsubscribe(); //IMP: this still allows u to unsubscribe.
            //x.next('007 is badass');

            -or-
            VIMP:
                > There is nothing "visible" to define "observer".
                    >>simple$.subscribe() :- .subscribe() is the glue which connects the observer and observable internally.
                        simple$ (which is an observable), does NOT provide a .unsubscribe() method.
                    >>let x = simple$.subscribe(...); now x has a unsubscribe() method which can be called like x.unsubscribe();
                        x is a subsciber.
                        - Subscriber is an implementation of observer, which inturn is an implementation of IObserver<T>;
                > If u want to emit AFTER observable-creation, use a subscriber.
                                 
            IMP: To create multiple subscribers obs1, obs2 use this:-
          
            Here the COMMON values between obs1 and obs2 will be executed by:-
                let simple$ = new Rx.Observable(emitter => {
                  setTimeout(()=>{
                    //console.log('xxxx');
                    //emitter.next('this is val1');
                    //emitter.complete();
                  },3000);
                  emitter.next('this is val2');
                  emitter.next('this is val3');
                  //dont write emitter.complete() here, else the async code doesnt emit!!! IMP!!!
                });
              
            And the DIFFERENTIAL Values can be emitted from obs1.next(...) and obs2.next(...) which will be independent of each other  
          
                function getObserver(xsimple$, id){
                  let y = xsimple$.subscribe(
                    (e) => { console.log(e + 'subscriber/observer' + id);},
                    (err) => {}, //has to be comma separated since these r params
                    () => {}
                  );
                  return y; //do not return xsimple$, else it will be an observable
                            // y = observer/subscriber
                            // xsimple$ = observable. Its pass by reference remember and we want Pbyref.
                } //getObserver ends

                let obs1 = getObserver(simple$, 1);
                obs1.next('val4.1.1');
                obs1.next('val4.1.2');
                obs1.unsubscribe(); //if u unsubscribe, then val4 wont be displayed.
                obs1.next('val4.1.3');
                console.log("\n");
                //console.log(obs1);
                //console.log("\n");
                let obs2 = getObserver(simple$, 2);
                //console.log(obs2);
                console.log('==========================');
                obs2.next('val4.2.1');
                obs2.next('val4.2.2');
                obs2.unsubscribe();
                obs2.next('val4.2.3');
              
              
            */

---
          
eg.2    Lets c example of a subject.   
        NOTE:- the object keys of obs1 and obs2 is similar to the structure of "subscription" variable eg. let subscription = sub.subscribe(...);
        So, it looks to me like obs1, obs2 and subscription are similar if NOT equal objs.
        However, in JS, its impossible to compare 2 objects, as there is no inherent way to do it.
        u can create ur own method like Object.prototype.myequal = ()=>{}
        but then u will have to define what kind of "equality" needs to be checked, if only keys, or only keys/values, etc.
      
        NOTE:- the only place where obs1 and obs2 differ with subscription-var is in _subscriptions: null for them.
      
        back to Subjects:-
      
        import Rx from 'rxjs/Rx';

        let sub = new Rx.Subject();
        //console.log(typeof(sub)); //object
        //console.log(sub);
        /*
        Subject {
          _isScalar: false,
          observers: [],
          closed: false,
          isStopped: false,
          hasError: false,
          thrownError: null }
        */

        let subscription = sub.subscribe(
            function (x) { console.log('onNext: ' + x); },
            function (e) { console.log('onError: ' + e.message); },
            function () { console.log('onCompleted'); });

        //console.log(typeof(subscription)) //object
        console.log(subscription);
        /*
        Subscriber {
          closed: false,
          _parent: null,
          _parents: null,
          _subscriptions:
           [ SubjectSubscription {
               closed: false,
               _parent: [Circular],
               _parents: null,
               _subscriptions: null,
               subject: [Object],
               subscriber: [Circular] } ],
          syncErrorValue: null,
          syncErrorThrown: false,
          syncErrorThrowable: false,
          isStopped: false,
          destination:
           SafeSubscriber {
             closed: false,
             _parent: null,
             _parents: null,
             _subscriptions: null,
             syncErrorValue: null,
             syncErrorThrown: false,
             syncErrorThrowable: false,
             isStopped: false,
             destination:
              { closed: true,
                next: [Function: next],
                error: [Function: error],
                complete: [Function: complete] },
             _parentSubscriber: [Circular],
             _context: [Circular],
             _next: [Function],
             _error: [Function],
             _complete: [Function] } }
        */

        console.log('==========================');
        console.log(sub instanceof Rx.Subject); //true

---

2.1
    import Rx from 'rxjs/Rx';
    let sub = new Rx.Subject();

    let subscription = sub.subscribe(
        function (x) { console.log('onNext: ' + x); },
        function (e) { console.log('onError: ' + e.message); },
        function () { console.log('onCompleted'); });

    //sub.unsubscribe(); //WONT WORK!!!! because sub is not a 'subscriber, its a Subject'

    subscription.next(1); //subscriber type subscription
    subscription.next(2);
    subscription.next(3);
    subscription.unsubscribe(); //WORKS !!! if u unsubscribe, none of following statements will execute
    subscription.next(4);

    sub.next(3.14); //works. subject-type subscription
    sub.next(3.141);
    sub.next(3.145);
    sub.next(3.146);
    sub.next(3.147);

    //The Subject class inherits both Observable(IObservable<T>) and (Observer<T>)
    //https://github.com/ReactiveX/RxJava/issues/792
    //Publisher-subscriber is a network oriented architectural pattern and
        //Observer is an object-event oriented pattern. They both are used at different Software levels.
    //http://www.introtorx.com/Content/v1.0.10621.0/02_KeyTypes.html#IObserver  
  
---

simple$:-
Observable { _isScalar: false, _subscribe: [Function] }

obs1,obs2, obs3:-
Subscriber {
  closed: false,
  _parent: null,
  _parents: null,
  _subscriptions: null,
  syncErrorValue: null,
  syncErrorThrown: false,
  syncErrorThrowable: false,
  isStopped: false,
  destination:
   SafeSubscriber {
     closed: false,
     _parent: null,
     _parents: null,
     _subscriptions: null,
     syncErrorValue: null,
     syncErrorThrown: false,
     syncErrorThrowable: false,
     isStopped: false,
     destination:
      { closed: true,
        next: [Function: next],
        error: [Function: error],
        complete: [Function: complete] },
     _parentSubscriber: [Circular],
     _context: [Circular],
     _next: [Function],
     _error: [Function],
     _complete: [Function] } }

sub:-   
Subject {
  _isScalar: false,
  observers: [],
  closed: false,
  isStopped: false,
  hasError: false,
  thrownError: null }   
   
subscription:-
Subscriber {
  closed: false,
  _parent: null,
  _parents: null,
  _subscriptions:
   [ SubjectSubscription {
       closed: false,
       _parent: [Circular],
       _parents: null,
       _subscriptions: null,
       subject: [Object],
       subscriber: [Circular] } ],
  syncErrorValue: null,
  syncErrorThrown: false,
  syncErrorThrowable: false,
  isStopped: false,
  destination:
   SafeSubscriber {
     closed: false,
     _parent: null,
     _parents: null,
     _subscriptions: null,
     syncErrorValue: null,
     syncErrorThrown: false,
     syncErrorThrowable: false,
     isStopped: false,
     destination:
      { closed: true,
        next: [Function: next],
        error: [Function: error],
        complete: [Function: complete] },
     _parentSubscriber: [Circular],
     _context: [Circular],
     _next: [Function],
     _error: [Function],
     _complete: [Function] } }   
   
     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
     
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  

 ng2 complete guide (maxi)
sec 9 v 96

1. services:-
- never create instances of a service like this
let x = new LoggingService(); //DONT DO.

- instead use
constructor (private x : LogginService){}

- we need to add the
providers: [LoggingService];  in the @Component () section.

All components which are using the LoggingService will need the providers-section
the service can now be called as this.x.function1(), etc.

---
v 99 Hierarchial Injector

The Dependency injector is a hierarchial injector.
 - So, if a service is created for a component, then it is ALSO AVAILABLE to its child components.
- the child components will receive the same instance of the service

AppModule: same instance of service is available APPLICATION WISE
- if u provide a module there, it is available throughout the application

AppComponent: same instance of Service is avail. for all child components. (but not for other services)

NOTE: child component can override the same instance of service . that is what the providers : [] array is for !!!
- so if u want to use the same instance of Service from parent component, DO NOT populate providers:[] array
- so if u want to override the instance from parent component, then populate the providers[] array.

---

v101 Injecting Services in Services

- AppModule: add both services here AccountsService and LogginService.
-  Open AccountService and add a constructor(private x : LoggingService){}

u may think this should do it, but u will run into errors.
the problem is if u inject LServ. into AServ. , Aserv. should have some metadata attached to it .
Component has some metadata in @Component, directive has some metadata with @Directive, but a  service does NOT have any metadata by default.

@Injectable() is the metadata to be used and it needs to be put into the AServ. as it is receiving the LServ.
- no @Injectable in Lserv()
- @injectable in AServ, as we r injecting LServ into it.

---

v102 Cross-component communication (using Services)
- Services have made our code a lot leaner, else we would have to do a lot with property/event binding, etc.

GOAL: trigger an event in one comp and LISTEN in another
A. we will use new EventEmitter(), .emit() and .subscribe()

Pre-requisite: Comp1 and Comp2 are using a common service  Aserv

AServ: accounts.service.ts
- statusUpdated: new EventEmitter<string>();

Comp1:- (already uses AServ)
this.AServ.statusUpdated.emit(status);

Comp2:- (already uses Aserv)
this.Aserv.statusUpdated.subscribe();

This is also called push-notifications being sent across components
---
Skipped Course project
---

Sec11, v114 Routes

AppModule : here is where we inform angular where we r going to add routes.
eg.
import {Routes, RouterModule} from '@angular/router'

const appRoutes: Routes = [
 {path:'server' (no slash plz!!!), component: ServerComponent},
 {path:'servers', component: },
];

...
imports: [
...,
RouterModule.forRoot(appRoutes) //this is how we register our routes. angular now knows our routes.
]

<router-outlet></router-outlet> is the placeholder for injecting the component.

<a href="/server"></a>            dont use this . this will reload the page
<a routerLink="/server"></a>  USE this. this will PREVENT page reload.

---

v117 styling router links

we can add css class to the <li> tabs. (bootstrap classes: ul: nav nav-tabs & li: role="presentation")
we use BStrap class "active" (?) to keep Home as active by default.

Q. But how do we make the other tabs "active" when they r clicked? currently there is NO visual indication (even though the components are visible correctly. This is a styling problem of non-home tabs.
A. use routerLinkActive and routerLinkActiveOptions together.

routerLinkActive="active" (is active a bootstrap class? i think so)
[routerLinkActiveOptions] = "{exact:true}"

we r using property binding here, because we are passing an object and NOT a string.

---

v118 routes: navigating programmitically

- import {Router} from '@angular/router';
- constructor(private x: Router){ ... }
- somefunc(){
//complex calculation
this.router.navigate(['/servers']);
}

on some button-click execute somefunc()

NOTE: no page reload happens while doing this

---

v119: using relative paths in route navigation
- if u are already on /servers page, above code in v118 will not work as that is an absolute path.
 this.router.navigate(['/servers']);

Note:-
- / is removed to make it relative.
- Router does not know on which component u r correctly on
- routerLink (in prev videos) CANNOT use relative paths but Router, here , can.
that is bcoz routerLink KNOWS which route it is currently on and will give errors.

eg.2
To make Router know which route it is on, do below:-

- import {Router, ActivateRoute} from '@angular/router';
- constructor ( private x: ActivatedRoute) { ... } 
this.router.navigate(['servers'], {relativeTo: this.x });

Now, we are relative to this.x

---

v 120 Passing parameters to Routes

AppModule:

const appRoutes: Routes = [
   {path: 'server/:id', component: ServerComponent }
];

here :id is a param and can be retrieved later

v121

- use ActivatedRoute
constructor(private x: ActivatedRoute){ ... }
ngOnInit(){
   //this.x.snapshot.params['id']  will give us the:id param we passed in AppModule.
}


if route was server/:id/:name will be accessible via //this.x.snapshot.params['name']
---

v 122 fetching route params reactively

there r few cases in which above style of getting params may NOT work

// this.route.params (is an observable)
this.route.params.subscribe();

++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

 synetraining: ng2
nodejs, gitbash, webstorm, atom

https://github.com/coreybutler/nvm-windows/releases
Download nvm-setup.zip

C:\js\ts>nvm install 8.0.0
nvm list
nvm use 8.0.0

C:\js\ts>nvm list

  * 8.0.0 (Currently using 64-bit executable)
    6.10.3

C:\js\ts>
---

For scoop
iex (new-object net.webclient).downloadstring('https://get.scoop.sh')

scoop update
scoop install wget
scoop install curl

---

creating a project in ES5 > creating a project in ES6 > creating a project in TS2.3 > 

//IIFE can be invoked using +function(){}
//u can use + ~
//* is for generators so dont use it. @ and $ may not work. so some things work, other dont.

 ---

ES6:-

1) Destructuring  objects

<script type="module">
 let comp = {name: 'synechron', site: 'hinjewadi'};
 let {name, site} = comp;
 console.log (name,site);

</script>

//compName and compSite are two new objects
<script type="module">
 let comp = {name: 'synechron', site: 'hinjewadi'};
 let {name : compName, site : compSite} = comp;
 console.log (compName, compSite);

</script>

<script type="module">
 let comp = {name: 'synechron',
             site: 'hinjewadi',
             projects:
                 {
                     project01: 'DMT',
                     project02: 'xyz'
                 }
            };

 //read from right to left.
 //RHS to LHS: From comp, i want the key "projects", from which i want project01, and assign project01 to a new variable "p1"
 let {projects: {project01: p1}, projects: {project02: p2}} = comp;
 console.log(p1, p2);
</script>

 REFER ES6 CONSOLIDATED FOR MORE ON SYNE TRAINING

----


core-js/client/shim.js
zone.js/dist/zone.js
rxjs/bundles/Rx.js
@angular/core/bundles/core.umd.js
common/bundles/common.umd.js
compiler/bundles/compiler
platform-browser/bundles/
platform-browser-dynamic/bundles/


var Mycomp = ng.core.Component({
selector: "",
remplateUrl:""
}).Class({
 constructor: function(){
}

}) ;


var MyMod = ng.core.NgModel({
  declaration:[],
  imports:[ng.platformBrowser.BrowserModule],
  bootstrap:[]
}).Class({
  consutrcutor: function(){
  //empty
 }

})

FULL CODE:-

<!DOCTYPE html> 	<html lang="en"> 	<head> 	<meta charset="UTF-8"> 	<title>Hello World with Angular4</title> 	<script src="node_modules/core-js/client/shim.js"></script> 	<script src="node_modules/zone.js/dist/zone.js"></script> 	<script src="node_modules/rxjs/bundles/Rx.js"></script> 		<script src="node_modules/@angular/core/bundles/core.umd.js"></script> 	<script src="node_modules/@angular/common/bundles/common.umd.js"></script> 	<script src="node_modules/@angular/compiler/bundles/compiler.umd.js"></script> 	<script src="node_modules/@angular/platform-browser/bundles/platform-browser.umd.js"></script> 	<script src="node_modules/@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js"></script> 	<script> 	// component 	// dom element which is used by our component 	// module 	// module is bootstraped to your app 	
	var MyComp = ng.core.Component({ 	selector : "my-app", 	template : "<h1> Welcome to your life </h1>" 	}).Class({ 	constructor : function(){ 	// empty 	} 	}); 	var MyMod = ng.core.NgModule({ 	imports : [ng.platformBrowser.BrowserModule], 	declarations : [MyComp], 	bootstrap : [MyComp] 	}).Class({ 	constructor : function(){ 	// empty 	} 	}); 	
	window.onload = function(){ 	ng.platformBrowserDynamic 	.platformBrowserDynamic() 	.bootstrapModule(MyMod); 	} 	</script> 	</head> 	<body> 	<my-app></my-app> 	</body> 	</html>


xxxxxxxxxxxxxxxxxxxxxx

interfaces and typescript

interface IcanRun {
    run(speed:string): string;
};

interface IcanFly {
    fly(): string;
};

class Hero implements IcanRun, IcanFly{

    public name:string;
    private secret:string;

    constructor(){
        this.name = 'batman';
        this.secret = 'i am bruce wayne' ;
    }
    toString(num1: number){
        return num1.toString();
    }

    run(p1: string):string{
        return 'I can rrun @ 110km/hr';
    }

    fly():string{
        return 'i cann fcking fly';
    }

};

let h = new Hero();
console.log(h.name);
console.log(h.run('xxx'));
console.log(h.run('xxx'));
console.log(h.fly());

xxxxxxxxxxxxxxxxxxx



pipes

ng g p somepipe

somepipe.ts

    import { Pipe, PipeTransform } from '@angular/core';

    @Pipe({
      name: 'somepipe'
    })


    export class SomepipePipe implements PipeTransform {
      // transform(value: any, args?: any): any {
      transform(value: any, ...x): any { //2ns param doesnt have to be args, it can be anything like x
        //do Mr. and Mrs. ka logic here.
        return x[0] + " hi  " + value;
      }

    }
   
app.component.ts

    import { Component} from '@angular/core';

    @Component({
      selector: 'app-root',
      //templateUrl: './app.component.html',
      template:`
         <h1 *ngFor = "let item of usersList; let i = index">{{item.title | somepipe :item.gender}}</h1>    <!-- see how params r passes to pipes using : -->
      `,

          // <h1>{{userslist[0].title}}</h1>
      styleUrls: ['./app.component.css']
    })


    export class AppComponent {
      title = 'app';
      usersList = [
        {title: "Superman", gender: "male", city:"Metropolis"},
        {title: "Superman2", gender: "male", city:"Metropolis"}
      ];

    }
   
---
u can send in more params using one more :
eg.  <h1 *ngFor = "let item of usersList; let i = index">{{item.title | somepipe :item.gender: item.city }}</h1>

Solution: (use x[1] to get the additional param )
    ...
    return x[0] + " hi  " + value + " " + x[1];
  
---
u can also add one more custome pipe and lets say currencypipe.    
    item.title | somepipe :item.gender: item.city | currencypipe
u may have to import them
---
pipes may have restriction when converting string to int. try to RND on that.
---

import { SomepipePipe } from './somepipe.pipe';

describe('SomepipePipe', () => {
  it('create an instance', () => {
    const pipe = new SomepipePipe();
    expect(pipe).toBeTruthy();
  });
});

---
input [(ngModel)] = "uname" #ctrl = "ngModel"
https://github.com/angular/angular/issues/15890
formElement, formBuilder  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 ngtesting_rough1
app.component.spec.ts


describe('xxx', ()=>{
  it('testsuite', ()=>{
    expect(true).toBe(true);
  });

  it('testsuite', ()=>{
    expect(true).toBe(true);
  });

  it('testsuite', ()=>{
    expect(true).toBe(true);
  });
 
})



// /* tslint:disable:no-unused-variable */
//
// import { TestBed, async } from '@angular/core/testing';
// import { AppComponent } from './app.component';
//
// describe('AppComponent', () => {
//   beforeEach(() => {
//     TestBed.configureTestingModule({
//       declarations: [
//         AppComponent
//       ],
//     });
//     TestBed.compileComponents();
//   });
//
//   it('should create the app', async(() => {
//     const fixture = TestBed.createComponent(AppComponent);
//     const app = fixture.debugElement.componentInstance;
//     expect(app).toBeTruthy();
//     expect(true).toBe(true);
//   }));
//
//   it(`should have as title 'app works!'`, async(() => {
//     const fixture = TestBed.createComponent(AppComponent);
//     const app = fixture.debugElement.componentInstance;
//     expect(app.title).toEqual('app works!');
//   }));
//
//   it('should render title in a h1 tag', async(() => {
//     const fixture = TestBed.createComponent(AppComponent);
//     fixture.detectChanges();
//     const compiled = fixture.debugElement.nativeElement;
//     expect(compiled.querySelector('h1').textContent).toContain('app works!');
//   }));
// });


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

karma.conf.js

// Karma configuration
// Generated on Fri Oct 30 2015 22:10:10 GMT+0900 (JST)

module.exports = function(config) {
  config.set({

    // base path that will be used to resolve all patterns (eg. files, exclude)
    basePath: '',


    // frameworks to use
    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
    frameworks: ['jasmine'],


    // list of files / patterns to load in the browser
    files: [
      'node_modules/babel-polyfill/dist/polyfill.js',
      'src/app/*.spec.ts'
    ],


    // list of files to exclude
    exclude: [
    ],


    plugins: [
      'karma-jasmine',
      'karma-phantomjs-launcher',
      'angular-cli/plugins/karma',
      'karma-babel-preprocessor',
      //require('./lib')
    ],


    // preprocess matching files before serving them to the browser
    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: {
      'src/app/*.ts': 'babel'
    },


    babelPreprocessor: {
              options: {
                presets: ['es2015'],
                sourceMap: 'inline'
              },
              filename: function (file) {
                return file.originalPath.replace(/\.js$/, '.es5.js');
              },
              sourceFileName: function (file) {
                return file.originalPath;
              }
            },

    // test results reporter to use
    // possible values: 'dots', 'progress'
    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
    reporters: ['progress'],


    // web server port
    port: 9876,


    // enable / disable colors in the output (reporters and logs)
    colors: true,


    // level of logging
    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // enable / disable watching file and executing tests whenever any file changes
    autoWatch: true,


    // start these browsers
    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
    browsers: ['PhantomJS'],


    // Continuous Integration mode
    // if true, Karma captures browsers, runs the tests and exits
    singleRun: true,

    // Concurrency level
    // how many browser should be started simultanous
    concurrency: Infinity
  })
}

xxxxxxxxxxxxxxxxxxxxxxxxxxx

package.json

{
  "name": "project1",
  "version": "0.0.0",
  "license": "MIT",
  "angular-cli": {},
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "test": "ng test",
    "pree2e": "webdriver-manager update --standalone false --gecko false",
    "e2e": "protractor"
  },
  "private": true,
  "dependencies": {
    "@angular/common": "^2.3.1",
    "@angular/compiler": "^2.3.1",
    "@angular/core": "^2.3.1",
    "@angular/forms": "^2.3.1",
    "@angular/http": "^2.3.1",
    "@angular/platform-browser": "^2.3.1",
    "@angular/platform-browser-dynamic": "^2.3.1",
    "@angular/router": "^3.3.1",
    "core-js": "^2.4.1",
    "rxjs": "^5.0.1",
    "ts-helpers": "^1.1.1",
    "zone.js": "^0.7.2"
  },
  "devDependencies": {
    "@angular/compiler-cli": "^2.3.1",
    "@types/jasmine": "2.5.38",
    "@types/node": "^6.0.42",
    "angular-cli": "1.0.0-beta.28.3",
    "babel-core": "^6.24.1",
    "babel-loader": "^7.0.0",
    "babel-polyfill": "^6.23.0",
    "babel-preset-es2015": "^6.24.1",
    "codelyzer": "~2.0.0-beta.1",
    "jasmine": "^2.6.0",
    "jasmine-core": "2.5.2",
    "jasmine-spec-reporter": "2.5.0",
    "karma": "^1.7.0",
    "karma-babel-preprocessor": "^6.0.1",
    "karma-chrome-launcher": "^2.0.0",
    "karma-cli": "^1.0.1",
    "karma-jasmine": "^1.1.0",
    "karma-phantomjs-launcher": "^1.0.4",
    "karma-remap-istanbul": "^0.2.1",
    "protractor": "~4.0.13",
    "ts-node": "1.2.1",
    "tslint": "^4.3.0",
    "typescript": "~2.0.3"
  }
}

xxxxxxxxxxxxxxxxxxxxxxxxxxx

i copied the karma.conf.js from the node_modules/karma-babel-preprocessor/ ... /karma.conf.js

xxxxxxxxxxxxxxxxxxxxxxxxxxx

original karma.conf.js wrongly modified but kept for reference

ROUGH 1

// Karma configuration file, see link for more information
// https://karma-runner.github.io/0.13/config/configuration-file.html


module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine', 'angular-cli'],
    plugins: [
      //require("babel-core"), require("jasmine-core"),
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-remap-istanbul'),
      require('angular-cli/plugins/karma'),
      require('karma-babel-preprocessor')
    ],
    files: [
//      { pattern: './src/test.ts', watched: false }
        'node_modules/babel-polyfill/dist/polyfill.js'
   ],
    preprocessors: {
      //'./src/test.ts': ['angular-cli']
      './src/app/*.spec.ts': ['babel']
    },
    babelPreprocessor: {
          options: {
            presets: ['es2015'],
            sourceMap: 'inline'
          },
          filename: function (file) {
            return file.originalPath.replace(/\.js$/, '.es5.js');
          },
          sourceFileName: function (file) {
            return file.originalPath;
          }
        },

    // mime: {
    //   'text/x-typescript': ['ts','tsx']
    // },
    // remapIstanbulReporter: {
    //   reports: {
    //     html: 'coverage',
    //     lcovonly: './coverage/coverage.lcov'
    //   }
    // },
    angularCli: {
      config: './angular-cli.json',
      environment: 'dev'
    },
    // reporters: config.angularCli && config.angularCli.codeCoverage
    //           ? ['progress', 'karma-remap-istanbul']
    //           : ['progress'],
    reporters: ['progress'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['Chrome'],
    singleRun: false
  });
};

xxxxxxxxxxxxxxxxxxxxxxxxxxx


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 ngTesting01
ng new ngtesting01/

npm test
    D:\js\Ang2\proj2\ngtesting01>npm test

npm install systemjs --save-dev    (required?)

karma start karma.conf.js
    D:\js\Ang2\proj2\ngtesting01>karma start karma.conf.js
    1st.spec.ts is the only one running.

npm install karma-phantomjs-launcher --save-dev
karma start karma.conf.js
    npm install babel-polyfill --save-dev
    karma start karma.conf.js
    https://stackoverflow.com/questions/42640317/phantomjs-error-while-running-tests-in-angular-cli
        Uncomment these lines in polyfill.js
       
        import 'core-js/es6/object';
        import 'core-js/es6/array';
        import 'intl';  // Run `npm install --save intl`.
   
        https://github.com/angular/angular-cli/issues/1675
        npm install --save intl
       
       
D:\js\Ang2\proj2\ngtesting01>karma start karma.conf.js

WORKED!!! with phantomjs !!!

----------------------

ng new ngtesting02/
cd ngtesting02/
karma start karma.conf.js    //works
    singlerun:true
    files: [
      { pattern: './src/**/*.spec.ts', watched: false }
    ],
   
renamed app.component.spec.ts to .xxx
and added
01.spec.ts
    describe('1st tests', () => {
      it('true is true', () => expect(true).toBe(true));
      // it('true is true', () => expect(true).toBe(true));
    });
   
karma start karma.conf.js //worked

---

karma-phantomjs-launcher

npm install karma-phantomjs-launcher --save-dev

add to karma.conf.js
    require('karma-phantomjs-launcher'),
    ...
    ...
    browsers: ['PhantomJS', 'PhantomJS_custom'],

        customLaunchers: {
             'PhantomJS_custom': {
               base: 'PhantomJS',
               options: {
                 windowName: 'my-window',
                 settings: {
                   webSecurityEnabled: false
                 },
               },
               flags: ['--load-images=true'],
               debug: true
             }
           },

           phantomjsLauncher: {
             // Have phantomjs exit if a ResourceError is encountered (useful if karma exits without killing phantom)
             exitOnResourceError: true
           },

karma start karma.conf.js //error (pending)
        Uncomment these lines in polyfill.js
       
        import 'core-js/es6/object';
        import 'core-js/es6/array';
        import 'intl';  // Run `npm install --save intl`.

================================

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


D:\js\test\tsc>
npm install -g jasmine jasmine-ts
npm install -g jasmine-core
D:\js\test\tsc>
npm install jasmine-core jasmine @types/jasmine jasmine-ts --save-dev
npm uninstall jasmine-core jasmine @types/jasmine jasmine-ts --save-dev

---------------

http://twofuckingdevelopers.com/2016/01/testing-angular-2-with-karma-and-jasmine/

---------------
stack: ang2 + ang2material + jasmine + karma
---------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 synetraining outputs (child to parent communication)
Example 1:- eg. 1.

Sending data from child to parent:-
1. CHILD STEPS
1a) needs an custom-event to send event up (to the parent)using event bubbling.
we are calling it "compevent" .

outputs: ['compevent']    //we let angular know, there is a custom-event we are going to define.
...
method 1a.1

    compevent;                //declare the event
    constructor(){
        this.compevent = new EventEmitter(); //setting the event type to EventEmitter. This is to make it inline with angular context.
    }
    Reading the custom-event is DONE.
  
method 1a.2
    Remove 1a) code and add this:-
  
    @Output() compevent = new EventEmitter();  


1b)
Q. when should this event be emitted?
A. lets say a button click . so we need to tie the click-event to action-function.

template:`
  <div style="border: 1px solid red">
    <button (click) = "clickHandler()" >send msg to parent </button>    <!-- clickHandler will be responsible for emitting -->
  </div>
  `,
READING the template is DONE.

1c)
clickHandler(){
  this.compevent.emit("secret data");
}
Emitting the event is DONE

2. PARENT STEPS
2a) Link the child-component to the child-event

<app-comp1 (compevent) = "childEventHandler($event)">
  <div>hey where r u guys ??? </div>
</app-comp1> 
Linking to child-event is DONE.

2b)
childmessage;
childEventHandler(evt){
  this.childMessage = evt;
  console.log(this.childMessage);
}

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

>>>
@Output: child -> parent communication (think like event bubbling)

Child:-
    import {Component, Input, Output, OnInit, EventEmitter} from '@angular/core';
    ...
    @Output() childEvent = new EventEmitter(); //step1. create the custom-event which needs to be bubbled.
    clickHandler(){
        this.childEvent.emit("secret data"); //step2. created event must be emitted.
    }
   
-> radical-test.component.html    //step3. bind clickHandler() to child-view
    <div style="border: 1px solid red">Radical Component in html
      <button (click) = "clickHandler()"> child button </button>
    </div>

Parent:-    
    app.component.html
    <radical-test (childEvent) = "parentDoSomething($event)"></radical-test> //step4. using the custom event. Note $event usage.
   
    app.component.ts
    parentDoSomething(e){
        console.log(e); //e has "secret data
    }
    
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 COMMONJS, AMD, UMD, ES6 Modules -- Module bundling n loading
https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc
https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306
module_bundling
module_loader

Good authors divide their books into chapters and sections; good programmers divide their programs into modules.
Modules can be written in patterns.
1. Module pattern

1.1 Anonymous Closure (Module Pattern)
var global_var = '';
(function(){
    //global vars are accessible here.
    var func1 = function() { ... };
    var func2 = function() { ... };
  
    console.log(func1());
    console.log(global_var);
}())

1.2 Global Import (Module Pattern)
- jquery uses this.
- here globals are passed as a param

(function(globalvar/$){
}(globalvar))
//check if $ works.

1.3. Object interface (Module Pattern)
var x = (function(){
    //some code
    return{
        func1 : function(){ ... },
        func2 : function(){ ... }
    }
}());
x.func1();
x.func2();

1.4. Revealing Module Pattern
Same as 1.3. but with one difference.
- it ensures all methods and variables are kept private until explicitly exposed.

var x = (function(){
    //some code
    var func1 = function(){ ... }; //var makes the method private.
    var func2 : function(){ ... }; //this is private too
    return{
        func1 : func1, //explicit exposing. LHS can be named differently
        func2 : func2
    }
}());
x.func1();
x.func2();

The approaches above all have one thing in common:
the use of a single global variable to wrap its code in a function, thereby creating a private namespace for itself using a closure scope.

But the module-pattern has its downsides:-
1. hard-dependency eg. BBjs has hard dependency on underscore and it cannot be loaded before underscore.
As a developer, we have to keep track of all these hard dependencies. Imagine if there r 100s of modules.

2. name space collisions:-
eg. 2 modules with same name, 2 versions of same module and both r needed
Q. is: can we design a way to ask for a module’s interface without going through the global scope?
A. yes.
Use CommonJS, AMD, UMD

---
There is a need:-
Modules need to be:- loaded(based on dependency AST) + bundled (+ minified + DCE(ES5)/tree-shaken(ES6)/removing-exports(ES6) + converted to ES5 )
NOTE: uglify uses  DCE
---
xxxxxxxxxxx
1. CommonJS: helps in synchronous loading. so if we have 3 modules, all r loaded one by one.
- exporting using module.exports
- require to import + new classname()
Pros:- Helps in
1. Avoiding global namespace pollution
2. Making our dependencies explicit

Cons:-
Since, CommonJS uses synchronous loading, its good for server side (eg. nodejs)
Its not helpful on client side.
- its NOT browser-first approach

PS: A workaround for this is to use browserify.
Browserify is a tool that compiles CommonJS modules for the browser. it does this by parsing the AST (Abstract syntax tree) and finding all dependencies.
Once all dependencies are found, it bundles them into one file (bundle.js). (It solves the problem COMMONJS has with browser/client-side.)
Minifying tools like Minify.js can be used to minify the bundle.js
So, browserify = loading dependencies + bundling, but not minifying.

---
2. AMD: Asynchronous loading of modules on client side. Stands for Asynchronous module definition.
- it uses define()
- implements browser-first approach
- Aside from asynchronicity, another benefit of AMD is that your modules can be objects, functions, constructors, strings, JSON and many other types, while CommonJS only supports objects as modules.

eg.
define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) {
  console.log(myModule.hello());
});

Cons:-
AMD isn’t compatible with io, filesystem, and other server-oriented features available via CommonJS

AMD loader : RequireJS / Curl . It just loads dependencies; but does not create a bundle.
(In theory, Since everything is loaded asynchronously, a bundler is not required; that extra step of bundling is not required)
(In reality, people do the bundling as too many high volume async requests can be problem in prod; so people using tools like RequireJS optimizer, r.js , etc.)

Diff. between CommonJS and AMD:-
During development, AMD apps can get away without a build step. (CommonJS apps will have to do the build step even on dev).
At least, until you push the code live, at which point optimizers like r.js can step in to handle it.
---
Aside: This section is about webpack and can be read later.
Webpack:-
- is agnostic to the module system in use. therefore webpack allows developers to use CommonJS, AMD, or ES6 as appropriate.
Q. Other than above, what advantages does it have over browserify,  requireJs, etc. ?
A. Well, for one, Webpack provides some useful features like “code splitting”?—?a way to split your codebase into “chunks” which are loaded on demand.

I could NOT do tree-shaking earlier, but looks like it is possible in webpack2
http://jakewiesler.com/tree-shaking-es6-modules-in-webpack-2/
    if u use webpack2, use babel, because of dynamic-structure problem with CommonJS.
    webpack2 and rollup require static-structure to do tree-shaking.
        - use babel to prevent common-js style creation in the above url of jakewiesler.com

---
3. UMD : Universal Module Definition
(for projects that require both AMD and Common JS)

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
      // AMD
    define(['myModule', 'myOtherModule'], factory);
  } else if (typeof exports === 'object') {
      // CommonJS
    module.exports = factory(require('myModule'), require('myOtherModule'));
  } else {
    // Browser globals (Note: root is window)
    root.returnExports = factory(root.myModule, root.myOtherModule);
  }
}(this, function (myModule, myOtherModule) {
  // Methods
  function notHelloOrGoodbye(){}; // A private method
  function hello(){}; // A public method because it's returned (see below)
  function goodbye(){}; // A public method because it's returned (see below)

  // Exposed public methods
  return {
      hello: hello,
      goodbye: goodbye
  }
}));

WTF is root n factory?
---
4. Native JS. : none of the above are native to JS. NativeJS gives us that.
- provides built-in modules in ES6 using import and export

 ES6 modules are designed with "static analysis" in mind.
 What this means is that when you import modules, the import is resolved at compile time?—?that is, before the script starts executing.
 This allows us to remove exports that are not used by other modules before we run the program.
    (Removing unused exports can lead to significant space savings, reducing stress on the browser.)

Q. how is "removing exports" different from "dead code elimination"?
A.  Dead code elimination is an optimization step which removes unused code and variables?—?think of it as removing the excess baggage that your bundled program doesn’t need to run, AFTER it’s been bundled. DCE is ES5-based.
  
Removing exports: happens BEFORE its bundled.

Tree shaking:- (ES6 based. Helps to remove code, BEFORE bundling)
What makes ES6 modules different is the different approach to dead code elimination, called “tree shaking”
Imagine util.js having 4 functions like myfilter, myeach, mymap and myreduce and we are importing entire util.js, but are using ONLY myEach.
So, the final version will NOT have myFilter, myMap and myReduce. This is tree shaking.

Building ES6 modules:-
- this is tough because browsers dont yet provide this.
    Options:-
    Opt#1: 1.1) Use a transpiler like Babel/Traceur to transpile ur code from ES6 to ES5 code in either CommonJS/AMD/UMD format.
           1.2) Then use Browserify/webpack to create one or more bundles
         
    Opt#2: Use RollUp (which is same as Opt#1)
        - it uses the power of ES6 modules to statically analyze your ES6 code and dependencies (BEFORE bundling) using Tree Shaking.
        - this is a big advan. over browserify/webpack as bundles are extremely small.
      
        Caveat:
         Rollup provide several formats to bundle your code to, including ES6, CommonJS, AMD, UMD, or IIFE.
         The IIFE and UMD bundles would work in your browser as they are,
            but if you choose to bundle to AMD, CommonJS, or ES6, you need to find other methods to convert that code into a format the browser understands (e.g. by using Browserify, Webpack, RequireJS, etc.).
          
        Note:-
        - Doesn't have code-splitting yet (like webpack), but thats ok
        - But its tree shaking really helps a lot lot in ang2 application.
        - Use rollup + tsc (See this: https://www.codementor.io/stevebelovarich/use-rollup-to-build-angular-2-web-apps-du1089cq5 )
        ( I Don't think systemJS has tree shaking yet!! If it had, it would've beaten rollup hands down, i think)
      
        TS/ES2015 i.e. ES6 => Tree Shaking => ES2015 Bundle (ES6) => tsc => ES5 / ES3
        See its use with ionic2:
            https://stackoverflow.com/questions/40144085/how-to-configure-rollup-or-ionic-copy-script-to-override-files-in-assets-direc
            ionic uses webpack, by default i think

Q. when will ES6 modules run in the browser without all this overhead?
A. sooner than later
ECMAScript currently has a specification for a solution called the ECMAScript 6 module loader API.
https://github.com/ModuleLoader/es6-module-loader (es6-module-loader is a polyfill)

Promise-based API that is supposed to dynamically load your modules
    and cache them so that subsequent imports do not reload a new version of the module.

myModule.js  
export class myModule{
        //some shit, constructor(), hello(), etc.
}
          
main.js
    method1:-           
    System.import(‘myModule’).then(function(myModule) {
      new myModule.hello();
    });

    -OR-
    method2
    <script type="module">
      // loads the 'myModule' export from 'mymodule.js'
      import { hello } from 'mymodule';
      new Hello(); // 'Hello, I am a module!'
    </script>
      
SystemJS is built on top of es6-module-loader polyfill
    SystemJS dynamically loads any module format (ES6 modules, AMD, CommonJS and/or global scripts) in the browser and in Node.
    It keeps track of all loaded modules in a “module registry” to avoid re-loading modules.
    Not to mention that it also automatically transpiles ES6 modules (if you simply set an option)
        and has the ability to load any module type from any other type!

    Q. Does it support tree-shaking? I dont think so!
  
xxxxxxxxxx
You should now be able to answer these questions.

Q. Why is a module bundler used ?
Q. Why is a module loader used ?

xxxxxxxxxx

Moral of story:-
1. Modules can be written in 4 module patterns. Cool.
2. Modules' Life cycle: Modules need to be:-
loaded(based on dependency AST) + bundled (+ minified + DCE(ES5)/tree-shaken(ES6)/removing-exports(ES6) + if ES6, needs convertion to ES5 )

Loading & Bundling (+ others):- is needed so that page displays on browser fast.

    1. CommonJS-style: Loader is CommonJS.
              - modules can ONLY BE objects
              - synchronous loading. Server side mostly. (is NOT browser-first)
                + browserify to implement bundling
                + minify.js/uglify.js to implement minification, etc.
              
            Note:- Auth0 uses CommonJS style  
  
    2. AMD-style: -modules can be objects, functions, constructors, strings, JSON, etc.
               - Async loading.
               - Loader is RequireJS/Curl
               - implements browser-first approach
               + r.js (requireJS optimizer) to implement bundling (on prod)
                 bundler is NOT required (on dev)

    3. UMD-style: skipped

    4. NativeJS-style (ES6):
                4.1.
                    - use babel/traceur:
                        to convert (and load) in CommonJS/AMD/UMD
                    + browserify/webpack to create bundling  
                -OR-
                4.2.    
                    - use Rollup (removing exports + tree shaking)
                        loading + bundling is done by Rollup itself and u can get any format ES6, CommonJS, AMD, UMD, or IIFE
                      
                        --> no additional step if O/P is UMD or IIFE
                        --> if ES6/CommonJS/AMD, then use browserify/webpack/RequireJS (to convert to ES5 CommonJS/AMD)
                      
Javascript bundlers such as webpack2 and Rollup can only perform tree-shaking on modules that have a static structure.
If a module is static, then the bundler can determine its structure at build time, safely removing code that isn't being imported anywhere. CommonJS DOESNOT have a static structure
                      
---
Aside: Rollup

https://www.codementor.io/stevebelovarich/use-rollup-to-build-angular-2-web-apps-du1089cq5
https://stackoverflow.com/questions/42036331/bundle-angular2-aot-with-systemjs-builder-and-rollup-tree-shaking


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Redux basics part 1
Redux egghead 1st 10 videos

- 1st principle:- state of ur app (whether small or large app) will be one SINGLE js object.
This obj. is called the "state tree" 
NOTE: the state is the minimal representation of the data in ur app

- 2nd principle:- the state-tree is immutable/read-only
Anytime u want to change it, u have to "dispatch an action"
An action is a plain JS obj describing the change
NOTE: the action is a minimal representation of the change to the data in ur app.

The structure of the action obj is upto u. However, it is mandatory that the action obj should have
"type" property . type-cannot be undefined. egghead suggests to use strings because they r serializeable.

- 3rd principle:-pure n impure functions
pure functions:
> are predictable. they do NOT mutate their arguments/updatedb, etc.

impure functions:
> opp. of pure functions and have side-effects.
> they may operate on the DOM

---

u might have heard:- the UI layer is a MOST PREDICTABLE when it is describe as a pure function of the APPLICATION STATE.

Redux uses this and adds one more:=
> the state mutations in ur app need to be describe as a pure function
       - a pure function that takes the previous state + action-being-dispatched n returns the next-state of ur application.
        - the previous state should NOT be modified and should be kept pure .

So, pure function (previous-state,  action-being-dispatched) = next-state. this is the 3rd principle of redux. Such a pure function is called the reducer-function.
---

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 ng2-quick-recap
//creating a DStream manually
import Rx from 'rxjs/Rx';
dstream$ = Rx.observable({
    emitter => {
        emitter.next('val1');
        emitter.next('val2');
        emitter.complete();
    }
})
dstream$.subscribe();

//creating a dstream from events.
dstream$ = Rx.observable.fromEvent('btn', 'click');

//creating a dstream from variables.
dstream$ = Rx.observable.from([10, 20, 30]);

//creating a data stream from promises.
dstream$ = Rx.observable.fromPromise(some-Promise-defined-earlier);

const source$ = Rx.observable.interval(100)
                             .take(5); //take allows to complete. take only 5 vals.
const source$ = Rx.observable.timer(5000, 2000)
                             .take(5); //take allows to complete.

const source$ = Rx.observable.interval(100)
                             .take(5)
                             .map(v => v*v)  //sinceonly one line {} is NOT required.
                             ;
                            
---

IObservable, IObserver in angular2
Subject, Behavior Subject, Async Subject                            
Communicating between 2 components that are deeply nested:-
    1. EventEmitter: bad practise . bubbling event from child to parent is a deep cost.
    2. Use an observable in a service instead:- http://jasonwatmore.com/post/2016/12/01/angular-2-communicating-between-components-with-observable-subject
  
---  
ngrx: @ngrx/store

//1.
MathReducer.ts
- import {Action} from '@ngrx/store';
- define actions as serializable strings:- export const MULTIPLYBYTWO = 'MULTIPLYBYTWO';
- export function MathReducer(state:number = 2000, action:Action){ //1stparam is state, 2ndparam is an instance of Action.
    switch (action.type){
    case 'MULTIPLYBYTWO':
      return state * 2;
The MathReducer has to return a new state.

//2.
create child1 component:- ng g c child1

//3. child1.component.ts
import {Store} from '@ngrx/store';
import {Observable} from 'rxjs/Observable';

export class Child1Component implements OnInit {
  yr: Observable<number>; //step4.2. create an observable and

  constructor(private store: Store<AppState> ) {    //3.1 create an instance of Store.
    //we will then use this.store.select() and this.store.dispatch() .
    //select() and dispatch() are instance methods.
    this.yr = this.store.select('year');
  }

    multiplybytwo(){
    this.store.dispatch({ type: 'MULTIPLYBYTWO'})
  }
...

4. child1.component.html
<button (click) = multiplybytwo() >* by 2</button>
{{ yr | async }}

---

import {Routes, RouterModule} from '@angular/router'
const someRoutesVar:Routes = [
    {path: 'path1without/', component: 'component1'},
    {path: 'path2without/', component: 'component2'}
];

app.module.ts:-
    imports: [ RouterModule.forRoot(someRoutesVar), ... ]

<router-outler></router-outler>    as placeholder in .html
<a href="/server"></a>            dont use this . this will reload the page
<a routerLink="/server"></a>  USE this. this will PREVENT page reload.

---

---
++++++++++++++++++++++++++++++++++++++++++++++++

 atom snippets.cson
snippets.cson

# Your snippets
#
# Atom snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     'prefix': 'log'
#     'body': 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Atom Flight Manual:
# http://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson

'.source.ts':
  'jasmine describe':
    'prefix': 'aa'
    'body': """
      describe('', ()=>{
        it('', ()=>{
          expect().toBe();
          });
        });
    """  


+++++++++++++++++++++++++++++++++++++++++++++++

 css
https://stackoverflow.com/questions/41834019/angular2-with-haml


https://www.smashingmagazine.com/2009/06/fixed-vs-fluid-vs-elastic-layout-whats-the-right-one-for-you/
http://www.takeflyte.com/resources/newsletters/04/12-fluid-v-fixed-web-pages.php
    http://graybit.com/    FLUID
http://green-beast.com/blog/?p=199

http://browsersize.com/   -OR-  http://resizemybrowser.com/
http://setmy.browsersize.com/
http://whatsmy.browsersize.com/ (to check width in px)   
    Nowadays its 1024 * 768 for most users.
    960 pixels is the most that's safe, as it works on a 1024x768 screen and leaves room for the scrollbar
        VIMP:- https://webmasters.stackexchange.com/questions/7932/what-is-the-standard-width-for-a-website-in-pixels
        https://www.smashingmagazine.com/2009/06/fixed-vs-fluid-vs-elastic-layout-whats-the-right-one-for-you/

    DONT USE THIS:- https://www.w3schools.com/browsers/browsers_display.asp
        we should take w3schools data with a pinch of salt. (dont trust w3schools.com)

---
http://getbootstrap.com/css/
> ONLY col-md-1 * 12 = 12 stacked divs in mobile.
> If more than 12 columns are placed within a single row, each group of extra columns will, as one unit, wrap onto a new line.
    .col-xs-4
    Since 9 + 4 = 13 > 12, this 4-column-wide div gets wrapped onto a new line as one contiguous unit.
    .col-xs-6
    Subsequent columns continue along the new line.

---

quick floats: pull-left, pull-right (don't use in navbar, in navbar use: navbar-left, navbar-right)

.show, .hidden,

NOTE:- @ syntax below is for less. See http://getbootstrap.com/customize/#less-variables-section

.lighten, .darken
    @gray-dark:    lighten(#000, 20%);   // #333
    @gray:         lighten(#000, 33.5%); // #555

    @brand-primary: darken(#428bca, 6.5%); // #337ab7
    @brand-success: #5cb85c;
   
    // Variables
    @link-color:       @brand-primary;
    @link-hover-color: darken(@link-color, 15%);
   
    //Typography
    @font-size-base:          14px;
    @font-size-h5:            @font-size-base;

---   
    webkit:
        1. https://davidwalsh.name/webkit-css
            1a) -webkit-appearance
            Using the -webkit-appearance property, you can make a SPAN tag look like a radio button, or textarea, or SELECT dropdown
                span.lookLikeRadio {
                    -webkit-appearance: radio;
                }

                span.lookLikeTextarea {
                    -webkit-appearance: textarea;
                }
                   
---
    http://getbootstrap.com/javascript/
---
css3 animations
    @keyframes rule: https://www.w3schools.com/css/css3_animations.asp

css3 transitions   
    https://www.w3schools.com/css/css3_transitions.asp
     -webkit-transition: width 2s; /* Safari */
    transition: width 2s;
   
        https://www.w3schools.com/css/tryit.asp?filename=trycss3_transition4

https://stackoverflow.com/questions/18083056/css-what-are-moz-and-webkit       
-webkit for Chrome, Safari;
-moz for Firefox,
-o for Opera,
-ms for Internet Explorer       

---
center-block and mixin ex.
    http://getbootstrap.com/css/#helper-classes-clearfix

    // Class
    .center-block {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    // Usage as a mixin
    .element {
      .center-block();
    }
   
---
css-locks (for increasing font-size, line-height, etc. with viewport increase)
    https://fvsch.com/code/css-locks/
    https://css-tricks.com/viewport-sized-typography/

breakpoints in sass n css:
    http://breakpoint-sass.com/

---
w3 schools, css file:-    view-source:https://www.w3schools.com/cssref/css3_pr_mediaquery.asp
    #leftmenuinner { 
        box-shadow:0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
        overflow:auto;
        -webkit-overflow-scrolling:touch;
        height:100%;
        position:relative;
        width:auto;
        padding-top:0;
        background-color:#f1f1f1;
    }
---
https://www.w3schools.com/cssref/css3_pr_mediaquery.asp
media query:-
    @media only screen ... means @media not|only <mediatype> ... , the link shows deprecated and active mediatypes.
        - other "active" mediatypes are: all, printer, speech .
---
breakpoints using media queries:-
    1. https://stackoverflow.com/questions/16443380/common-css-media-queries-break-points
            @media only screen and (min-width: 768px) {
                /* tablets and desktop */
            }

            @media only screen and (max-width: 767px) {
                /* phones */
            }

            @media only screen and (max-width: 767px) and (orientation: portrait) {
                /* portrait phones */
            }

           
    2. http://bradfrost.com/blog/post/7-habits-of-highly-effective-media-queries/
    3. https://teamtreehouse.com/community/are-there-standard-media-query-break-points   
            /*==================================================
            =            Bootstrap 3 Media Queries             =
            ==================================================*/




                /*==========  Mobile First Method  ==========*/

                /* Custom, iPhone Retina */
                @media only screen and (min-width : 320px) {

                }

                /* Extra Small Devices, Phones */
                @media only screen and (min-width : 480px) {

                }

                /* Small Devices, Tablets */
                @media only screen and (min-width : 768px) {

                }

                /* Medium Devices, Desktops */
                @media only screen and (min-width : 992px) {

                }

                /* Large Devices, Wide Screens */
                @media only screen and (min-width : 1200px) {

                }



                /*==========  Non-Mobile First Method  ==========*/

                /* Large Devices, Wide Screens */
                @media only screen and (max-width : 1200px) {

                }

                /* Medium Devices, Desktops */
                @media only screen and (max-width : 992px) {

                }

                /* Small Devices, Tablets */
                @media only screen and (max-width : 768px) {

                }

                /* Extra Small Devices, Phones */
                @media only screen and (max-width : 480px) {

                }

                /* Custom, iPhone Retina */
                @media only screen and (max-width : 320px) {

                }   
           
    4. https://responsivedesign.is/develop/browser-feature-support/media-queries-for-common-device-breakpoints/
            /* Smartphones (portrait and landscape) ----------- */
            @media only screen and (min-device-width : 320px) and (max-device-width : 480px) {
            /* Styles */
            }

            /* Smartphones (landscape) ----------- */
            @media only screen and (min-width : 321px) {
            /* Styles */
            }

            /* Smartphones (portrait) ----------- */
            @media only screen and (max-width : 320px) {
            /* Styles */
            }

            /* iPads (portrait and landscape) ----------- */
            @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) {
            /* Styles */
            }

            /* iPads (landscape) ----------- */
            @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) {
            /* Styles */
            }

            /* iPads (portrait) ----------- */
            @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) {
            /* Styles */
            }
            /**********
            iPad 3
            **********/
            @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) and (-webkit-min-device-pixel-ratio : 2) {
            /* Styles */
            }

            @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) and (-webkit-min-device-pixel-ratio : 2) {
            /* Styles */
            }
            /* Desktops and laptops ----------- */
            @media only screen  and (min-width : 1224px) {
            /* Styles */
            }

            /* Large screens ----------- */
            @media only screen  and (min-width : 1824px) {
            /* Styles */
            }

            /* iPhone 4 ----------- */
            @media only screen and (min-device-width : 320px) and (max-device-width : 480px) and (orientation : landscape) and (-webkit-min-device-pixel-ratio : 2) {
            /* Styles */
            }

            @media only screen and (min-device-width : 320px) and (max-device-width : 480px) and (orientation : portrait) and (-webkit-min-device-pixel-ratio : 2) {
            /* Styles */
            }

            /* iPhone 5 ----------- */
            @media only screen and (min-device-width: 320px) and (max-device-height: 568px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            @media only screen and (min-device-width: 320px) and (max-device-height: 568px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            /* iPhone 6 ----------- */
            @media only screen and (min-device-width: 375px) and (max-device-height: 667px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            @media only screen and (min-device-width: 375px) and (max-device-height: 667px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            /* iPhone 6+ ----------- */
            @media only screen and (min-device-width: 414px) and (max-device-height: 736px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            @media only screen and (min-device-width: 414px) and (max-device-height: 736px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            /* Samsung Galaxy S3 ----------- */
            @media only screen and (min-device-width: 320px) and (max-device-height: 640px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            @media only screen and (min-device-width: 320px) and (max-device-height: 640px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 2){
            /* Styles */
            }

            /* Samsung Galaxy S4 ----------- */
            @media only screen and (min-device-width: 320px) and (max-device-height: 640px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 3){
            /* Styles */
            }

            @media only screen and (min-device-width: 320px) and (max-device-height: 640px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 3){
            /* Styles */
            }

            /* Samsung Galaxy S5 ----------- */
            @media only screen and (min-device-width: 360px) and (max-device-height: 640px) and (orientation : landscape) and (-webkit-device-pixel-ratio: 3){
            /* Styles */
            }

            @media only screen and (min-device-width: 360px) and (max-device-height: 640px) and (orientation : portrait) and (-webkit-device-pixel-ratio: 3){
            /* Styles */
            }

            http://bodasoaxaca.com/

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

RBCCOE

/*used for the minus sign*/
.BOX {
  width: 26px;
  height: 26px;
  background-color: #f7f7f7;
  border: solid 1px #efefef;
}
/*offers initial line */
.Line {
  /*width: 360.5px;*/
  width: 33%;  /*changed*/
  height: 2px;
  opacity: 0.25;
  border: solid 1px #979797;
  display:inline-block;
  /*added display:inline-block; its not there in zeplin */
}

/*Offers-Specifically*/
.Offers-Specifically {
  /*width: 561px;*/
  width: 25%; /*changed */
  height: 41px;
  font-family: Roboto;
  /*font-size: 35px;*/
  font-size: 20px; /* changed */
  font-weight: 300;
  text-align: center;
  color: #143e71;
  display:inline-block;
  /*added display:inline-block; its not there in zeplin */
}

/*used for offers only */
.Rectangle-7 {
  width: 336px;
  height: 455px;
  background-color: #ffffff;
  background-color: var(--white);
  border: solid 0.8px #333333;
  margin-left: 10px;
  margin-right: 30px;
}

/*offers: div1*/
.-Rain-X-Quantu {
  width: 296.5px;
  /*height: 93.3px;*/
  font-family: Roboto;
  font-size: 24px;
  font-weight: 300;
  line-height: 1.27;
  text-align: left;
  color: #143e71;
}

.-Rain-X-Quantu .text-style-1 {
  font-size: 19px;
  font-weight: normal;
  line-height: normal;
}

.-Rain-X-Quantu .text-style-2 {
  font-size: 12.5px;
  line-height: 1.93;
  color: #000000;
}

/*offers: div2*/
.Bitmap {
  width: 126px;
  height: 214.3px;
  object-fit: contain;
}

.div2_img{
  /*padding-top:25px; padding-bottom:25px; padding-left: 45px;*/
  display:block;
  margin-left:auto;
  margin-right:auto;
  margin-top:30px;
  margin-bottom:20px;
}

/*offers: button*/
.Rectangle-9-Copy-2 {
  width: 180px;
  height: 39px;
  background-color: #8b214b;
  /*background-color: var(--darkish-purple);*/
  bottom: -40px;
  border: 1px solid #8b214b;
}

/*offers: button text*/
.View-Details {
  /*width: 180px;*/
  /*height: 19px;*/
  font-family: Roboto;
  /*font-size: 14px;*/
  text-align: center;
  color: #ffffff;
  /*color: var(--white);*/
  /*color: white;*/
}

.section_padding{
  padding-top:10%; padding-left:10%
}


.Rectangle-9 {
  /*width: 177.5px;*/
  /*height: 41px;*/
  /*background-color: #8b214b;*/
  /*background-color: var(--darkish-purple);*/
  background-color: #8b214b;
}

/**********************TOUCH-PAINT******************/
.-Touch-Up-Paint {
  width: 296.5px;
  height: 93.3px;
  font-family: Roboto;
  font-size: 19px;
  font-weight: 300;
  line-height: 1.27;
  text-align: left;
  color: #143e71;
}

.-Touch-Up-Paint .text-style-1 {
  font-size: 38px;
  font-weight: normal;
  line-height: normal;
}

.-Touch-Up-Paint .text-style-2 {
  font-size: 12.5px;
  line-height: 1.93;
  color: #000000;
}

/*************BATTERY***********/
.-OFF-New-Battery {
  width: 295.5px;
  height: 94.1px;
  font-family: Roboto;
  font-size: 12.5px;
  font-weight: 300;
  line-height: 1.93;
  text-align: left;
  color: #000000;
}

.-OFF-New-Battery .text-style-1 {
  font-size: 38px;
  font-weight: normal;
  line-height: normal;
  color: #143e71;
}

.-OFF-New-Battery .text-style-2 {
  font-size: 19px;
  line-height: normal;
  color: #143e71;
}

/* offers: view all offers */
.View-all-offers {
  /*width: 158.1px;*/
  /*height: 19px;*/
  font-family: Roboto;
  font-size: 14px;
  letter-spacing: 1px;
  text-align: center;
  color: #4a4a4a;
  display:block;
  margin:auto;
}
.angle-double-right---FontAwesome {
  width: 12px;
  height: 20px;
  font-family: FontAwesome;
  font-size: 20px;
  color: #000000;
}

/*used for news and articles*/
.Mask {
  width: 336px;
  height: 520px;
  background-color: #ffffff;
  background-color: var(--white);
  box-shadow: 0 2px 13px 0 rgba(190, 190, 190, 0.5);
}




/***********LOAN*************/
.Line-Copy-5 {
  /*width: 383.5px;*/
  width: 35%;
  height: 2px;
  opacity: 0.25;
  border: solid 1px #979797;
  display: inline-block;
}

.Line-Copy-6 {
  /*width: 343.5px;*/
  width:35%;
  height: 2px;
  opacity: 0.25;
  border: solid 1px #979797;
  display: inline-block;

}

.Your-Loan-Information {
  /*width: 561px;*/
  /*height: 41px;*/
  width:25%;
  font-family: Roboto;
  /*font-size: 35px;*/
  font-size: 20px;
  font-weight: 300;
  text-align: center;
  color: #143e71;
  display: inline-block;

}


.Line-Copy-11 {
  width: 100px;
  height: 3px;
  border: solid 3px #143e71;
  display:block;
  margin:auto;
  margin-top: 10px;
}
.Rectangle-2 {
  width: 1440px;
  height: 450px;
  background-color: #f7f7f7;

}

.GRAPH {
  /*width: 695px;*/
  /*height: 339px;*/
  /*object-fit: contain;*/
  width: 95%;
  height: 65%;
}

.Sync-Your-Loan-Data {
  width: 426px;
  height: 45px;
  font-family: Roboto;
  font-size: 34px;
  font-weight: 300;
  text-align: left;
  color: #000000;
}

.Lorem-ipsum-dolor-si {
  width: 375px;
  height: 132px;
  font-family: Roboto;
  font-size: 14px;
  line-height: 1.57;
  text-align: left;
  color: #2b2b2b;
}

.Rectangle-Copy-2 {
  width: 260px;
  height: 42px;
  background-color: #8b214b;
  background-color: var(--darkish-purple);
}

.Add-Loan-Data {
  width: 126px;
  height: 42.3px;
  font-family: Roboto;
  font-size: 14px;
  line-height: 3.03;
  text-align: center;
  color: #ffffff;
  /*color: var(--white);*/
}

.Id-like-to-learn-mo {
  width: 260px;
  height: 18px;
  font-family: Roboto;
  font-size: 13.2px;
  font-weight: 500;
  text-align: left;
  color: #000000;
  text-decoration: none;

}

.loan{
  margin-top: 20px;
}

.loan_graph{
  display:block;
  margin:auto;
}

/************RECALLS************/
.Line-Copy-20 {
  /*width: 503.5px;*/
  width: 46%;
  height: 2px;
  opacity: 0.25;
  border: solid 1px #979797;
  display: inline-block;
}

.Recalls {
  /*width: 561px;*/
  /*height: 41px;*/
  font-family: Roboto;
  /*font-size: 35px;*/
  font-size: 24px;
  width: 7%;
  font-weight: 300;
  text-align: center;
  color: #143e71;
  display: inline-block;
}

.Line-Copy-8 {
  /*width: 463.5px;*/
  width: 42%;
  height: 2px;
  opacity: 0.25;
  border: solid 1px #979797;
  display: inline-block;

}

.Line-Copy-16 {
  width: 100px;
  height: 3px;
  border: solid 3px #143e71;
  display:block;
  margin:auto;
}

.Recall-Date {
  /*width: 67px;*/
  width: 10%;
  height: 15px;
  font-family: Roboto;
  font-size: 13px;
  font-weight: bold;
  text-align: left;
  color: #000000;
  display: inline-block;
}

.Description {
  /*width: 67px;*/
  width: 80%;
  height: 15px;
  font-family: Roboto;
  font-size: 13px;
  font-weight: bold;
  text-align: left;
  color: #000000;
  display: inline-block;

}

.Rectangle-8 {
  /*width: 1132.7px;*/
  height: 216px;
  background-color: #f7f7f7;
  display:inline-block;

}

.recalls-table-left{

}

.recalls-table-right-margin{
  margin-top:20px
}

.left-layer1 {
  /*width: 116px;*/
  width:10%;
  height: 32px;
  font-family: Roboto;
  font-size: 14px;
  font-weight: 300;
  text-align: left;
  color: #000000;
  display:inline-block;
  vertical-align: top;
  margin-top: 20px;
}

.Recall-Number-YX-10 {
  /*width: 833px;*/
  width: 80%;
  height: 209px;
  font-family: Roboto;
  font-size: 14px;
  font-weight: 300;
  text-align: left;
  /*color: #000000;*/
  display:inline-block;
}

.Recall-Number-YX-10 .text-style-1 {
  /*color: #4a90e2;*/
}


.Air-Bag-Deployment {
  /*width: 838px;*/
  width: 80%;
  height: 48px;
  font-family: Roboto;
  font-size: 14px;
  font-weight: 300;
  text-align: left;
  color: #000000;
  display: inline-block;
}

.Air-Bag-Deployment .text-style-1 {
  color: #4a90e2;
}

.Seat-Belt-Driver-Si {
  /*width: 842px;*/
  width:80%;
  height: 48px;
  font-family: Roboto;
  font-size: 14px;
  font-weight: 300;
  text-align: left;
  color: #000000;
  display:inline-block;
}

.Seat-Belt-Driver-Si .text-style-1 {
  color: #4a90e2;
}

.Electrical-Failure {
  /*width: 845px;*/
  width: 80%;
  height: 57px;
  font-family: Roboto;
  font-size: 14px;
  font-weight: 300;
  text-align: left;
  color: #000000;
  display:inline-block;
}

.Electrical-Failure .text-style-1 {
  color: #4a90e2;
}

 <div class="Line"></div>
           <div class="Offers-Specifically">xxx</div>
           <div class="Line"></div>
           
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 div tricks
eg. 1 2 column, side-by-side using span + display: inline-block (avoid using float:left , even if it works)

.vertical_line{
  border-right: 1px solid grey;
}

.div-col-width{
  /*width:50%;*/
  display:inline-block;
  /*display:flex;*/
  /*border-right: 1px solid grey;*/
  /*float:left;*/
}

.div1{
  /*display: inline-block;*/
  /*display:flex;*/
  /*float:left;*/
}


<div class="container">
  <div class="row">
    <div class="col-xs-4 col-sm-4 col-md-4 div-col-width vertical_line">
      <!-- <div class=" vertical_line div1"> -->

        <span>sssssssss</span> <button> xxx </button>
        <span>sssssssss</span>
        <span>sssssssss</span>
        <span>sssssssss</span>
        <span>sssssssss</span>
      <!-- </div> -->
    </div>
    <div class="col-xs-8 col-sm-8 col-md-8 div-col-width" >
        <!-- <div class="div1"> -->
            <span>aaaa</span><button> xxx </button>
            <span>aaaa</span>
            <span>aaaa</span>
            <span>aaaa</span>
            <span>aaaa</span>
          <!-- </div> -->
    </div>
  </div>
</div>

xxxxxxxxxxx 

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 migration plan
Migration plan:-
MILESTONE 1.
https://blog.thoughtram.io/angular/2015/10/24/upgrading-apps-to-angular-2-using-ngupgrade.html
> structuring:- ng1 folder structure should be feature based. like ng2. (like moda in ng1)
    >> make ng1 app work using this new structure.
> use .service() instead of .factory()
    >> >> https://blog.thoughtram.io/angular/2015/07/07/service-vs-factory-once-and-for-all.html
> writing new components in ES6 n TS.    
> identifying dumb components n move to .components(), so that ng2 equivalent code can be written.

MILESTONE 2.        
ngUpgrade. The module basically acts as an adapter facade, so we don’t really feel that there are two frameworks running side-by-side.
The typical upgrade process
Here’s what a typical upgrade process would look like:-
    Include Angular and upgrade module
    Pick component to upgrade and change its controller and template Angular 2.x syntax (this is now an Angular 2.x component)
    Downgrade Angular 2.x component to make it run in Angular 1.x app
    Pick a service to upgrade, this usually requires little amount of change (especially if we’re on ES2015)
    Repeat step 2 and 3 (and 4)
    Replace Angular 1 bootstrap with Angular 2.x bootstrap

Sample demo:-
    1. https://github.com/thoughtram/angular-upgrade-demo
    2. https://angular.io/guide/upgrade
    3. https://gist.github.com/bcherny/8f35f5e5ff62b09ce7b3ef9cbf637ee9 (ang.1. using ts)
            http://www.developerhandbook.com/typescript/writing-angularjs-1-x-with-typescript/ 
           
Communicating between components in ng2
http://jasonwatmore.com/post/2016/12/01/angular-2-communicating-between-components-with-observable-subject

upgrade cheatsheet:-
https://angular.io/guide/ajs-quick-reference  VIMP!!!

webpack2 for angular2:-
    https://github.com/AngularClass/angular-starter (Detailed ng2 starter kit for dev n prod, using webpack2)
    https://github.com/wkwiatek/angular2-webpack2 (mini starter kit)
    https://semaphoreci.com/community/tutorials/setting-up-angular-2-with-webpack
    http://www.dotnetcurry.com/angularjs/1320/using-webpack-bundling-with-angular-2
    https://damienbod.com/2017/01/14/angular-2-lazy-loading-with-webpack-2/
    https://webpack.github.io/
        http://webpack.github.io/docs/
        http://webpack.github.io/docs/what-is-webpack.html
        http://webpack.github.io/docs/tutorials/getting-started/
       
---
yarn with angular2:-  https://yakovfain.com/2016/11/06/angular-cli-speed-up-installing-dependencies-with-yarn/
    ng new sampleProj
    The above command will generate the boilerplate code of the project in the directory sampleProj with package.json and will immediately run npm install there.

Deterministic installation using yarn:-

    ng set --global packageManager=yarn
    npm install -g yarn
    ng new --skip-install sampleProj
    cd sampleProj
    yarn
    npm set strict-ssl false
    yarn

---
Q. Is yarn really deterministic? How about a test?
A. We will check if same versions of packages were installed or not (before and after deleting node_modules/ folder)

1) yarn list > yarn_list_1.txt
    D:\js\ng2\test02\sampleProj>yarn list > yarn_list_1.txt   
2) Delete node_modules/ folder
3) yarn (same as "yarn install") .
    Parallely also install Ultraedit to compare both yarn_list_1.txt and yarn_list_2.txt (which we will create soon)
4) yarn list > yarn_list_2.txt
5) Open both files in ultraedit compare and only 1 line is different i.e. Done in x.xxs.
   
   
> Delete node_modules/ folder
    npm install
> npm list > npm_list_2.txt.
    Now lets compare yarn_list_1.txt and npm_list_2.txt and we can already see many diff:-

        eg.1.
        package.json: No entry. this is a dependency
        yarn: autoprefixer@^6.5.3. Both time same version. in yarn_list_1.txt , yarn_list_2.txt
        npm: autoprefixer@6.7.7
       
        package.json: No entry. this is a dependency
        yarn: lodash@^4.11.1       Both time same version. in yarn_list_1.txt , yarn_list_2.txt
        npm: lodash@4.17.4
   
        eg.2. https://stackoverflow.com/questions/22343224/whats-the-difference-between-tilde-and-caret-in-package-json
        package.json: ^5.1.0
        yarn: rxjs@^5.0.1
        npm: rxjs@5.4.2
       
        package.json: "zone.js": "^0.8.4"
        yarn: zone.js@0.8.12
        zone.js@0.8.12
       
        Looks like both yarn and npm r not picking any version. Looks that way. But isnt.
        0.8.12 ===> major(breakingchange).minor(refactoring,backward compatibility, etc.).patch(bugfixes)
        minor is denoted by ^
        patch is denoted by ~
       
        https://stackoverflow.com/questions/22343224/whats-the-difference-between-tilde-and-caret-in-package-json
        ^version     "Compatible with version"
        ~version     "Approximately equivalent to version"
         version     Must match version exactly
       
         eg. 3. How does yarn & npm behave when we use exact versions ??
         package.json
             "rxjs": "5.1.0",
             "zone.js": "0.8.4"
           
            > Delete node_modules/
            > yarn
            > yarn list > yarn_list_3_1.txt
       
            > Delete node_modules/
            > npm install
            > npm list > npm_list_3_1.txt
           
            Compare:   
                yarn n npm both got exact versions. However, rxjs uses a symbol-observable sub-package and :-
                    for it, yarn: 1.0.1 , npm : 1.0.4
   
Continue to use yarn.
Running npm install on two different machines can result in different dependencies being installed on each machine. These two machines could be two developer machines.
Or, much more problematic, they could be a development machine and a production machine.
If the same dependency list goes in, the same node_modules folder should come out.

    npm claims to do what yarn does using "npm shrinkwrap" but pundits rebuff this. See this:- http://jonnyreeves.co.uk/2016/npm-shrinkwrap-sucks/
   
---
    https://scotch.io/tutorials/yarn-package-manager-an-improvement-over-npm
   
    Adding Babel, sass and webpack to yarn:-
    https://medium.com/front-end-hacking/what-are-npm-yarn-babel-and-webpack-and-how-to-properly-use-them-d835a758f987
   
    Did not add:- (as these are already there in the ng-cli-skeleton ) webpack  babel-preset-react  css-loader  node-sass  sass-loader  style-loader
   
    yarn add --dev  babel-core babel-loader  babel-preset-es2015

---   

Lets start with webpack:-

webpack.config.js:-
    var config = {
      entry: 'src/app/index.js',
      output:{
        path: 'src/dist',
        filename: 'build.js',
      }
    };

    module.exports = config;

edit package.json
scripts->build: ng run build / ng build ??
Also, cli has src/dist defined so use another ABSOLUTE path.

---

toaster-service in angular1.

app.factory("Data", ['$http', 'toaster',
    function ($http, toaster) { // This service connects to our REST API

        var serviceBase = 'api/v1/';

        var obj = {};
        obj.toast = function (data) {
            toaster.pop(data.status, "", data.message, 10000, 'trustedHtml');
        }

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ng eject

C:\Users\Dell\Desktop\crap\crap1proj>ng eject

==========================================================================================

Ejection was successful.


To run your builds, you now need to do the following commands:

   - "npm run build" to build.

   - "npm run test" to run unit tests.

   - "npm start" to serve the app using webpack-dev-server.

   - "npm run e2e" to run protractor.


Running the equivalent CLI commands will result in an error.


==========================================================================================

Some packages were added. Please run "npm install".



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


ng eject

 - updates .angular-cli.json

 "project": {

    "name": "crap1proj",

    "ejected": true

  },

- updated package.json with some more new packages. so before doing anything else, u will have to do "npm install" once more.

See package.json

"scripts": {

    "ng": "ng",

    "start": "webpack-dev-server --port=4200",

    "build": "webpack",

    "test": "karma start ./karma.conf.js",

    "lint": "ng lint",

    "e2e": "protractor ./protractor.conf.js",

    "prepree2e": "npm start",

    "pree2e": "webdriver-manager update --standalone false --gecko false --quiet"

  },

- now webpack.config.js has also got created in the root of ur project folder.



xxx

ng eject

ng eject --prod

      webpack --config webpack.config-prod.js


Undo "ng eject":


- delete webpack.config.js

- keep ejected:false in .angular-cli.json

- re-run ng build ?


=======

IMP #1 to un-eject:- (Running the app on IE 11 as well; by default it works only on FF n chrome)


remove from .cli.json

delete webpack.config.js

delete dist folder

ng build

   - this recreates the dist folder

   -

npm i -g http-server

installed ie11

  

---


remove from .cli.json

delete webpack.config.js

delete dist folder

ng build

   - this recreates the dist folder

   -

npm i -g http-server (This allows us to turn any folder into a DOCUMENTROOT. if it has an index.html in it)

- We will run http-server on the dist/ folder of our application.

cd dist/

http-server (default is 8080 port)

   http-server -p 9000


installed ie11

   http-server doesn't work for IE

Refer  https://github.com/angular/angular-cli/issues/5226  <<!!! VIMP

   uncomment lines in polyfills.ts &  ng build (failed)

   npm install --save classlist.js

   npm install --save web-animations-js

   ng build (worked!!)

   cd dist

   http-server -p 9000

   (works on FF n IE 11 n )


---  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
